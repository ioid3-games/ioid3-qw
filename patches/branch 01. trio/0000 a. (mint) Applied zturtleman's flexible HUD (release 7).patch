Index: code/cgame/cg_consolecmds.c
===================================================================
--- code/cgame/cg_consolecmds.c	(revision 3317)
+++ code/cgame/cg_consolecmds.c	(working copy)
@@ -134,6 +134,7 @@
 	}
 
 	CG_LoadMenus(hudSet);
+	CG_HudMenuHacks();
   menuScoreboard = NULL;
 }
 
Index: code/cgame/cg_draw.c
===================================================================
--- code/cgame/cg_draw.c	(revision 3317)
+++ code/cgame/cg_draw.c	(working copy)
@@ -242,6 +242,10 @@
 		l = width;
 	x += 2 + CHAR_WIDTH*(width - l);
 
+	// center x, move y to bottom.
+	x += (1.0f-cg_statusScale.value)*l*CHAR_WIDTH*0.5f;
+	y += (1.0f-cg_statusScale.value)*CHAR_HEIGHT;
+
 	ptr = num;
 	while (*ptr && l)
 	{
@@ -250,8 +254,8 @@
 		else
 			frame = *ptr -'0';
 
-		CG_DrawPic( x,y, CHAR_WIDTH, CHAR_HEIGHT, cgs.media.numberShaders[frame] );
-		x += CHAR_WIDTH;
+		CG_DrawPic( x,y, CHAR_WIDTH*cg_statusScale.value, CHAR_HEIGHT*cg_statusScale.value, cgs.media.numberShaders[frame] );
+		x += CHAR_WIDTH*cg_statusScale.value;
 		ptr++;
 		l--;
 	}
@@ -304,6 +308,58 @@
 
 /*
 ================
+CG_DrawHealthModel
+
+================
+*/
+void CG_DrawHealthModel( float x, float y, float w, float h, qhandle_t model, qhandle_t skin, qhandle_t model2, vec3_t origin, vec3_t angles, float yaw2 ) {
+	refdef_t		refdef;
+	refEntity_t		ent;
+
+	if ( !cg_draw3dIcons.integer || !cg_drawIcons.integer ) {
+		return;
+	}
+
+	CG_AdjustFrom640( &x, &y, &w, &h );
+
+	memset( &refdef, 0, sizeof( refdef ) );
+
+	memset( &ent, 0, sizeof( ent ) );
+	AnglesToAxis( angles, ent.axis );
+	VectorCopy( origin, ent.origin );
+	ent.hModel = model;
+	ent.customSkin = skin;
+	ent.renderfx = RF_NOSHADOW;		// no stencil shadows
+
+	refdef.rdflags = RDF_NOWORLDMODEL;
+
+	AxisClear( refdef.viewaxis );
+
+	refdef.fov_x = 30;
+	refdef.fov_y = 30;
+
+	refdef.x = x;
+	refdef.y = y;
+	refdef.width = w;
+	refdef.height = h;
+
+	refdef.time = cg.time;
+
+	trap_R_ClearScene();
+	trap_R_AddRefEntityToScene( &ent );
+
+	if ( model2 ) {
+		ent.hModel = model2;
+		angles[YAW] = yaw2;
+		AnglesToAxis( angles, ent.axis );
+		trap_R_AddRefEntityToScene( &ent );
+	}
+
+	trap_R_RenderScene( &refdef );
+}
+
+/*
+================
 CG_DrawHead
 
 Used for both the status bar and the scoreboard
@@ -465,7 +521,7 @@
 	angles[YAW] = cg.headStartYaw + ( cg.headEndYaw - cg.headStartYaw ) * frac;
 	angles[PITCH] = cg.headStartPitch + ( cg.headEndPitch - cg.headStartPitch ) * frac;
 
-	CG_DrawHead( x, 480 - size, size, size, 
+	CG_DrawHead( x+(1.0f-cg_statusScale.value)*size*0.5f, 480 - size*cg_statusScale.value, size*cg_statusScale.value, size*cg_statusScale.value, 
 				cg.snap->ps.clientNum, angles );
 }
 #endif // MISSIONPACK
@@ -478,7 +534,8 @@
 */
 #ifndef MISSIONPACK
 static void CG_DrawStatusBarFlag( float x, int team ) {
-	CG_DrawFlagModel( x, 480 - ICON_SIZE, ICON_SIZE, ICON_SIZE, team, qfalse );
+	int iconSize = ICON_SIZE*cg_statusScale.value;
+	CG_DrawFlagModel( x+(1.0f-cg_statusScale.value)*ICON_SIZE*0.5f, 480 - iconSize, iconSize, iconSize, team, qfalse );
 }
 #endif // MISSIONPACK
 
@@ -505,7 +562,9 @@
 		return;
 	}
 	trap_R_SetColor( hcolor );
+	CG_SetScreenPlacement(PLACE_STRETCH, CG_GetScreenVerticalPlacement());
 	CG_DrawPic( x, y, w, h, cgs.media.teamStatusBar );
+	CG_PopScreenPlacement();
 	trap_R_SetColor( NULL );
 }
 
@@ -524,6 +583,7 @@
 	vec4_t		hcolor;
 	vec3_t		angles;
 	vec3_t		origin;
+	float		scale, iconSize;
 
 	static float colors[4][4] = { 
 //		{ 0.2, 1.0, 0.2, 1.0 } , { 1.0, 0.2, 0.2, 1.0 }, {0.5, 0.5, 0.5, 1} };
@@ -536,8 +596,14 @@
 		return;
 	}
 
+	CG_SetScreenPlacement(PLACE_CENTER, PLACE_BOTTOM);
+
+	scale = Com_Clamp( 0.1f, 2, cg_statusScale.value);
+
+	iconSize = scale * ICON_SIZE;
+
 	// draw the team background
-	CG_DrawTeamBackground( 0, 420, 640, 60, 0.33f, cg.snap->ps.persistant[PERS_TEAM] );
+	CG_DrawTeamBackground( 0, 480 - 60*scale, 640, 60*scale, 0.33f, cg.snap->ps.persistant[PERS_TEAM] );
 
 	cent = &cg_entities[cg.snap->ps.clientNum];
 	ps = &cg.snap->ps;
@@ -550,12 +616,26 @@
 		origin[1] = 0;
 		origin[2] = 0;
 		angles[YAW] = 90 + 20 * sin( cg.time / 1000.0 );
-		CG_Draw3DModel( CHAR_WIDTH*3 + TEXT_ICON_SPACE, 432, ICON_SIZE, ICON_SIZE,
+		CG_Draw3DModel( CHAR_WIDTH*3 + TEXT_ICON_SPACE, 480-iconSize, iconSize, iconSize,
 					   cg_weapons[ cent->currentState.weapon ].ammoModel, 0, origin, angles );
 	}
 
-	CG_DrawStatusBarHead( 185 + CHAR_WIDTH*3 + TEXT_ICON_SPACE );
+	if ( cg_drawStatusHead.integer == 2 ) {
+		origin[0] = 60;
+		origin[1] = 0;
+		origin[2] = -5;
+		angles[YAW] = ( cg.time & 2047 ) * 360 / 4096.0;
+		CG_DrawHealthModel( 185 + CHAR_WIDTH*3 + TEXT_ICON_SPACE, 480-iconSize, iconSize, iconSize,
+					   cg_items[ 6 /*item_health_large*/].models[0], 0, cg_items[ 6 /*item_health_large*/].models[1], origin, angles, 0 );
 
+		// if we didn't draw a 3D icon, draw a 2D icon for health
+		if ( !cg_draw3dIcons.integer && cg_drawIcons.integer ) {
+			CG_DrawPic( 185 + CHAR_WIDTH*3 + TEXT_ICON_SPACE, 480 - iconSize, iconSize, iconSize, cg_items[6/*item_health_large*/].icon );
+		}
+	}
+	else if ( cg_drawStatusHead.integer == 1 )
+		CG_DrawStatusBarHead( 185 + CHAR_WIDTH*3 + TEXT_ICON_SPACE );
+
 	if( cg.predictedPlayerState.powerups[PW_REDFLAG] ) {
 		CG_DrawStatusBarFlag( 185 + CHAR_WIDTH*3 + TEXT_ICON_SPACE + ICON_SIZE, TEAM_RED );
 	} else if( cg.predictedPlayerState.powerups[PW_BLUEFLAG] ) {
@@ -569,7 +649,7 @@
 		origin[1] = 0;
 		origin[2] = -10;
 		angles[YAW] = ( cg.time & 2047 ) * 360 / 2048.0;
-		CG_Draw3DModel( 370 + CHAR_WIDTH*3 + TEXT_ICON_SPACE, 432, ICON_SIZE, ICON_SIZE,
+		CG_Draw3DModel( 370 + CHAR_WIDTH*3 + TEXT_ICON_SPACE, 480 - iconSize, iconSize, iconSize,
 					   cgs.media.armorModel, 0, origin, angles );
 	}
 	//
@@ -600,7 +680,7 @@
 
 				icon = cg_weapons[ cg.predictedPlayerState.weapon ].ammoIcon;
 				if ( icon ) {
-					CG_DrawPic( CHAR_WIDTH*3 + TEXT_ICON_SPACE, 432, ICON_SIZE, ICON_SIZE, icon );
+					CG_DrawPic( CHAR_WIDTH*3 + TEXT_ICON_SPACE, 480 - iconSize, iconSize, iconSize, icon );
 				}
 			}
 		}
@@ -637,7 +717,7 @@
 		trap_R_SetColor( NULL );
 		// if we didn't draw a 3D icon, draw a 2D icon for armor
 		if ( !cg_draw3dIcons.integer && cg_drawIcons.integer ) {
-			CG_DrawPic( 370 + CHAR_WIDTH*3 + TEXT_ICON_SPACE, 432, ICON_SIZE, ICON_SIZE, cgs.media.armorIcon );
+			CG_DrawPic( 370 + CHAR_WIDTH*3 + TEXT_ICON_SPACE, 480 - iconSize, iconSize, iconSize, cgs.media.armorIcon );
 		}
 
 	}
@@ -981,6 +1061,8 @@
 
 	y = 0;
 
+	CG_SetScreenPlacement(PLACE_RIGHT, PLACE_TOP);
+
 	if ( cgs.gametype >= GT_TEAM && cg_drawTeamOverlay.integer == 1 ) {
 		y = CG_DrawTeamOverlay( y, qtrue, qtrue );
 	} 
@@ -1024,6 +1106,10 @@
 	float		y1;
 	gitem_t		*item;
 
+	if ( !cg_drawScores.integer ) {
+		return y;
+	}
+
 	s1 = cgs.scores1;
 	s2 = cgs.scores2;
 
@@ -1280,6 +1366,8 @@
 
 	y = 480 - ICON_SIZE;
 
+	CG_SetScreenPlacement(PLACE_RIGHT, PLACE_BOTTOM);
+
 	if ( cgs.gametype >= GT_TEAM && cg_drawTeamOverlay.integer == 2 ) {
 		y = CG_DrawTeamOverlay( y, qtrue, qfalse );
 	} 
@@ -1298,13 +1386,22 @@
 static int CG_DrawPickupItem( int y ) {
 	int		value;
 	float	*fadeColor;
+	float	iconSize, charWidth, charHeight;
 
+	if ( cg_drawPickups.value <= 0 ) {
+		return y;
+	}
+
 	if ( cg.snap->ps.stats[STAT_HEALTH] <= 0 ) {
 		return y;
 	}
 
-	y -= ICON_SIZE;
+	iconSize = ICON_SIZE*cg_drawPickups.value;
+	charWidth = BIGCHAR_WIDTH*cg_drawPickups.value;
+	charHeight = BIGCHAR_HEIGHT*cg_drawPickups.value;
 
+	y -= iconSize;
+
 	value = cg.itemPickup;
 	if ( value ) {
 		fadeColor = CG_FadeColor( cg.itemPickupTime, 3000 );
@@ -1311,8 +1408,8 @@
 		if ( fadeColor ) {
 			CG_RegisterItemVisuals( value );
 			trap_R_SetColor( fadeColor );
-			CG_DrawPic( 8, y, ICON_SIZE, ICON_SIZE, cg_items[ value ].icon );
-			CG_DrawBigString( ICON_SIZE + 16, y + (ICON_SIZE/2 - BIGCHAR_HEIGHT/2), bg_itemlist[ value ].pickup_name, fadeColor[0] );
+			CG_DrawPic( 8, y, iconSize, iconSize, cg_items[ value ].icon );
+			CG_DrawStringExt( iconSize + 16, y + (iconSize/2 - charHeight/2), bg_itemlist[ value ].pickup_name, fadeColor, qfalse, qtrue, charWidth, charHeight, 0 );
 			trap_R_SetColor( NULL );
 		}
 	}
@@ -1333,6 +1430,8 @@
 
 	y = 480 - ICON_SIZE;
 
+	CG_SetScreenPlacement(PLACE_LEFT, PLACE_BOTTOM);
+
 	if ( cgs.gametype >= GT_TEAM && cg_drawTeamOverlay.integer == 3 ) {
 		y = CG_DrawTeamOverlay( y, qfalse, qfalse );
 	} 
@@ -1367,6 +1466,8 @@
 	if (chatHeight <= 0)
 		return; // disabled
 
+	CG_SetScreenPlacement( PLACE_LEFT, PLACE_BOTTOM );
+
 	if (cgs.teamLastChatPos != cgs.teamChatPos) {
 		if (cg.time - cgs.teamChatMsgTimes[cgs.teamLastChatPos % chatHeight] > cg_teamChatTime.integer) {
 			cgs.teamLastChatPos++;
@@ -1417,6 +1518,8 @@
 static void CG_DrawHoldableItem( void ) { 
 	int		value;
 
+	CG_SetScreenPlacement(PLACE_RIGHT, PLACE_CENTER);
+
 	value = cg.snap->ps.stats[STAT_HOLDABLE_ITEM];
 	if ( value ) {
 		CG_RegisterItemVisuals( value );
@@ -1436,6 +1539,8 @@
 static void CG_DrawPersistantPowerup( void ) { 
 	int		value;
 
+	CG_SetScreenPlacement(PLACE_RIGHT, PLACE_CENTER);
+
 	value = cg.snap->ps.stats[STAT_PERSISTANT_POWERUP];
 	if ( value ) {
 		CG_RegisterItemVisuals( value );
@@ -1461,6 +1566,8 @@
 		return;
 	}
 
+	CG_SetScreenPlacement(PLACE_CENTER, PLACE_CENTER);
+
 	color = CG_FadeColor( cg.rewardTime, REWARD_TIME );
 	if ( !color ) {
 		if (cg.rewardStack > 0) {
@@ -1601,6 +1708,8 @@
 		return;
 	}
 
+	CG_SetScreenPlacement(PLACE_CENTER, PLACE_CENTER);
+
 	// also add text in center of screen
 	s = "Connection Interrupted";
 	w = CG_DrawStrlen( s ) * BIGCHAR_WIDTH;
@@ -1611,6 +1720,8 @@
 		return;
 	}
 
+	CG_SetScreenPlacement(PLACE_RIGHT, PLACE_BOTTOM);
+
 #ifdef MISSIONPACK
 	x = 640 - 48;
 	y = 480 - 144;
@@ -1643,6 +1754,8 @@
 		return;
 	}
 
+	CG_SetScreenPlacement(PLACE_RIGHT, PLACE_BOTTOM);
+
 	//
 	// draw the graph
 	//
@@ -1800,6 +1913,8 @@
 		return;
 	}
 
+	CG_SetScreenPlacement(PLACE_CENTER, PLACE_CENTER);
+
 	trap_R_SetColor( color );
 
 	start = cg.centerPrint;
@@ -1881,6 +1996,8 @@
 		return;
 	}
 
+	CG_SetScreenPlacement(PLACE_CENTER, PLACE_CENTER);
+
 	// set color based on health
 	if ( cg_crosshairHealth.integer ) {
 		vec4_t		hcolor;
@@ -1903,7 +2020,6 @@
 
 	x = cg_crosshairX.integer;
 	y = cg_crosshairY.integer;
-	CG_AdjustFrom640( &x, &y, &w, &h );
 
 	ca = cg_drawCrosshair.integer;
 	if (ca < 0) {
@@ -1911,9 +2027,7 @@
 	}
 	hShader = cgs.media.crosshairShader[ ca % NUM_CROSSHAIRS ];
 
-	trap_R_DrawStretchPic( x + cg.refdef.x + 0.5 * (cg.refdef.width - w), 
-		y + cg.refdef.y + 0.5 * (cg.refdef.height - h), 
-		w, h, 0, 0, 1, 1, hShader );
+	CG_DrawPic( ((SCREEN_WIDTH-w)*0.5f)+x, ((SCREEN_HEIGHT-h)*0.5f)+y, w, h, hShader );
 
 	trap_R_SetColor( NULL );
 }
@@ -2051,6 +2165,8 @@
 		return;
 	}
 
+	CG_SetScreenPlacement(PLACE_CENTER, PLACE_CENTER);
+
 	// scan the known entities to see if the crosshair is sighted on one
 	CG_ScanForCrosshairEntity();
 
@@ -2082,6 +2198,7 @@
 =================
 */
 static void CG_DrawSpectator(void) {
+	CG_SetScreenPlacement(PLACE_CENTER, PLACE_BOTTOM);
 	CG_DrawBigString(320 - 9 * 8, 440, "SPECTATOR", 1.0F);
 	if ( cgs.gametype == GT_TOURNAMENT ) {
 		CG_DrawBigString(320 - 15 * 8, 460, "waiting to play", 1.0F);
@@ -2104,6 +2221,8 @@
 		return;
 	}
 
+	CG_SetScreenPlacement(PLACE_LEFT, PLACE_TOP);
+
 	// play a talk beep whenever it is modified
 	if ( cgs.voteModified ) {
 		cgs.voteModified = qfalse;
@@ -2145,6 +2264,8 @@
 		return;
 	}
 
+	CG_SetScreenPlacement(PLACE_LEFT, PLACE_TOP);
+
 	// play a talk beep whenever it is modified
 	if ( cgs.teamVoteModified[cs_offset] ) {
 		cgs.teamVoteModified[cs_offset] = qfalse;
@@ -2165,6 +2286,8 @@
 #ifdef MISSIONPACK
 	static qboolean firstTime = qtrue;
 
+	CG_SetScreenPlacement(PLACE_CENTER, PLACE_CENTER);
+
 	if (menuScoreboard) {
 		menuScoreboard->window.flags &= ~WINDOW_FORCED;
 	}
@@ -2259,6 +2382,9 @@
 	if ( !(cg.snap->ps.pm_flags & PMF_FOLLOW) ) {
 		return qfalse;
 	}
+
+	CG_SetScreenPlacement(PLACE_CENTER, PLACE_TOP);
+
 	color[0] = 1;
 	color[1] = 1;
 	color[2] = 1;
@@ -2295,6 +2421,8 @@
 		return;
 	}
 
+	CG_SetScreenPlacement(PLACE_CENTER, PLACE_TOP);
+
 	if ( cg.lowAmmoWarning == 2 ) {
 		s = "OUT OF AMMO";
 	} else {
@@ -2322,6 +2450,8 @@
 		return;
 	}
 
+	CG_SetScreenPlacement(PLACE_CENTER, PLACE_TOP);
+
   if (proxTime == 0) {
     proxTime = cg.time;
   }
@@ -2362,6 +2492,8 @@
 		return;
 	}
 
+	CG_SetScreenPlacement(PLACE_CENTER, PLACE_TOP);
+
 	if ( sec < 0 ) {
 		s = "Waiting for players";		
 		w = CG_DrawStrlen( s ) * BIGCHAR_WIDTH;
@@ -2558,6 +2690,8 @@
 
 #ifdef MISSIONPACK
 			if ( cg_drawStatus.integer ) {
+				CG_SetScreenPlacement(PLACE_CENTER, PLACE_BOTTOM);
+
 				Menu_PaintAll();
 				CG_DrawTimedMenus();
 			}
Index: code/cgame/cg_drawtools.c
===================================================================
--- code/cgame/cg_drawtools.c	(revision 3317)
+++ code/cgame/cg_drawtools.c	(working copy)
@@ -23,8 +23,58 @@
 // cg_drawtools.c -- helper functions called by cg_draw, cg_scoreboard, cg_info, etc
 #include "cg_local.h"
 
+static screenPlacement_e cg_horizontalPlacement = PLACE_CENTER;
+static screenPlacement_e cg_verticalPlacement = PLACE_CENTER;
+static screenPlacement_e cg_lastHorizontalPlacement = PLACE_CENTER;
+static screenPlacement_e cg_lastVerticalPlacement = PLACE_CENTER;
+
 /*
 ================
+CG_SetScreenPlacement
+================
+*/
+void CG_SetScreenPlacement(screenPlacement_e hpos, screenPlacement_e vpos)
+{
+	cg_lastHorizontalPlacement = cg_horizontalPlacement;
+	cg_lastVerticalPlacement = cg_verticalPlacement;
+
+	cg_horizontalPlacement = hpos;
+	cg_verticalPlacement = vpos;
+}
+
+/*
+================
+CG_PopScreenPlacement
+================
+*/
+void CG_PopScreenPlacement(void)
+{
+	cg_horizontalPlacement = cg_lastHorizontalPlacement;
+	cg_verticalPlacement = cg_lastVerticalPlacement;
+}
+
+/*
+================
+CG_GetScreenHorizontalPlacement
+================
+*/
+screenPlacement_e CG_GetScreenHorizontalPlacement(void)
+{
+	return cg_horizontalPlacement;
+}
+
+/*
+================
+CG_GetScreenVerticalPlacement
+================
+*/
+screenPlacement_e CG_GetScreenVerticalPlacement(void)
+{
+	return cg_verticalPlacement;
+}
+
+/*
+================
 CG_AdjustFrom640
 
 Adjusted for resolution and screen aspect ratio
@@ -32,6 +82,7 @@
 */
 void CG_AdjustFrom640( float *x, float *y, float *w, float *h ) {
 #if 0
+#if 0
 	// adjust for wide screens
 	if ( cgs.glconfig.vidWidth * 480 > cgs.glconfig.vidHeight * 640 ) {
 		*x += 0.5 * ( cgs.glconfig.vidWidth - ( cgs.glconfig.vidHeight * 640 / 480 ) );
@@ -42,6 +93,37 @@
 	*y *= cgs.screenYScale;
 	*w *= cgs.screenXScale;
 	*h *= cgs.screenYScale;
+#endif
+
+	if (cg_horizontalPlacement == PLACE_STRETCH || cg_stretch.integer) {
+		// scale for screen sizes (not aspect correct in wide screen)
+		*w *= cgs.screenXScaleStretch;
+		*x *= cgs.screenXScaleStretch;
+	} else {
+		// scale for screen sizes
+		*w *= cgs.screenXScale;
+		*x *= cgs.screenXScale;
+
+		if (cg_horizontalPlacement == PLACE_CENTER) {
+			*x += cgs.screenXBias;
+		} else if (cg_horizontalPlacement == PLACE_RIGHT) {
+			*x += cgs.screenXBias*2;
+		}
+	}
+
+	if (cg_verticalPlacement == PLACE_STRETCH || cg_stretch.integer) {
+		*h *= cgs.screenYScaleStretch;
+		*y *= cgs.screenYScaleStretch;
+	} else {
+		*h *= cgs.screenYScale;
+		*y *= cgs.screenYScale;
+
+		if (cg_verticalPlacement == PLACE_CENTER) {
+			*y += cgs.screenYBias;
+		} else if (cg_verticalPlacement == PLACE_BOTTOM) {
+			*y += cgs.screenYBias*2;
+		}
+	}
 }
 
 /*
@@ -604,7 +686,7 @@
 	trap_R_SetColor( color );
 	
 	ax = x * cgs.screenXScale + cgs.screenXBias;
-	ay = y * cgs.screenYScale;
+	ay = y * cgs.screenYScale + cgs.screenYBias;
 
 	s = str;
 	while ( *s )
@@ -714,7 +796,7 @@
 	trap_R_SetColor( color );
 	
 	ax = x * cgs.screenXScale + cgs.screenXBias;
-	ay = y * cgs.screenYScale;
+	ay = y * cgs.screenYScale + cgs.screenYBias;
 
 	s = str;
 	while ( *s )
Index: code/cgame/cg_info.c
===================================================================
--- code/cgame/cg_info.c	(revision 3317)
+++ code/cgame/cg_info.c	(working copy)
@@ -164,7 +164,7 @@
 		levelshot = trap_R_RegisterShaderNoMip( "menu/art/unknownmap" );
 	}
 	trap_R_SetColor( NULL );
-	CG_DrawPic( 0, 0, SCREEN_WIDTH, SCREEN_HEIGHT, levelshot );
+	trap_R_DrawStretchPic( 0, 0, cgs.glconfig.vidWidth, cgs.glconfig.vidHeight, 0, 0, 1, 1, levelshot );
 
 	// blend a detail texture over it
 	detail = trap_R_RegisterShader( "levelShotDetail" );
Index: code/cgame/cg_local.h
===================================================================
--- code/cgame/cg_local.h	(revision 3317)
+++ code/cgame/cg_local.h	(working copy)
@@ -518,6 +518,7 @@
 	// view rendering
 	refdef_t	refdef;
 	vec3_t		refdefViewAngles;		// will be converted to refdef.viewaxis
+	float		fov;					// either range checked cg_fov or forced value
 
 	// zoom key
 	qboolean	zoomed;
@@ -995,7 +996,11 @@
 	float			screenXScale;		// derived from glconfig
 	float			screenYScale;
 	float			screenXBias;
+	float			screenYBias;
+	float			screenXScaleStretch;
+	float			screenYScaleStretch;
 
+
 	int				serverCommandSequence;	// reliable command stream counter
 	int				processedSnapshotNum;// the number of snapshots cgame has requested
 
@@ -1102,6 +1107,14 @@
 extern	vmCvar_t		cg_drawCrosshairNames;
 extern	vmCvar_t		cg_drawRewards;
 extern	vmCvar_t		cg_drawTeamOverlay;
+extern	vmCvar_t		cg_drawScores;
+extern	vmCvar_t		cg_drawPickups;
+extern	vmCvar_t		cg_drawWeaponBar;
+extern	vmCvar_t		cg_drawStatusHead;
+extern	vmCvar_t		cg_statusScale;
+extern	vmCvar_t		cg_fovAspectAdjust;
+extern	vmCvar_t		cg_fovGunAdjust;
+extern	vmCvar_t		cg_stretch;
 extern	vmCvar_t		cg_teamOverlayUserinfo;
 extern	vmCvar_t		cg_crosshairX;
 extern	vmCvar_t		cg_crosshairY;
@@ -1207,6 +1220,7 @@
 int CG_CrosshairPlayer( void );
 int CG_LastAttacker( void );
 void CG_LoadMenus(const char *menuFile);
+void CG_HudMenuHacks( void );
 void CG_KeyEvent(int key, qboolean down);
 void CG_MouseEvent(int x, int y);
 void CG_EventHandling(int type);
@@ -1235,6 +1249,27 @@
 //
 // cg_drawtools.c
 //
+// ugly workaround for having it in cg_local.h and ui_shared.h
+#ifndef HAVE_SCREEN_PLACEMENT
+#define HAVE_SCREEN_PLACEMENT
+typedef enum {
+	PLACE_STRETCH,
+	PLACE_CENTER,
+
+	// horizontal only
+	PLACE_LEFT,
+	PLACE_RIGHT,
+
+	// vertical only
+	PLACE_TOP,
+	PLACE_BOTTOM
+} screenPlacement_e;
+#endif
+
+void CG_SetScreenPlacement(screenPlacement_e hpos, screenPlacement_e vpos);
+void CG_PopScreenPlacement(void);
+screenPlacement_e CG_GetScreenHorizontalPlacement(void);
+screenPlacement_e CG_GetScreenVerticalPlacement(void);
 void CG_AdjustFrom640( float *x, float *y, float *w, float *h );
 void CG_FillRect( float x, float y, float width, float height, const float *color );
 void CG_DrawPic( float x, float y, float width, float height, qhandle_t hShader );
Index: code/cgame/cg_main.c
===================================================================
--- code/cgame/cg_main.c	(revision 3317)
+++ code/cgame/cg_main.c	(working copy)
@@ -108,6 +108,14 @@
 vmCvar_t	cg_drawCrosshair;
 vmCvar_t	cg_drawCrosshairNames;
 vmCvar_t	cg_drawRewards;
+vmCvar_t	cg_drawScores;
+vmCvar_t	cg_drawPickups;
+vmCvar_t	cg_drawWeaponBar;
+vmCvar_t	cg_drawStatusHead;
+vmCvar_t	cg_statusScale;
+vmCvar_t	cg_fovAspectAdjust;
+vmCvar_t	cg_fovGunAdjust;
+vmCvar_t	cg_stretch;
 vmCvar_t	cg_crosshairSize;
 vmCvar_t	cg_crosshairX;
 vmCvar_t	cg_crosshairY;
@@ -228,6 +236,14 @@
 	{ &cg_drawCrosshair, "cg_drawCrosshair", "4", CVAR_ARCHIVE },
 	{ &cg_drawCrosshairNames, "cg_drawCrosshairNames", "1", CVAR_ARCHIVE },
 	{ &cg_drawRewards, "cg_drawRewards", "1", CVAR_ARCHIVE },
+	{ &cg_drawScores, "cg_drawScores", "1", CVAR_ARCHIVE },
+	{ &cg_drawPickups, "cg_drawPickups", "1", CVAR_ARCHIVE },
+	{ &cg_drawWeaponBar, "cg_drawWeaponBar", "1", CVAR_ARCHIVE },
+	{ &cg_drawStatusHead, "cg_drawStatusHead", "1", CVAR_ARCHIVE },
+	{ &cg_statusScale, "cg_statusScale", "1", CVAR_ARCHIVE },
+	{ &cg_fovAspectAdjust, "cg_fovAspectAdjust", "0", CVAR_ARCHIVE },
+	{ &cg_fovGunAdjust, "cg_fovGunAdjust", "0", CVAR_ARCHIVE },
+	{ &cg_stretch, "cg_stretch", "0", CVAR_ARCHIVE },
 	{ &cg_crosshairSize, "cg_crosshairSize", "24", CVAR_ARCHIVE },
 	{ &cg_crosshairHealth, "cg_crosshairHealth", "1", CVAR_ARCHIVE },
 	{ &cg_crosshairX, "cg_crosshairX", "0", CVAR_ARCHIVE },
@@ -1021,6 +1037,9 @@
 		}
 	}
 
+	// can be used by HUD so always load it
+	CG_RegisterItemVisuals( 6 /* item_health_large */ );
+
 	// wall marks
 	cgs.media.bulletMarkShader = trap_R_RegisterShader( "gfx/damage/bullet_mrk" );
 	cgs.media.burnMarkShader = trap_R_RegisterShader( "gfx/damage/burn_med_mrk" );
@@ -1796,6 +1815,9 @@
 	cgDC.stopCinematic = &CG_StopCinematic;
 	cgDC.drawCinematic = &CG_DrawCinematic;
 	cgDC.runCinematicFrame = &CG_RunCinematicFrame;
+	cgDC.adjustFrom640 = &CG_AdjustFrom640;
+	cgDC.setScreenPlacement = &CG_SetScreenPlacement;
+	cgDC.popScreenPlacement = &CG_PopScreenPlacement;
 	
 	Init_Display(&cgDC);
 
@@ -1808,8 +1830,45 @@
 	}
 
 	CG_LoadMenus(hudSet);
+	CG_HudMenuHacks();
 }
 
+/*
+=================
+CG_HudMenuHacks
+=================
+*/
+void CG_HudMenuHacks( void ) {
+	menuDef_t *menu;
+
+	Init_Display(&cgDC);
+
+	// make voice chat head stick to left side in widescreen
+	menu = Menus_FindByName( "voiceMenu" );
+	if ( menu && !menu->forceScreenPlacement ) {
+		Menu_SetScreenPlacement( menu, PLACE_LEFT, PLACE_TOP );
+	}
+
+	// Make vertical power up area stick to the left or right side in widescreen.
+	// Team Arena has it on the right side but also handle custom huds that use left side.
+	menu = Menus_FindByName( "powerup area" );
+	if ( menu && !menu->forceScreenPlacement ) {
+		itemDef_t *item = Menu_FindItemByName( menu, "powerupArea" );
+
+		if ( item && item->window.ownerDraw == CG_AREA_POWERUP && item->alignment == HUD_VERTICAL ) {
+			screenPlacement_e hpos;
+
+			if ( item->window.rect.x > SCREEN_WIDTH*0.5f ) {
+				hpos = PLACE_RIGHT;
+			} else {
+				hpos = PLACE_LEFT;
+			}
+
+			Menu_SetScreenPlacement( menu, hpos, PLACE_CENTER );
+		}
+	}
+}
+
 void CG_AssetCache( void ) {
 	//if (Assets.textFont == NULL) {
 	//  trap_R_RegisterFont("fonts/arial.ttf", 72, &Assets.textFont);
@@ -1877,8 +1936,25 @@
 
 	// get the rendering configuration from the client system
 	trap_GetGlconfig( &cgs.glconfig );
-	cgs.screenXScale = cgs.glconfig.vidWidth / 640.0;
-	cgs.screenYScale = cgs.glconfig.vidHeight / 480.0;
+	cgs.screenXScaleStretch = cgs.glconfig.vidWidth * (1.0/640.0);
+	cgs.screenYScaleStretch = cgs.glconfig.vidHeight * (1.0/480.0);
+	if ( cgs.glconfig.vidWidth * 480 > cgs.glconfig.vidHeight * 640 ) {
+		cgs.screenXScale = cgs.glconfig.vidWidth * (1.0/640.0);
+		cgs.screenYScale = cgs.glconfig.vidHeight * (1.0/480.0);
+		// wide screen
+		cgs.screenXBias = 0.5 * ( cgs.glconfig.vidWidth - ( cgs.glconfig.vidHeight * (640.0/480.0) ) );
+		cgs.screenXScale = cgs.screenYScale;
+		// no narrow screen
+		cgs.screenYBias = 0;
+	} else {
+		cgs.screenXScale = cgs.glconfig.vidWidth * (1.0/640.0);
+		cgs.screenYScale = cgs.glconfig.vidHeight * (1.0/480.0);
+		// narrow screen
+		cgs.screenYBias = 0.5 * ( cgs.glconfig.vidHeight - ( cgs.glconfig.vidWidth * (480.0/640.0) ) );
+		cgs.screenYScale = cgs.screenXScale;
+		// no wide screen
+		cgs.screenXBias = 0;
+	}
 
 	// get the gamestate from the client system
 	trap_GetGameState( &cgs.gameState );
Index: code/cgame/cg_newdraw.c
===================================================================
--- code/cgame/cg_newdraw.c	(revision 3317)
+++ code/cgame/cg_newdraw.c	(working copy)
@@ -1804,6 +1804,8 @@
 void CG_ShowResponseHead(void) {
 	float x, y, w, h;
 
+	CG_SetScreenPlacement( PLACE_LEFT, PLACE_TOP );
+
 	x = 72;
 	y = w = h = 0;
 	CG_AdjustFrom640( &x, &y, &w, &h );
@@ -1811,6 +1813,8 @@
 	Menus_OpenByName("voiceMenu");
 	trap_Cvar_Set("cl_conXOffset", va("%d", (int)x));
 	cg.voiceTime = cg.time;
+
+	CG_PopScreenPlacement();
 }
 
 void CG_RunMenuScript(char **args) {
Index: code/cgame/cg_scoreboard.c
===================================================================
--- code/cgame/cg_scoreboard.c	(revision 3317)
+++ code/cgame/cg_scoreboard.c	(working copy)
@@ -272,6 +272,8 @@
 	int lineHeight;
 	int topBorderSize, bottomBorderSize;
 
+	CG_SetScreenPlacement(PLACE_CENTER, PLACE_CENTER);
+
 	// don't draw amuthing if the menu or console is up
 	if ( cg_paused.integer ) {
 		cg.deferredPlayerLoading = 0;
@@ -457,6 +459,8 @@
 	int				y;
 	int				i;
 
+	CG_SetScreenPlacement(PLACE_CENTER, PLACE_CENTER);
+
 	// request more scores regularly
 	if ( cg.scoresRequestTime + 2000 < cg.time ) {
 		cg.scoresRequestTime = cg.time;
@@ -466,7 +470,9 @@
 	// draw the dialog background
 	color[0] = color[1] = color[2] = 0;
 	color[3] = 1;
+	CG_SetScreenPlacement(PLACE_STRETCH, PLACE_STRETCH);
 	CG_FillRect( 0, 0, SCREEN_WIDTH, SCREEN_HEIGHT, color );
+	CG_PopScreenPlacement();
 
 	color[0] = 1;
 	color[1] = 1;
Index: code/cgame/cg_view.c
===================================================================
--- code/cgame/cg_view.c	(revision 3317)
+++ code/cgame/cg_view.c	(working copy)
@@ -479,7 +479,7 @@
 
 	if ( cg.predictedPlayerState.pm_type == PM_INTERMISSION ) {
 		// if in intermission, use a fixed value
-		fov_x = 90;
+		cg.fov = fov_x = 90;
 	} else {
 		// user selectable
 		if ( cgs.dmflags & DF_FIXED_FOV ) {
@@ -494,6 +494,8 @@
 			}
 		}
 
+		cg.fov = fov_x;
+
 		// account for zooms
 		zoomFov = cg_zoomFov.value;
 		if ( zoomFov < 1 ) {
@@ -517,6 +519,16 @@
 		}
 	}
 
+	if ( cg_fovAspectAdjust.integer ) {
+		// Based on LordHavoc's code for Darkplaces
+		// http://www.quakeworld.nu/forum/topic/53/what-does-your-qw-look-like/page/30
+		const float baseAspect = 0.75f; // 3/4
+		const float aspect = (float)cg.refdef.width/(float)cg.refdef.height;
+		const float desiredFov = fov_x;
+
+		fov_x = atan2( tan( desiredFov*M_PI / 360.0f ) * baseAspect*aspect, 1 )*360.0f / M_PI;
+	}
+
 	x = cg.refdef.width / tan( fov_x / 360 * M_PI );
 	fov_y = atan2( cg.refdef.height, x );
 	fov_y = fov_y * 360 / M_PI;
Index: code/cgame/cg_weapons.c
===================================================================
--- code/cgame/cg_weapons.c	(revision 3317)
+++ code/cgame/cg_weapons.c	(working copy)
@@ -1357,7 +1357,7 @@
 	refEntity_t	hand;
 	centity_t	*cent;
 	clientInfo_t	*ci;
-	float		fovOffset;
+	vec3_t		fovOffset;
 	vec3_t		angles;
 	weaponInfo_t	*weapon;
 
@@ -1394,11 +1394,19 @@
 		return;
 	}
 
-	// drop gun lower at higher fov
-	if ( cg_fov.integer > 90 ) {
-		fovOffset = -0.2 * ( cg_fov.integer - 90 );
-	} else {
-		fovOffset = 0;
+	VectorClear(fovOffset);
+
+	if ( cg_fovGunAdjust.integer ) {
+		if ( cg.fov > 90 ) {
+			// drop gun lower at higher fov
+			fovOffset[2] = -0.2 * ( cg.fov - 90 ) * cg.refdef.fov_x / cg.fov;
+		} else if ( cg.fov < 90 ) {
+			// move gun forward at lowerer fov
+			fovOffset[0] = -0.2 * ( cg.fov - 90 ) * cg.refdef.fov_x / cg.fov;
+		}
+	} else if ( cg_fov.integer > 90 ) {
+		// Q3A's auto adjust
+		fovOffset[2] = -0.2 * ( cg_fov.integer - 90 );
 	}
 
 	cent = &cg.predictedPlayerEntity;	// &cg_entities[cg.snap->ps.clientNum];
@@ -1410,9 +1418,9 @@
 	// set up gun position
 	CG_CalculateWeaponPosition( hand.origin, angles );
 
-	VectorMA( hand.origin, cg_gun_x.value, cg.refdef.viewaxis[0], hand.origin );
-	VectorMA( hand.origin, cg_gun_y.value, cg.refdef.viewaxis[1], hand.origin );
-	VectorMA( hand.origin, (cg_gun_z.value+fovOffset), cg.refdef.viewaxis[2], hand.origin );
+	VectorMA( hand.origin, (cg_gun_x.value+fovOffset[0]), cg.refdef.viewaxis[0], hand.origin );
+	VectorMA( hand.origin, (cg_gun_y.value+fovOffset[1]), cg.refdef.viewaxis[1], hand.origin );
+	VectorMA( hand.origin, (cg_gun_z.value+fovOffset[2]), cg.refdef.viewaxis[2], hand.origin );
 
 	AnglesToAxis( angles, hand.axis );
 
@@ -1456,7 +1464,14 @@
 	int		x, y, w;
 	char	*name;
 	float	*color;
+	float	markerSize, iconSize, offsetSize, charWidth, charHeight;
 
+	CG_SetScreenPlacement(PLACE_CENTER, PLACE_BOTTOM);
+
+	if ( cg_drawWeaponBar.value <= 0 ) {
+		return;
+	}
+
 	// don't display if dead
 	if ( cg.predictedPlayerState.stats[STAT_HEALTH] <= 0 ) {
 		return;
@@ -1480,9 +1495,16 @@
 		}
 	}
 
-	x = 320 - count * 20;
+	x = 320 - count * 20 * cg_drawWeaponBar.value;
 	y = 380;
 
+	markerSize = 40 * cg_drawWeaponBar.value;
+	iconSize = 32 * cg_drawWeaponBar.value;
+	offsetSize = (markerSize - iconSize) * 0.5f;
+
+	charWidth = BIGCHAR_WIDTH * cg_drawWeaponBar.value;
+	charHeight = BIGCHAR_HEIGHT * cg_drawWeaponBar.value;
+
 	for ( i = 1 ; i < MAX_WEAPONS ; i++ ) {
 		if ( !( bits & ( 1 << i ) ) ) {
 			continue;
@@ -1491,19 +1513,19 @@
 		CG_RegisterWeapon( i );
 
 		// draw weapon icon
-		CG_DrawPic( x, y, 32, 32, cg_weapons[i].weaponIcon );
+		CG_DrawPic( x, y, iconSize, iconSize, cg_weapons[i].weaponIcon );
 
 		// draw selection marker
 		if ( i == cg.weaponSelect ) {
-			CG_DrawPic( x-4, y-4, 40, 40, cgs.media.selectShader );
+			CG_DrawPic( x-offsetSize, y-offsetSize, markerSize, markerSize, cgs.media.selectShader );
 		}
 
 		// no ammo cross on top
 		if ( !cg.snap->ps.ammo[ i ] ) {
-			CG_DrawPic( x, y, 32, 32, cgs.media.noammoShader );
+			CG_DrawPic( x, y, iconSize, iconSize, cgs.media.noammoShader );
 		}
 
-		x += 40;
+		x += markerSize;
 	}
 
 	// draw the selected name
@@ -1510,9 +1532,9 @@
 	if ( cg_weapons[ cg.weaponSelect ].item ) {
 		name = cg_weapons[ cg.weaponSelect ].item->pickup_name;
 		if ( name ) {
-			w = CG_DrawStrlen( name ) * BIGCHAR_WIDTH;
+			w = CG_DrawStrlen( name ) * charWidth;
 			x = ( SCREEN_WIDTH - w ) / 2;
-			CG_DrawBigStringColor(x, y - 22, name, color);
+			CG_DrawStringExt(x, y - 22*cg_drawWeaponBar.value, name, color, qfalse, qtrue, charWidth, charHeight, 0 );
 		}
 	}
 
Index: code/ui/ui_main.c
===================================================================
--- code/ui/ui_main.c	(revision 3317)
+++ code/ui/ui_main.c	(working copy)
@@ -5149,6 +5149,9 @@
 	uiInfo.uiDC.stopCinematic = &UI_StopCinematic;
 	uiInfo.uiDC.drawCinematic = &UI_DrawCinematic;
 	uiInfo.uiDC.runCinematicFrame = &UI_RunCinematicFrame;
+	uiInfo.uiDC.adjustFrom640 = &UI_AdjustFrom640;
+	uiInfo.uiDC.setScreenPlacement = NULL;
+	uiInfo.uiDC.popScreenPlacement = NULL;
 
 	Init_Display(&uiInfo.uiDC);
 
Index: code/ui/ui_shared.c
===================================================================
--- code/ui/ui_shared.c	(revision 3317)
+++ code/ui/ui_shared.c	(working copy)
@@ -3640,14 +3640,6 @@
 
 
 
-void AdjustFrom640(float *x, float *y, float *w, float *h) {
-	//*x = *x * DC->scale + DC->bias;
-	*x *= DC->xscale;
-	*y *= DC->yscale;
-	*w *= DC->xscale;
-	*h *= DC->yscale;
-}
-
 void Item_Model_Paint(itemDef_t *item) {
 	float x, y, w, h;
 	refdef_t refdef;
@@ -3669,7 +3661,7 @@
 	w = item->window.rect.w-2;
 	h = item->window.rect.h-2;
 
-	AdjustFrom640( &x, &y, &w, &h );
+	DC->adjustFrom640( &x, &y, &w, &h );
 
 	refdef.x = x;
 	refdef.y = y;
@@ -4215,6 +4207,20 @@
 	}
 }
 
+void Menu_SetScreenPlacement(menuDef_t *menu, screenPlacement_e hpos, screenPlacement_e vpos ) {
+	if ( !menu )
+		return;
+
+	if (DC->setScreenPlacement == NULL) {
+		Com_Printf( S_COLOR_YELLOW "WARNING: Menu_SetScreenPlacement() is only supported in CGame\n" );
+		return;
+	}
+
+	menu->forceScreenPlacement = qtrue;
+	menu->screenHPos = hpos;
+	menu->screenVPos = vpos;
+}
+
 qboolean Menus_AnyFullScreenVisible(void) {
   int i;
   for (i = 0; i < menuCount; i++) {
@@ -4347,6 +4353,10 @@
 		menu->window.flags |= WINDOW_FORCED;
 	}
 
+	if (menu->forceScreenPlacement) {
+		DC->setScreenPlacement( menu->screenHPos, menu->screenVPos );
+	}
+
 	// draw the background if necessary
 	if (menu->fullScreen) {
 		// implies a background shader
@@ -4370,6 +4380,10 @@
 		color[1] = 0;
 		DC->drawRect(menu->window.rect.x, menu->window.rect.y, menu->window.rect.w, menu->window.rect.h, 1, color);
 	}
+
+	if (menu->forceScreenPlacement) {
+		DC->popScreenPlacement();
+	}
 }
 
 /*
@@ -5769,7 +5783,55 @@
 	return qtrue;
 }
 
+// NOTE: This only affects the draw location. It's mainly for HUDs,
+// not interactive menus. Though it could be used for menu decorations.
+qboolean MenuParse_screenPlacement( itemDef_t *item, int handle ) {
+	menuDef_t *menu = (menuDef_t*)item;
+	screenPlacement_e hpos, vpos;
+	pc_token_t token;
 
+	if (DC->setScreenPlacement == NULL) {
+		PC_SourceError(handle, "screenPlacement is only supported in HUDs");
+		return qfalse;
+	}
+
+	if (!trap_PC_ReadToken(handle, &token))
+		return qfalse;
+
+	if (Q_stricmp(token.string, "PLACE_RIGHT") == 0) {
+		hpos = PLACE_RIGHT;
+	} else if (Q_stricmp(token.string, "PLACE_LEFT") == 0) {
+		hpos = PLACE_LEFT;
+	} else if (Q_stricmp(token.string, "PLACE_CENTER") == 0) {
+		hpos = PLACE_CENTER;
+	} else if (Q_stricmp(token.string, "PLACE_STRETCH") == 0) {
+		hpos = PLACE_STRETCH;
+	} else {
+		PC_SourceError(handle, "unknown screenPlacement horizontal placement %s", token.string);
+		return qfalse;
+	}
+
+	if (!trap_PC_ReadToken(handle, &token))
+		return qfalse;
+
+	if (Q_stricmp(token.string, "PLACE_TOP") == 0) {
+		vpos = PLACE_RIGHT;
+	} else if (Q_stricmp(token.string, "PLACE_BOTTOM") == 0) {
+		vpos = PLACE_LEFT;
+	} else if (Q_stricmp(token.string, "PLACE_CENTER") == 0) {
+		vpos = PLACE_CENTER;
+	} else if (Q_stricmp(token.string, "PLACE_STRETCH") == 0) {
+		vpos = PLACE_STRETCH;
+	} else {
+		PC_SourceError(handle, "unknown screenPlacement vertical placement %s", token.string);
+		return qfalse;
+	}
+
+	Menu_SetScreenPlacement( menu, hpos, vpos );
+	return qtrue;
+}
+
+
 qboolean MenuParse_itemDef( itemDef_t *item, int handle ) {
 	menuDef_t *menu = (menuDef_t*)item;
 	if (menu->itemCount < MAX_MENUITEMS) {
@@ -5816,6 +5878,7 @@
 	{"fadeClamp", MenuParse_fadeClamp, NULL},
 	{"fadeCycle", MenuParse_fadeCycle, NULL},
 	{"fadeAmount", MenuParse_fadeAmount, NULL},
+	{"screenPlacement", MenuParse_screenPlacement, NULL},
 	{NULL, 0, NULL}
 };
 
Index: code/ui/ui_shared.h
===================================================================
--- code/ui/ui_shared.h	(revision 3317)
+++ code/ui/ui_shared.h	(working copy)
@@ -105,6 +105,23 @@
 #define SLIDER_THUMB_HEIGHT 20.0
 #define	NUM_CROSSHAIRS			10
 
+// ugly workaround for having it in cg_local.h and ui_shared.h
+#ifndef HAVE_SCREEN_PLACEMENT
+#define HAVE_SCREEN_PLACEMENT
+typedef enum {
+	PLACE_STRETCH,
+	PLACE_CENTER,
+
+	// horizontal only
+	PLACE_LEFT,
+	PLACE_RIGHT,
+
+	// vertical only
+	PLACE_TOP,
+	PLACE_BOTTOM
+} screenPlacement_e;
+#endif
+
 typedef struct {
   const char *command;
   const char *args[MAX_SCRIPT_ARGS];
@@ -269,6 +286,9 @@
   vec4_t focusColor;								// focus color for items
   vec4_t disableColor;							// focus color for items
   itemDef_t *items[MAX_MENUITEMS];	// items this menu contains   
+
+	qboolean forceScreenPlacement;
+	screenPlacement_e screenHPos, screenVPos;
 } menuDef_t;
 
 typedef struct {
@@ -366,6 +386,9 @@
 	void (*stopCinematic)(int handle);
 	void (*drawCinematic)(int handle, float x, float y, float w, float h);
 	void (*runCinematicFrame)(int handle);
+	void (*adjustFrom640)( float *x, float *y, float *w, float *h );
+	void (*setScreenPlacement)( screenPlacement_e hpos, screenPlacement_e vpos );
+	void (*popScreenPlacement)( void );
 
   float			yscale;
   float			xscale;
@@ -433,8 +456,11 @@
 void Menus_CloseAll( void );
 void Menu_Paint(menuDef_t *menu, qboolean forcePaint);
 void Menu_SetFeederSelection(menuDef_t *menu, int feeder, int index, const char *name);
+void Menu_SetScreenPlacement(menuDef_t *menu, screenPlacement_e hpos, screenPlacement_e vpos );
 void Display_CacheAll( void );
 
+itemDef_t *Menu_FindItemByName(menuDef_t *menu, const char *p);
+
 void *UI_Alloc( int size );
 void UI_InitMemory( void );
 qboolean UI_OutOfMemory( void );
Index: README.md
===================================================================
--- README.md	(revision 3317)
+++ README.md	(working copy)
@@ -129,6 +129,19 @@
 ## New cvars
 
 ```
+  cg_stretch                        - Set to 1 to stretch 4:3 HUD to fit screen
+  cg_fovAspectAdjust                - Automatically convert 4:3 cg_fov values to current aspect
+  cg_fovGunAdjust                   - Controls gun offset based on FOV
+                                      0 uses Q3A code
+                                      1 uses new code (works with FOV < 90 and fixed FOV dmflags)
+  cg_statusScale                    - Set scale of status bar (ammo, health, head, armor, CTF flag)
+  cg_drawStatusHead                 - 0 disables drawing head
+                                      1 acts like Q3A
+                                      2 drawing health item instead (supports 3D and 2D icons)
+  cg_drawPickups                    - Set scale of item pickup message (0 to disable)
+  cg_drawWeaponBar                  - Set scale of weapon select popup (0 to disable)
+  cg_drawScores                     - Toggle drawing scores in bottom right corner (no scaling support)
+
   cl_autoRecordDemo                 - record a new demo on each map change
   cl_aviFrameRate                   - the framerate to use when capturing video
   cl_aviMotionJpeg                  - use the mjpeg codec when capturing video
