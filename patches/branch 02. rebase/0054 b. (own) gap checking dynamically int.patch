Index: code/botlib/be_ai_move.c
===================================================================
--- code/botlib/be_ai_move.c	(revision 3372)
+++ code/botlib/be_ai_move.c	(working copy)
@@ -993,7 +993,7 @@
 // Returns:				-
 // Changes Globals:		-
 //===========================================================================
-float BotGapDistance(vec3_t origin, vec3_t hordir, int entnum)
+int BotGapDistance(vec3_t origin, vec3_t hordir, int checkdist, int entnum)
 {
 	int dist;
 	vec3_t start, end;
@@ -1000,7 +1000,7 @@
 	aas_trace_t trace;
 
 	//do gap checking
-	for (dist = 8; dist <= 100; dist += 8)
+	for (dist = 8; dist <= checkdist; dist += 8)
 	{
 		VectorMA(origin, dist, hordir, start);
 		start[2] = origin[2] + 24;
@@ -1017,7 +1017,7 @@
 				end[2] -= 20;
 				if (AAS_PointContents(end) & CONTENTS_WATER) break;
 				//if a gap is found slow down
-				//botimport.Print(PRT_MESSAGE, "gap at %i\n", dist);
+				//botimport.Print(PRT_MESSAGE, "BotGapDistance: found gap at %i (checkdist = %i)\n", dist, checkdist);
 				return dist;
 			} //end if
 			origin[2] = trace.endpos[2];
@@ -1123,7 +1123,7 @@
 		if (!(type & MOVE_JUMP))
 		{
 			//if there is a gap, try to jump over it
-			if (BotGapDistance(ms->origin, hordir, ms->entitynum) > 0) type |= MOVE_JUMP;
+			if (BotGapDistance(ms->origin, hordir, 100, ms->entitynum) > 0) type |= MOVE_JUMP;
 		} //end if
 		//get command movement
 		VectorScale(hordir, speed, cmdmove);
@@ -1172,10 +1172,10 @@
 		{
 			//check for nearby gap
 			VectorNormalize2(move.velocity, tmpdir);
-			dist = BotGapDistance(move.endpos, tmpdir, ms->entitynum);
+			dist = BotGapDistance(move.endpos, tmpdir, 100, ms->entitynum);
 			if (dist > 0) return qfalse;
 			//
-			dist = BotGapDistance(move.endpos, hordir, ms->entitynum);
+			dist = BotGapDistance(move.endpos, hordir, 100, ms->entitynum);
 			if (dist > 0) return qfalse;
 		} //end if
 		//get horizontal movement
@@ -1343,7 +1343,7 @@
 		if (dist < (200 + currentspeed) * 0.1f) EA_Crouch(ms->client);
 	} //end if
 	//
-	dist = BotGapDistance(ms->origin, hordir, ms->entitynum);
+	dist = BotGapDistance(ms->origin, hordir, 100, ms->entitynum);
 	//
 	// Tobias NOTE: These code changes are very map dependant (q3dm6, q3dm7, q3dm12), maybe delete all this gap checking code at all (at least for QW maps, or keep it only for obstacles?)
 	VectorSubtract(ms->origin, reach->end, dir1);
@@ -1817,7 +1817,7 @@
 	//
 	speed = 350;
 	//
-	gapdist = BotGapDistance(ms, hordir, ms->entitynum);
+	gapdist = BotGapDistance(ms, hordir, 100, ms->entitynum);
 	//if pretty close to the start focus on the reachability end
 	if (dist < 50 || (gapdist && gapdist < 50))
 	{
@@ -1880,7 +1880,7 @@
 		if (AAS_PointAreaNum(end) != ms->reachareanum) break;
 	} //end for
 	if (gapdist < 80) VectorMA(reach->start, gapdist, hordir, trace.endpos);
-//	dist1 = BotGapDistance(start, hordir, ms->entitynum);
+//	dist1 = BotGapDistance(start, hordir, 100, ms->entitynum);
 //	if (dist1 && dist1 <= trace.fraction * 80) VectorMA(reach->start, dist1-20, hordir, trace.endpos);
 	//
 	VectorSubtract(ms->origin, reach->start, dir1);
Index: code/botlib/be_interface.c
===================================================================
--- code/botlib/be_interface.c	(revision 3372)
+++ code/botlib/be_interface.c	(working copy)
@@ -288,7 +288,7 @@
 
 int BotFuzzyPointReachabilityArea(vec3_t origin);
 
-float BotGapDistance(vec3_t origin, vec3_t hordir, int entnum);
+int BotGapDistance(vec3_t origin, vec3_t hordir, int checkdist, int entnum);
 
 void AAS_FloodAreas(vec3_t origin);
 
@@ -529,7 +529,7 @@
 		}
 	} //end else
 	VectorClear(forward);
-	//BotGapDistance(origin, forward, 0);
+	//BotGapDistance(origin, forward, 100, 0);
 	/*
 	if (parm0 & BUTTON_USE)
 	{
