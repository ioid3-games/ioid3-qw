Index: code/botlib/be_aas_debug.c
===================================================================
--- code/botlib/be_aas_debug.c	(revision 515)
+++ code/botlib/be_aas_debug.c	(working copy)
@@ -640,7 +640,7 @@
 
 		cmdmove[2] = aassettings.phys_jumpvel;
 		// movement prediction
-		AAS_PredictClientMovement(&move, -1, reach->start, PRESENCE_NORMAL, qtrue, velocity, cmdmove, 3, 30, 0.1f, SE_HITGROUND|SE_ENTERWATER|SE_ENTERSLIME|SE_ENTERLAVA|SE_HITGROUNDDAMAGE, 0, qtrue);
+		AAS_PredictClientMovement(&move, -1, reach->start, PRESENCE_NORMAL, qtrue, qfalse, velocity, cmdmove, 3, 30, 0.1f, SE_HITGROUND|SE_ENTERWATER|SE_ENTERSLIME|SE_ENTERLAVA|SE_HITGROUNDDAMAGE, 0);
 
 		if ((reach->traveltype & TRAVELTYPE_MASK) == TRAVEL_JUMP) {
 			AAS_JumpReachRunStart(reach, dir);
@@ -659,7 +659,7 @@
 		VectorScale(dir, speed, cmdmove);
 		VectorSet(velocity, 0, 0, zvel);
 		// movement prediction
-		AAS_PredictClientMovement(&move, -1, reach->start, PRESENCE_NORMAL, qtrue, velocity, cmdmove, 30, 30, 0.1f, SE_ENTERWATER|SE_ENTERSLIME|SE_ENTERLAVA|SE_HITGROUNDDAMAGE|SE_TOUCHJUMPPAD|SE_HITGROUNDAREA, reach->areanum, qtrue);
+		AAS_PredictClientMovement(&move, -1, reach->start, PRESENCE_NORMAL, qtrue, qfalse, velocity, cmdmove, 30, 30, 0.1f, SE_ENTERWATER|SE_ENTERSLIME|SE_ENTERLAVA|SE_HITGROUNDDAMAGE|SE_TOUCHJUMPPAD|SE_HITGROUNDAREA, reach->areanum);
 	} else if ((reach->traveltype & TRAVELTYPE_MASK) == TRAVEL_JUMPPAD) {
 		VectorSet(cmdmove, 0, 0, 0);
 		VectorSubtract(reach->end, reach->start, dir);
@@ -673,7 +673,7 @@
 		// NOTE: the facenum is the Z velocity
 		velocity[2] = reach->facenum;
 		// movement prediction
-		AAS_PredictClientMovement(&move, -1, reach->start, PRESENCE_NORMAL, qtrue, velocity, cmdmove, 30, 30, 0.1f, SE_ENTERWATER|SE_ENTERSLIME|SE_ENTERLAVA|SE_HITGROUNDDAMAGE|SE_TOUCHJUMPPAD|SE_HITGROUNDAREA, reach->areanum, qtrue);
+		AAS_PredictClientMovement(&move, -1, reach->start, PRESENCE_NORMAL, qtrue, qfalse, velocity, cmdmove, 30, 30, 0.1f, SE_ENTERWATER|SE_ENTERSLIME|SE_ENTERLAVA|SE_HITGROUNDDAMAGE|SE_TOUCHJUMPPAD|SE_HITGROUNDAREA, reach->areanum);
 	}
 }
 
Index: code/botlib/be_aas_def.h
===================================================================
--- code/botlib/be_aas_def.h	(revision 515)
+++ code/botlib/be_aas_def.h	(working copy)
@@ -70,6 +70,7 @@
 	float phys_waterfriction;
 	float phys_watergravity;
 	float phys_maxvelocity;
+	float phys_maxscoutvelocity;
 	float phys_maxwalkvelocity;
 	float phys_maxcrouchvelocity;
 	float phys_maxswimvelocity;
@@ -80,7 +81,9 @@
 	float phys_maxsteepness;
 	float phys_maxwaterjump;
 	float phys_maxbarrier;
+	float phys_maxscoutbarrier;
 	float phys_jumpvel;
+	float phys_jumpvelscout;
 	float phys_falldelta5;
 	float phys_falldelta10;
 	float rs_waterjump;
Index: code/botlib/be_aas_move.c
===================================================================
--- code/botlib/be_aas_move.c	(revision 515)
+++ code/botlib/be_aas_move.c	(working copy)
@@ -86,6 +86,7 @@
 	aassettings.phys_waterfriction = LibVarValue("phys_waterfriction", "1");
 	aassettings.phys_watergravity = LibVarValue("phys_watergravity", "400");
 	aassettings.phys_maxvelocity = LibVarValue("phys_maxvelocity", "260");
+	aassettings.phys_maxscoutvelocity = LibVarValue("phys_maxscoutvelocity", "390");
 	aassettings.phys_maxwalkvelocity = LibVarValue("phys_maxwalkvelocity", "280");
 	aassettings.phys_maxcrouchvelocity = LibVarValue("phys_maxcrouchvelocity", "100");
 	aassettings.phys_maxswimvelocity = LibVarValue("phys_maxswimvelocity", "45");
@@ -96,7 +97,9 @@
 	aassettings.phys_maxsteepness = LibVarValue("phys_maxsteepness", "0.7");
 	aassettings.phys_maxwaterjump = LibVarValue("phys_maxwaterjump", "20");
 	aassettings.phys_maxbarrier = LibVarValue("phys_maxbarrier", "43");
+	aassettings.phys_maxscoutbarrier = LibVarValue("phys_maxscoutbarrier", "73");
 	aassettings.phys_jumpvel = LibVarValue("phys_jumpvel", "200");
+	aassettings.phys_jumpvelscout = LibVarValue("phys_jumpvelscout", "300");
 	aassettings.phys_falldelta5 = LibVarValue("phys_falldelta5", "40");
 	aassettings.phys_falldelta10 = LibVarValue("phys_falldelta10", "60");
 	aassettings.rs_waterjump = LibVarValue("rs_waterjump", "400");
@@ -273,7 +276,7 @@
 	// get command movement
 	VectorScale(hordir, 400, cmdmove);
 	// movement prediction
-	AAS_PredictClientMovement(&move, -1, start, PRESENCE_NORMAL, qtrue, vec3_origin, cmdmove, 1, 2, 0.1f, SE_HITGROUNDDAMAGE|SE_ENTERLAVA|SE_ENTERSLIME|SE_GAP, 0, qfalse);
+	AAS_PredictClientMovement(&move, -1, start, PRESENCE_NORMAL, qtrue, qfalse, vec3_origin, cmdmove, 1, 2, 0.1f, SE_HITGROUNDDAMAGE|SE_ENTERLAVA|SE_ENTERSLIME|SE_GAP, 0);
 	VectorCopy(move.endpos, runstart);
 	// don't fall from too high, don't enter slime or lava and don't fall in gaps
 	if (move.stopevent & (SE_HITGROUNDDAMAGE|SE_ENTERLAVA|SE_ENTERSLIME|SE_GAP)) {
@@ -283,6 +286,35 @@
 
 /*
 =======================================================================================================================================
+AAS_ScoutJumpReachRunStart
+=======================================================================================================================================
+*/
+void AAS_ScoutJumpReachRunStart(aas_reachability_t *reach, vec3_t runstart) {
+	vec3_t hordir, start, cmdmove;
+	aas_clientmove_t move;
+
+	hordir[0] = reach->start[0] - reach->end[0];
+	hordir[1] = reach->start[1] - reach->end[1];
+	hordir[2] = 0;
+
+	VectorNormalize(hordir);
+	// start point
+	VectorCopy(reach->start, start);
+
+	start[2] += 1;
+	// get command movement
+	VectorScale(hordir, 400, cmdmove);
+	// movement prediction
+	AAS_PredictClientMovement(&move, -1, start, PRESENCE_NORMAL, qtrue, qtrue, vec3_origin, cmdmove, 1, 2, 0.1f, SE_HITGROUNDDAMAGE|SE_ENTERSLIME|SE_ENTERLAVA|SE_GAP, 0);
+	VectorCopy(move.endpos, runstart);
+	// don't fall from too high, don't enter slime or lava and don't fall in gaps
+	if (move.stopevent & (SE_HITGROUNDDAMAGE|SE_ENTERLAVA|SE_ENTERSLIME|SE_GAP)) {
+		VectorCopy(start, runstart);
+	}
+}
+
+/*
+=======================================================================================================================================
 AAS_WeaponJumpZVelocity
 
 Returns the Z velocity when rocket jumping at the origin.
@@ -523,13 +555,13 @@
 Returns: aas_clientmove_t
 =======================================================================================================================================
 */
-static int AAS_ClientMovementPrediction(aas_clientmove_t *move, int entnum, const vec3_t origin, int presencetype, int onground, const vec3_t velocity, const vec3_t cmdmove, int cmdframes, int maxframes, float frametime, int stopevent, int stopareanum, const vec3_t mins, const vec3_t maxs, int visualize) {
+static int AAS_ClientMovementPrediction(aas_clientmove_t *move, int entnum, const vec3_t origin, int presencetype, int onground, int scoutmove, const vec3_t velocity, const vec3_t cmdmove, int cmdframes, int maxframes, float frametime, int stopevent, int stopareanum, const vec3_t mins, const vec3_t maxs) {
 	float phys_friction, phys_stopspeed, phys_gravity, phys_waterfriction;
 	float phys_watergravity;
 	float phys_walkaccelerate, phys_airaccelerate, phys_swimaccelerate;
 	float phys_maxwalkvelocity, phys_maxcrouchvelocity, phys_maxswimvelocity;
-	float phys_maxstep, phys_maxsteepness, phys_maxbarrier, phys_jumpvel, friction;
-	float gravity, delta, maxvel, wishspeed, accelerate;
+	float phys_maxstep, phys_maxsteepness, phys_maxbarrier, phys_maxscoutbarrier, phys_jumpvel, phys_jumpvelscout, friction;
+	float gravity, delta, maxvel, maxjumpvel, maxbarrierheight, wishspeed, accelerate;
 	//float velchange, newvel;
 	//int ax;
 	int n, i, j, pc, step, swimming, crouch, event, jump_frame, areanum;
@@ -560,7 +592,9 @@
 	phys_maxstep = aassettings.phys_maxstep;
 	phys_maxsteepness = aassettings.phys_maxsteepness;
 	phys_maxbarrier = aassettings.phys_maxbarrier;
+	phys_maxscoutbarrier = aassettings.phys_maxscoutbarrier;
 	phys_jumpvel = aassettings.phys_jumpvel * frametime;
+	phys_jumpvelscout = aassettings.phys_jumpvelscout * frametime;
 
 	Com_Memset(move, 0, sizeof(*move));
 	Com_Memset(&trace, 0, sizeof(trace));
@@ -593,6 +627,7 @@
 		if (n < cmdframes) {
 			// ax = 0;
 			maxvel = phys_maxwalkvelocity;
+			maxjumpvel = !scoutmove ? phys_jumpvel : phys_jumpvelscout;
 			accelerate = phys_airaccelerate;
 
 			VectorCopy(cmdmove, wishdir);
@@ -605,7 +640,7 @@
 				// if not swimming and upmove is positive then jump
 				if (!swimming && cmdmove[2] > 1) {
 					// jump velocity minus the gravity for one frame + 5 for safety
-					frame_test_vel[2] = phys_jumpvel - (gravity * 0.1 * frametime) + 5;
+					frame_test_vel[2] = maxjumpvel - (gravity * 0.1 * frametime) + 5;
 					jump_frame = n;
 					// jumping so air accelerate
 					accelerate = phys_airaccelerate;
@@ -982,12 +998,13 @@
 
 			VectorCopy(start, end);
 
-			end[2] -= 48 + phys_maxbarrier;
+			maxbarrierheight = !scoutmove ? phys_maxbarrier : phys_maxscoutbarrier;
+			end[2] -= 48 + maxbarrierheight;
 			gaptrace = AAS_TraceClientBBox(start, end, PRESENCE_CROUCH, entnum);
 			// if solid is found the bot cannot walk any further and will not fall into a gap
 			if (!gaptrace.startsolid) {
-				// if it is a gap (lower than phys_maxbarrier height)
-				if (gaptrace.endpos[2] < org[2] - phys_maxbarrier) {
+				// if it is a gap (lower than maxbarrierheight)
+				if (gaptrace.endpos[2] < org[2] - maxbarrierheight) {
 					if (!(AAS_PointContents(end) & CONTENTS_WATER)) {
 						VectorCopy(lastorg, move->endpos);
 						VectorScale(frame_test_vel, 1 / frametime, move->velocity);
@@ -1024,9 +1041,9 @@
 AAS_PredictClientMovement
 =======================================================================================================================================
 */
-int AAS_PredictClientMovement(struct aas_clientmove_s *move, int entnum, vec3_t origin, int presencetype, int onground, vec3_t velocity, vec3_t cmdmove, int cmdframes, int maxframes, float frametime, int stopevent, int stopareanum, int visualize) {
+int AAS_PredictClientMovement(struct aas_clientmove_s *move, int entnum, vec3_t origin, int presencetype, int onground, int scoutmove, vec3_t velocity, vec3_t cmdmove, int cmdframes, int maxframes, float frametime, int stopevent, int stopareanum) {
 	vec3_t mins, maxs;
-	return AAS_ClientMovementPrediction(move, entnum, origin, presencetype, onground, velocity, cmdmove, cmdframes, maxframes, frametime, stopevent, stopareanum, mins, maxs, visualize);
+	return AAS_ClientMovementPrediction(move, entnum, origin, presencetype, onground, scoutmove, velocity, cmdmove, cmdframes, maxframes, frametime, stopevent, stopareanum, mins, maxs);
 }
 
 /*
@@ -1034,8 +1051,8 @@
 AAS_ClientMovementHitBBox
 =======================================================================================================================================
 */
-int AAS_ClientMovementHitBBox(struct aas_clientmove_s *move, int entnum, vec3_t origin, int presencetype, int onground, vec3_t velocity, vec3_t cmdmove, int cmdframes, int maxframes, float frametime, vec3_t mins, vec3_t maxs, int visualize) {
-	return AAS_ClientMovementPrediction(move, entnum, origin, presencetype, onground, velocity, cmdmove, cmdframes, maxframes, frametime, SE_HITBOUNDINGBOX, 0, mins, maxs, visualize);
+int AAS_ClientMovementHitBBox(struct aas_clientmove_s *move, int entnum, vec3_t origin, int presencetype, int onground, int scoutmove, vec3_t velocity, vec3_t cmdmove, int cmdframes, int maxframes, float frametime, vec3_t mins, vec3_t maxs) {
+	return AAS_ClientMovementPrediction(move, entnum, origin, presencetype, onground, scoutmove, velocity, cmdmove, cmdframes, maxframes, frametime, SE_HITBOUNDINGBOX, 0, mins, maxs);
 }
 
 /*
@@ -1060,7 +1077,7 @@
 
 	AAS_ClearShownDebugLines();
 	// movement prediction
-	AAS_PredictClientMovement(&move, entnum, origin, PRESENCE_NORMAL, qtrue, velocity, cmdmove, 13, 13, 0.1f, SE_HITGROUND, 0, qtrue); //SE_LEAVEGROUND
+	AAS_PredictClientMovement(&move, entnum, origin, PRESENCE_NORMAL, qtrue, qfalse, velocity, cmdmove, 13, 13, 0.1f, SE_HITGROUND, 0); //SE_LEAVEGROUND
 
 	if (move.stopevent & SE_LEAVEGROUND) {
 		botimport.Print(PRT_MESSAGE, "leave ground\n");
@@ -1117,3 +1134,54 @@
 
 	return 1;
 }
+
+/*
+=======================================================================================================================================
+AAS_HorizontalVelocityForScoutJump
+
+Calculates the horizontal velocity needed to perform a jump from start to end using the scout powerup.
+
+Parameter:	zvel	: z velocity for jump.
+			start	: start position of jump.
+			end		: end position of jump.
+			*speed	: returned speed for jump.
+Returns: qfalse if too high or too far from start to end.
+=======================================================================================================================================
+*/
+int AAS_HorizontalVelocityForScoutJump(float zvel, vec3_t start, vec3_t end, float *velocity) {
+	float phys_gravity, phys_maxscoutvelocity;
+	float maxscoutjump, height2fall, t, top;
+	vec3_t dir;
+
+	phys_gravity = aassettings.phys_gravity;
+	phys_maxscoutvelocity = aassettings.phys_maxscoutvelocity;
+	// maximum height a player can jump with the given initial z velocity
+	maxscoutjump = 0.5 * phys_gravity * (zvel / phys_gravity) * (zvel / phys_gravity);
+	// top of the parabolic jump
+	top = start[2] + maxscoutjump;
+	// height the bot will fall from the top
+	height2fall = top - end[2];
+	// if the goal is to high to jump to
+	if (height2fall < 0) {
+		*velocity = phys_maxscoutvelocity;
+		return 0;
+	}
+	// time a player takes to fall the height
+	t = sqrt(height2fall / (0.5 * phys_gravity));
+	// direction from start to end
+	VectorSubtract(end, start, dir);
+
+	if ((t + zvel / phys_gravity) == 0.0f) {
+		*velocity = phys_maxscoutvelocity;
+		return 0;
+	}
+	// calculate horizontal speed
+	*velocity = sqrt(dir[0] * dir[0] + dir[1] * dir[1]) / (t + zvel / phys_gravity);
+	// the horizontal speed must be lower than the max speed
+	if (*velocity > phys_maxscoutvelocity) {
+		*velocity = phys_maxscoutvelocity;
+		return 0;
+	}
+
+	return 1;
+}
Index: code/botlib/be_aas_move.h
===================================================================
--- code/botlib/be_aas_move.h	(revision 515)
+++ code/botlib/be_aas_move.h	(working copy)
@@ -26,9 +26,9 @@
 extern aas_settings_t aassettings;
 #endif // AASINTERN
 // movement prediction
-int AAS_PredictClientMovement(struct aas_clientmove_s *move, int entnum, vec3_t origin, int presencetype, int onground, vec3_t velocity, vec3_t cmdmove, int cmdframes, int maxframes, float frametime, int stopevent, int stopareanum, int visualize);
+int AAS_PredictClientMovement(struct aas_clientmove_s *move, int entnum, vec3_t origin, int presencetype, int onground, int scoutmove, vec3_t velocity, vec3_t cmdmove, int cmdframes, int maxframes, float frametime, int stopevent, int stopareanum);
 // predict movement until bounding box is hit
-int AAS_ClientMovementHitBBox(struct aas_clientmove_s *move, int entnum, vec3_t origin, int presencetype, int onground, vec3_t velocity, vec3_t cmdmove, int cmdframes, int maxframes, float frametime, vec3_t mins, vec3_t maxs, int visualize);
+int AAS_ClientMovementHitBBox(struct aas_clientmove_s *move, int entnum, vec3_t origin, int presencetype, int onground, int scoutmove, vec3_t velocity, vec3_t cmdmove, int cmdframes, int maxframes, float frametime, vec3_t mins, vec3_t maxs);
 // returns true if on the ground at the given origin
 int AAS_OnGround(vec3_t origin, int presencetype, int passent);
 // returns true if swimming at the given origin
@@ -35,6 +35,8 @@
 int AAS_Swimming(vec3_t origin);
 // returns the jump reachability run start point
 void AAS_JumpReachRunStart(struct aas_reachability_s *reach, vec3_t runstart);
+// returns the jump reachability run start point for jumps requiring the scout powerup ('scoutmove' movement prediction)
+void AAS_ScoutJumpReachRunStart(struct aas_reachability_s *reach, vec3_t runstart);
 // returns true if against a ladder at the given origin
 int AAS_AgainstLadder(vec3_t origin);
 // rocket jump Z velocity when rocket-jumping at origin
@@ -43,5 +45,6 @@
 float AAS_BFGJumpZVelocity(vec3_t origin);
 // calculates the horizontal velocity needed for a jump and returns true this velocity could be calculated
 int AAS_HorizontalVelocityForJump(float zvel, vec3_t start, vec3_t end, float *velocity);
+int AAS_HorizontalVelocityForScoutJump(float zvel, vec3_t start, vec3_t end, float *velocity);
 int AAS_DropToFloor(vec3_t origin, vec3_t mins, vec3_t maxs);
 void AAS_InitSettings(void);
Index: code/botlib/be_aas_reach.c
===================================================================
--- code/botlib/be_aas_reach.c	(revision 515)
+++ code/botlib/be_aas_reach.c	(working copy)
@@ -69,6 +69,8 @@
 int reach_walkoffledge;	// walk off a ledge
 int reach_swim;			// swim
 int reach_waterjump;	// jump out of water
+int reach_scoutjump;	// jump (wearing the scout powerup)
+int reach_scoutbarrier;	// barrier jump (scout powerup)
 int reach_rocketjump;	// rocket jump
 int reach_bfgjump;		// bfg jump
 int reach_teleport;		// teleport
@@ -76,6 +78,8 @@
 int reach_funcbob;		// use a func bob
 int reach_elevator;		// use an elevator
 int reach_ladder;		// climb or descent a ladder
+
+int calcscoutreach; // if true scout reachabilities are calculated
 // linked reachability
 typedef struct aas_lreachability_s {
 	int areanum;					// number of the reachable area
@@ -341,7 +341,7 @@
 
 		Com_Memset(&move, 0, sizeof(aas_clientmove_t));
 
-		AAS_ClientMovementHitBBox(&move, -1, areastart, PRESENCE_NORMAL, qfalse, velocity, cmdmove, 0, 30, 0.1f, bboxmins, bboxmaxs, bot_visualizejumppads);
+		AAS_ClientMovementHitBBox(&move, -1, areastart, PRESENCE_NORMAL, qfalse, qfalse, velocity, cmdmove, 0, 30, 0.1f, bboxmins, bboxmaxs);
 
 		if (move.frames < 30) {
 			bestareanum = 0;
@@ -672,6 +672,35 @@
 
 /*
 =======================================================================================================================================
+AAS_MaxScoutJumpHeight
+=======================================================================================================================================
+*/
+float AAS_MaxScoutJumpHeight(float phys_jumpvelscout) {
+	float phys_gravity;
+
+	phys_gravity = aassettings.phys_gravity;
+	// maximum height a player can jump with the given initial z velocity
+	return 0.5 * phys_gravity * (phys_jumpvelscout / phys_gravity) * (phys_jumpvelscout / phys_gravity);
+}
+
+/*
+=======================================================================================================================================
+AAS_MaxScoutJumpDistance
+=======================================================================================================================================
+*/
+float AAS_MaxScoutJumpDistance(float phys_jumpvelscout) {
+	float phys_gravity, phys_maxscoutvelocity, t;
+
+	phys_gravity = aassettings.phys_gravity;
+	phys_maxscoutvelocity = aassettings.phys_maxscoutvelocity;
+	// time a player takes to fall the height
+	t = sqrt(aassettings.rs_maxjumpfallheight / (0.5 * phys_gravity));
+	// maximum distance
+	return phys_maxscoutvelocity * (t + phys_jumpvelscout / phys_gravity);
+}
+
+/*
+=======================================================================================================================================
 AAS_AreaCrouch
 
 Returns true if a player can only crouch in the area.
@@ -1673,7 +1646,118 @@
 			}
 		}
 	}
+	//
+	// Scout Barrier Jumps (the scout powerup is required for jumping onto these barriers)
+	//
+	//        ---------
+	//        |
+	//        |
+	//        |
+	//        |
+	//        |         higher than step height lower than (scout) barrier height -> TRAVEL_SCOUTBARRIER
+	//--------|
+	//
+	//        ---------
+	//        |
+	//        |
+	//        |
+	//        |
+	//~~~~~~~~|         higher than step height lower than (scout) barrier height
+	//--------|         and a thin layer of water in the area to jump from -> TRAVEL_SCOUTBARRIER
+	//
+	if (calcscoutreach) {
+		// check for a barrier jump reachability using the scout powerup
+		if (ground_foundreach) {
+			// if area2 is higher but lower than the maximum barrier jump height using the scout powerup
+			if (ground_bestdist > 0 && ground_bestdist < aassettings.phys_maxscoutbarrier) {
+				// if no water in area1 or a very thin layer of water on the ground
+				if (!water_foundreach || (ground_bestdist - water_bestdist < 16)) {
+					// cannot perform a barrier jump towards or from a crouch area in Quake2
+					if (!AAS_AreaCrouch(area1num) && !AAS_AreaCrouch(area2num)) {
+						// create a scout barrier jump reachability from area1 to area2
+						lreach = AAS_AllocReachability();
+
+						if (!lreach) {
+							return qfalse;
+						}
+
+						lreach->areanum = area2num;
+						lreach->facenum = 0;
+						lreach->edgenum = ground_bestarea2groundedgenum;
+
+						VectorMA(ground_beststart, INSIDEUNITS_WALKSTART, ground_bestnormal, lreach->start);
+						VectorMA(ground_bestend, INSIDEUNITS_WALKEND, ground_bestnormal, lreach->end);
+
+						lreach->traveltype = TRAVEL_SCOUTBARRIER;
+						lreach->traveltime = aassettings.rs_barrierjump;
+						lreach->next = areareachability[area1num];
+
+						areareachability[area1num] = lreach;
+						// we've got another barrierjump reachability when using the scout powerup
+						reach_scoutbarrier++;
+						return qtrue;
+					}
+				}
+			}
+		}
+	}
+
 	return qfalse;
 }
 
@@ -2384,7 +2468,7 @@
 			VectorNormalize(dir);
 			VectorScale(dir, speed, velocity);
 			// movement prediction
-			AAS_PredictClientMovement(&move, -1, beststart, PRESENCE_NORMAL, qtrue, velocity, cmdmove, 3, 30, 0.1f, stopevent, 0, qfalse);
+			AAS_PredictClientMovement(&move, -1, beststart, PRESENCE_NORMAL, qtrue, qfalse, velocity, cmdmove, 3, 30, 0.1f, stopevent, 0);
 			// if prediction time wasn't enough to fully predict the movement
 			if (move.frames >= 30) {
 				return qfalse;
@@ -2467,6 +2552,276 @@
 
 /*
 =======================================================================================================================================
+AAS_Reachability_ScoutJump
+
+Creates possible jump reachabilities between the areas.
+
+The two closest points on the ground of the areas are calculated.
+One of the points will be on an edge of a ground face of area1 and one on an edge of a ground face of area2.
+If there is a range of closest points the point in the middle of this range is selected.
+Between these two points there must be one or more gaps. If the gaps exist a potential jump is predicted.
+=======================================================================================================================================
+*/
+int AAS_Reachability_ScoutJump(int area1num, int area2num) {
+	int i, j, k, l, face1num, face2num, edge1num, edge2num, traveltype;
+	int stopevent, areas[10], numareas;
+	float phys_jumpvelscout, maxscoutjumpdistance, maxscoutjumpheight, bestdist, speed;
+	vec_t *v1, *v2, *v3, *v4;
+	vec3_t beststart = {0}, beststart2 = {0}, bestend = {0}, bestend2 = {0};
+	vec3_t teststart, testend, dir, velocity, cmdmove, up = {0, 0, 1}, sidewards;
+	aas_area_t *area1, *area2;
+	aas_face_t *face1, *face2;
+	aas_edge_t *edge1, *edge2;
+	aas_plane_t *plane1, *plane2, *plane;
+	aas_trace_t trace;
+	aas_clientmove_t move;
+	aas_lreachability_t *lreach;
+
+	if (!AAS_AreaGrounded(area1num) || !AAS_AreaGrounded(area2num)) {
+		return qfalse;
+	}
+	// cannot jump from or to a crouch area
+	if (AAS_AreaCrouch(area1num) || AAS_AreaCrouch(area2num)) {
+		return qfalse;
+	}
+
+	area1 = &aasworld.areas[area1num];
+	area2 = &aasworld.areas[area2num];
+
+	phys_jumpvelscout = aassettings.phys_jumpvelscout;
+	// maximum distance a player can jump
+	maxscoutjumpdistance = 2 * AAS_MaxScoutJumpDistance(phys_jumpvelscout);
+	// maximum height a player can jump with the given initial z velocity
+	maxscoutjumpheight = AAS_MaxScoutJumpHeight(phys_jumpvelscout);
+	// if the areas are not near enough in the x-y direction
+	for (i = 0; i < 2; i++) {
+		if (area1->mins[i] > area2->maxs[i] + maxscoutjumpdistance) {
+			return qfalse;
+		}
+
+		if (area1->maxs[i] < area2->mins[i] - maxscoutjumpdistance) {
+			return qfalse;
+		}
+	}
+	// if area2 is way to high to jump up to
+	if (area2->mins[2] > area1->maxs[2] + maxscoutjumpheight) {
+		return qfalse;
+	}
+
+	bestdist = 999999;
+
+	for (i = 0; i < area1->numfaces; i++) {
+		face1num = aasworld.faceindex[area1->firstface + i];
+		face1 = &aasworld.faces[abs(face1num)];
+		// if not a ground face
+		if (!(face1->faceflags & FACE_GROUND)) {
+			continue;
+		}
+
+		for (j = 0; j < area2->numfaces; j++) {
+			face2num = aasworld.faceindex[area2->firstface + j];
+			face2 = &aasworld.faces[abs(face2num)];
+			// if not a ground face
+			if (!(face2->faceflags & FACE_GROUND)) {
+				continue;
+			}
+
+			for (k = 0; k < face1->numedges; k++) {
+				edge1num = abs(aasworld.edgeindex[face1->firstedge + k]);
+				edge1 = &aasworld.edges[edge1num];
+
+				for (l = 0; l < face2->numedges; l++) {
+					edge2num = abs(aasworld.edgeindex[face2->firstedge + l]);
+					edge2 = &aasworld.edges[edge2num];
+					// calculate the minimum distance between the two edges
+					v1 = aasworld.vertexes[edge1->v[0]];
+					v2 = aasworld.vertexes[edge1->v[1]];
+					v3 = aasworld.vertexes[edge2->v[0]];
+					v4 = aasworld.vertexes[edge2->v[1]];
+					// get the ground planes
+					plane1 = &aasworld.planes[face1->planenum];
+					plane2 = &aasworld.planes[face2->planenum];
+
+					bestdist = AAS_ClosestEdgePoints(v1, v2, v3, v4, plane1, plane2, beststart, bestend, beststart2, bestend2, bestdist);
+				}
+			}
+		}
+	}
+
+	VectorMiddle(beststart, beststart2, beststart);
+	VectorMiddle(bestend, bestend2, bestend);
+
+	if (bestdist > 4 && bestdist < maxscoutjumpdistance) {
+		// get the horizontal speed for the jump, if it isn't possible to calculate this speed (the jump is not possible) then there's no jump reachability created
+		if (!AAS_HorizontalVelocityForScoutJump(phys_jumpvelscout, beststart, bestend, &speed)) {
+			return qfalse;
+		}
+
+		speed *= 1.05f;
+		traveltype = TRAVEL_SCOUTJUMP;
+		// NOTE: test if the horizontal distance isn't too small
+		VectorSubtract(bestend, beststart, dir);
+
+		dir[2] = 0;
+
+		if (VectorLength(dir) < 10) {
+			return qfalse;
+		}
+
+		VectorSubtract(bestend, beststart, dir);
+		VectorNormalize(dir);
+		VectorMA(beststart, 1, dir, teststart);
+		VectorCopy(teststart, testend);
+
+		testend[2] -= 100;
+		trace = AAS_TraceClientBBox(teststart, testend, PRESENCE_NORMAL, -1);
+
+		if (trace.startsolid) {
+			return qfalse;
+		}
+
+		if (trace.fraction < 1) {
+			plane = &aasworld.planes[trace.planenum];
+			// if the bot can stand on the surface
+			if (DotProduct(plane->normal, up) >= 0.7) {
+				// if no lava or slime below
+				if (!(AAS_PointContents(trace.endpos) & (CONTENTS_LAVA|CONTENTS_SLIME))) {
+					if (teststart[2] - trace.endpos[2] <= aassettings.phys_maxscoutbarrier) {
+						return qfalse;
+					}
+				}
+			}
+		}
+
+		VectorMA(bestend, -1, dir, teststart);
+		VectorCopy(teststart, testend);
+
+		testend[2] -= 100;
+		trace = AAS_TraceClientBBox(teststart, testend, PRESENCE_NORMAL, -1);
+
+		if (trace.startsolid) {
+			return qfalse;
+		}
+
+		if (trace.fraction < 1) {
+			plane = &aasworld.planes[trace.planenum];
+			// if the bot can stand on the surface
+			if (DotProduct(plane->normal, up) >= 0.7) {
+				// if no lava or slime below
+				if (!(AAS_PointContents(trace.endpos) & (CONTENTS_LAVA|CONTENTS_SLIME))) {
+					if (teststart[2] - trace.endpos[2] <= aassettings.phys_maxscoutbarrier) {
+						return qfalse;
+					}
+				}
+			}
+		}
+		// get command movement
+		VectorClear(cmdmove);
+
+		if ((traveltype & TRAVELTYPE_MASK) == TRAVEL_SCOUTJUMP) {
+			cmdmove[2] = aassettings.phys_jumpvelscout;
+		} else {
+			cmdmove[2] = 0;
+		}
+
+		VectorSubtract(bestend, beststart, dir);
+
+		dir[2] = 0;
+
+		VectorNormalize(dir);
+		CrossProduct(dir, up, sidewards);
+
+		stopevent = SE_HITGROUNDDAMAGE|SE_ENTERLAVA|SE_ENTERSLIME|SE_GAP;
+
+		if (!AAS_AreaClusterPortal(area1num) && !AAS_AreaClusterPortal(area2num)) {
+			stopevent |= SE_TOUCHCLUSTERPORTAL;
+		}
+
+		for (i = 0; i < 3; i++) {
+			if (i == 1) {
+				VectorAdd(testend, sidewards, testend);
+			} else if (i == 2) {
+				VectorSubtract(bestend, sidewards, testend);
+			} else {
+				VectorCopy(bestend, testend);
+			}
+
+			VectorSubtract(testend, beststart, dir);
+
+			dir[2] = 0;
+
+			VectorNormalize(dir);
+			VectorScale(dir, speed, velocity);
+			// movement prediction
+			AAS_PredictClientMovement(&move, -1, beststart, PRESENCE_NORMAL, qtrue, qtrue, velocity, cmdmove, 3, 30, 0.1f, stopevent, 0);
+			// if prediction time wasn't enough to fully predict the movement
+			if (move.frames >= 30) {
+				return qfalse;
+			}
+			// never jump or fall through a cluster portal and don't enter slime or lava
+			if (move.stopevent & (SE_TOUCHCLUSTERPORTAL|SE_ENTERLAVA|SE_ENTERSLIME)) { // Tobias NOTE: why does SE_GAP destroy q3dm6?
+				return qfalse;
+			}
+			// the end position should be in area2, also test a little bit back because the predicted jump could have rushed through the area
+			VectorMA(move.endpos, -64, dir, teststart);
+
+			teststart[2] += 1;
+			numareas = AAS_TraceAreas(move.endpos, teststart, areas, NULL, ARRAY_LEN(areas));
+
+			for (j = 0; j < numareas; j++) {
+				if (areas[j] == area2num) {
+					break;
+				}
+			}
+
+			if (j < numareas) {
+				break;
+			}
+		}
+
+		if (i >= 3) {
+			return qfalse;
+		}
+		// create a new reachability link
+		lreach = AAS_AllocReachability();
+
+		if (!lreach) {
+			return qfalse;
+		}
+
+		lreach->areanum = area2num;
+		lreach->facenum = 0;
+		lreach->edgenum = 0;
+
+		VectorCopy(beststart, lreach->start);
+		VectorCopy(bestend, lreach->end);
+
+		lreach->traveltype = traveltype;
+
+		VectorSubtract(bestend, beststart, dir);
+
+		lreach->traveltime = aassettings.rs_startjump + VectorDistance(bestend, beststart) * 240 / aassettings.phys_maxscoutvelocity;
+
+		if (!AAS_AreaJumpPad(area2num)) {
+			if (AAS_FallDelta(beststart[2] - bestend[2]) > aassettings.phys_falldelta5) {
+				lreach->traveltime += aassettings.rs_falldamage5;
+			} else if (AAS_FallDelta(beststart[2] - bestend[2]) > aassettings.phys_falldelta10) {
+				lreach->traveltime += aassettings.rs_falldamage10;
+			}
+		}
+
+		lreach->next = areareachability[area1num];
+
+		areareachability[area1num] = lreach;
+
+		reach_scoutjump++;
+	}
+
+	return qfalse;
+}
+
+/*
+=======================================================================================================================================
 AAS_Reachability_Ladder
 
 Create a possible ladder reachability from area1 to area2.
@@ -3006,7 +3361,7 @@
 
 				VectorClear(cmdmove);
 				// movement prediction
-				AAS_PredictClientMovement(&move, -1, destorigin, PRESENCE_NORMAL, qfalse, velocity, cmdmove, 0, 30, 0.1f, SE_TOUCHTELEPORTER|SE_TOUCHJUMPPAD|SE_HITGROUNDDAMAGE|SE_ENTERWATER|SE_ENTERLAVA|SE_ENTERSLIME|SE_HITGROUND, 0, qfalse); //qtrue
+				AAS_PredictClientMovement(&move, -1, destorigin, PRESENCE_NORMAL, qfalse, qfalse, velocity, cmdmove, 0, 30, 0.1f, SE_TOUCHTELEPORTER|SE_TOUCHJUMPPAD|SE_HITGROUNDDAMAGE|SE_ENTERWATER|SE_ENTERLAVA|SE_ENTERSLIME|SE_HITGROUND, 0);
 
 				area2num = AAS_PointAreaNum(move.endpos);
 
@@ -3892,7 +4243,7 @@
 
 			for (i = 0; i < 20; i++) {
 				// movement prediction
-				AAS_PredictClientMovement(&move, -1, areastart, PRESENCE_NORMAL, qfalse, velocity, cmdmove, 0, 30, 0.1f, SE_TOUCHTELEPORTER|SE_TOUCHJUMPPAD|SE_HITGROUNDDAMAGE|SE_ENTERLAVA|SE_ENTERSLIME|SE_HITGROUND, 0, bot_visualizejumppads);
+				AAS_PredictClientMovement(&move, -1, areastart, PRESENCE_NORMAL, qfalse, qfalse, velocity, cmdmove, 0, 30, 0.1f, SE_TOUCHTELEPORTER|SE_TOUCHJUMPPAD|SE_HITGROUNDDAMAGE|SE_ENTERLAVA|SE_ENTERSLIME|SE_HITGROUND, 0);
 
 				area2num = move.endarea;
 
@@ -4017,7 +4357,7 @@
 						// get command movement
 						VectorScale(dir, speed, cmdmove);
 						// movement prediction
-						AAS_PredictClientMovement(&move, -1, areastart, PRESENCE_NORMAL, qfalse, velocity, cmdmove, 30, 30, 0.1f, SE_TOUCHTELEPORTER|SE_TOUCHJUMPPAD|SE_HITGROUNDAREA|SE_HITGROUNDDAMAGE|SE_ENTERLAVA|SE_ENTERSLIME, area2num, visualize); // Tobias NOTE: does SE_GAP destroy some maps?
+						AAS_PredictClientMovement(&move, -1, areastart, PRESENCE_NORMAL, qfalse, qfalse, velocity, cmdmove, 30, 30, 0.1f, SE_TOUCHTELEPORTER|SE_TOUCHJUMPPAD|SE_HITGROUNDAREA|SE_HITGROUNDDAMAGE|SE_ENTERLAVA|SE_ENTERSLIME, area2num); // Tobias NOTE: does SE_GAP destroy some maps?
 						// if prediction time wasn't enough to fully predict the movement, don't fall from too high and don't enter slime or lava
 						if (move.frames < 30 && (move.stopevent & (SE_TOUCHTELEPORTER|SE_TOUCHJUMPPAD|SE_HITGROUNDAREA)) && !(move.stopevent & (SE_HITGROUNDDAMAGE|SE_ENTERLAVA|SE_ENTERSLIME))) { // Tobias NOTE: does SE_GAP destroy some maps?
 							// never go back to the same jumppad
@@ -4230,7 +4564,7 @@
 				VectorScale(dir, speed, cmdmove);
 				VectorSet(velocity, 0, 0, zvel);
 				// movement prediction
-				AAS_PredictClientMovement(&move, -1, areastart, PRESENCE_NORMAL, qtrue, velocity, cmdmove, 30, 30, 0.1f, SE_TOUCHTELEPORTER|SE_TOUCHJUMPPAD|SE_HITGROUNDAREA|SE_HITGROUNDDAMAGE|SE_ENTERLAVA|SE_ENTERSLIME|SE_HITGROUND|SE_GAP, area2num, visualize);
+				AAS_PredictClientMovement(&move, -1, areastart, PRESENCE_NORMAL, qtrue, qfalse, velocity, cmdmove, 30, 30, 0.1f, SE_TOUCHTELEPORTER|SE_TOUCHJUMPPAD|SE_HITGROUNDAREA|SE_HITGROUNDDAMAGE|SE_ENTERLAVA|SE_ENTERSLIME|SE_HITGROUND|SE_GAP, area2num);
 				// if prediction time wasn't enough to fully predict the movement, don't fall from too high, don't enter slime or lava and don't fall in gaps
 				if (move.frames < 30 && (move.stopevent & (SE_TOUCHTELEPORTER|SE_TOUCHJUMPPAD|SE_HITGROUNDAREA|SE_HITGROUND)) && !(move.stopevent & (SE_HITGROUNDDAMAGE|SE_ENTERLAVA|SE_ENTERSLIME|SE_GAP))) {
 					// create a rocket or bfg jump reachability from area1 to area2
@@ -4595,6 +4929,12 @@
 			if (AAS_Reachability_Swim(i, j)) {
 				continue;
 			}
+			// check for a scout jump reachability
+			if (calcscoutreach) {
+				if (AAS_Reachability_ScoutJump(i, j)) {
+					continue;
+				}
+			}
 			// check for ladder reachabilities
 			if (AAS_Reachability_Ladder(i, j)) {
 				continue;
@@ -4705,7 +5045,9 @@
 		return;
 #endif // BSPC
 	}
-
+#ifndef BSPC
+	calcscoutreach = LibVarGetValue("scoutreach");
+#endif
 	aasworld.savefile = qtrue;
 	// start with area 1 because area zero is a dummy
 	aasworld.numreachabilityareas = 1;
Index: code/botlib/be_aas_route.c
===================================================================
--- code/botlib/be_aas_route.c	(revision 515)
+++ code/botlib/be_aas_route.c	(working copy)
@@ -1217,6 +1217,14 @@
 				numareas = AAS_TraceAreas(reach->start, end, areas, NULL, MAX_REACHABILITYPASSAREAS);
 				break;
 			// trace arch
+			case TRAVEL_SCOUTJUMP:
+				break;
+			case TRAVEL_SCOUTBARRIER:
+				VectorCopy(reach->start, end);
+				end[2] = reach->end[2];
+				numareas = AAS_TraceAreas(reach->start, end, areas, NULL, MAX_REACHABILITYPASSAREAS);
+				break;
+			// trace arch
 			case TRAVEL_ROCKETJUMP:
 				break;
 			case TRAVEL_BFGJUMP:
Index: code/botlib/be_ai_move.c
===================================================================
--- code/botlib/be_ai_move.c	(revision 515)
+++ code/botlib/be_ai_move.c	(working copy)
@@ -728,6 +728,12 @@
 		case TRAVEL_WATERJUMP:
 			checkbetween = qtrue;
 			break;
+		case TRAVEL_SCOUTJUMP:
+			checkbetween = qfalse;
+			break;
+		case TRAVEL_SCOUTBARRIER:
+			checkbetween = qtrue;
+			break;
 		case TRAVEL_ROCKETJUMP:
 			checkbetween = qfalse;
 			break;
@@ -1223,7 +1229,7 @@
 */
 int BotWalkInDirection(bot_movestate_t *ms, vec3_t dir, float speed, int type) {
 	vec3_t hordir, cmdmove, velocity, tmpdir, origin;
-	int presencetype, maxframes, cmdframes, stopevent;
+	int presencetype, maxframes, cmdframes, stopevent, scoutFlag;
 	aas_clientmove_t move;
 	float dist;
 
@@ -1278,8 +1284,9 @@
 		VectorCopy(ms->origin, origin);
 
 		origin[2] += 0.5;
+		scoutFlag = ms->moveflags & MFL_SCOUT ? qtrue : qfalse;
 		// movement prediction
-		AAS_PredictClientMovement(&move, ms->entitynum, origin, presencetype, qtrue, velocity, cmdmove, cmdframes, maxframes, 0.1f, stopevent, 0, qfalse); // qtrue
+		AAS_PredictClientMovement(&move, ms->entitynum, origin, presencetype, qtrue, scoutFlag, velocity, cmdmove, cmdframes, maxframes, 0.1f, stopevent, 0);
 		// if prediction time wasn't enough to fully predict the movement
 		if (move.frames >= maxframes && (type & MOVE_JUMP)) {
 			//botimport.Print(PRT_MESSAGE, "client %d: max prediction frames\n", ms->client);
@@ -1584,6 +1591,7 @@
 */
 bot_moveresult_t BotTravel_BarrierJump(bot_movestate_t *ms, aas_reachability_t *reach) {
 	float rundist, dist, jumpdist, speed, currentspeed;
+	int scoutFlag;
 	vec3_t hordir, cmdmove, end, velocity;
 	bot_moveresult_t_cleared(result);
 	aas_clientmove_t move;
@@ -1603,11 +1611,13 @@
 	BotCheckBlocked(ms, hordir, qtrue, &result);
 	// get command movement
 	VectorScale(hordir, 400, cmdmove);
+
+	scoutFlag = ms->moveflags & MFL_SCOUT ? qtrue : qfalse;
 	VectorCopy(ms->velocity, velocity);
 	// start point
 	VectorCopy(reach->end, end);
 	// movement prediction
-	AAS_PredictClientMovement(&move, ms->entitynum, end, PRESENCE_NORMAL, qtrue, velocity, cmdmove, 2, 2, 0.1f, SE_HITGROUNDDAMAGE|SE_ENTERLAVA|SE_ENTERSLIME|SE_GAP, 0, qfalse);
+	AAS_PredictClientMovement(&move, ms->entitynum, end, PRESENCE_NORMAL, qtrue, scoutFlag, velocity, cmdmove, 2, 2, 0.1f, SE_HITGROUNDDAMAGE|SE_ENTERLAVA|SE_ENTERSLIME|SE_GAP, 0);
 	// reduce the speed if the bot will fall into slime, lava or into a gap
 	if (move.stopevent & (SE_HITGROUNDDAMAGE|SE_ENTERLAVA|SE_ENTERSLIME|SE_GAP)) {
 
@@ -1782,7 +1792,7 @@
 bot_moveresult_t BotTravel_WalkOffLedge(bot_movestate_t *ms, aas_reachability_t *reach) {
 	vec3_t hordir, dir, cmdmove, velocity;
 	float dist, speed, reachhordist;
-	int gapdist;
+	int gapdist, scoutFlag;
 	bot_moveresult_t_cleared(result);
 	aas_clientmove_t move;
 
@@ -1812,9 +1822,11 @@
 		VectorNormalize(hordir);
 		// get command movement
 		VectorScale(hordir, 400, cmdmove);
+
+		scoutFlag = ms->moveflags & MFL_SCOUT ? qtrue : qfalse;
 		VectorCopy(ms->velocity, velocity);
 		// movement prediction
-		AAS_PredictClientMovement(&move, ms->entitynum, reach->end, PRESENCE_NORMAL, qtrue, velocity, cmdmove, 2, 2, 0.1f, SE_TOUCHJUMPPAD|SE_HITGROUNDDAMAGE|SE_ENTERLAVA|SE_ENTERSLIME|SE_GAP, 0, qfalse); //qtrue
+		AAS_PredictClientMovement(&move, ms->entitynum, reach->end, PRESENCE_NORMAL, qtrue, scoutFlag, velocity, cmdmove, 2, 2, 0.1f, SE_TOUCHJUMPPAD|SE_HITGROUNDDAMAGE|SE_ENTERLAVA|SE_ENTERSLIME|SE_GAP, 0);
 		// check for nearby gap behind the current ledge
 		gapdist = BotGapDistance(reach->end, hordir, 400, ms->entitynum);
 		// if there is no gap under the current ledge
@@ -2078,10 +2090,14 @@
 	float dist1, dist2, dist3, speed;
 	bot_moveresult_t_cleared(result);
 
-	AAS_JumpReachRunStart(reach, runstart);
+	if (ms->moveflags & MFL_SCOUT) {
+		AAS_ScoutJumpReachRunStart(reach, runstart);
+	} else {
+		AAS_JumpReachRunStart(reach, runstart);
+	}
+
 	VectorSubtract(ms->origin, reach->start, dir1);
 
 	dir1[2] = 0;
@@ -3060,6 +3076,10 @@
 			return 5;
 		case TRAVEL_WATERJUMP:
 			return 5;
+		case TRAVEL_SCOUTJUMP:
+			return 5;
+		case TRAVEL_SCOUTBARRIER:
+			return 5;
 		case TRAVEL_ROCKETJUMP:
 			return 6;
 		case TRAVEL_BFGJUMP:
@@ -3414,6 +3434,12 @@
 				case TRAVEL_WATERJUMP:
 					*result = BotTravel_WaterJump(ms, &reach);
 					break;
+				case TRAVEL_SCOUTJUMP: // Tobias NOTE: separate 'BotTravel_ScoutJump' needed?
+					*result = BotTravel_Jump(ms, &reach);
+					break;
+				case TRAVEL_SCOUTBARRIER: // Tobias NOTE: separate 'BotTravel_ScoutBarrierJump' needed?
+					*result = BotTravel_BarrierJump(ms, &reach);
+					break;
 				case TRAVEL_ROCKETJUMP:
 					*result = BotTravel_RocketJump(ms, &reach);
 					break;
@@ -3536,6 +3562,12 @@
 				case TRAVEL_WATERJUMP:
 					*result = BotFinishTravel_WaterJump(ms, &reach);
 					break;
+				case TRAVEL_SCOUTJUMP: // Tobias NOTE: separate 'BotFinishTravel_ScoutJump' needed?
+					*result = BotFinishTravel_Jump(ms, &reach);
+					break;
+				case TRAVEL_SCOUTBARRIER: // Tobias NOTE: separate 'BotFinishTravel_ScoutBarrierJump' needed?
+					*result = BotFinishTravel_BarrierJump(ms, &reach);
+					break;
 				case TRAVEL_ROCKETJUMP:
 				case TRAVEL_BFGJUMP:
 					*result = BotFinishTravel_WeaponJump(ms, &reach);
Index: code/botlib/botlib.h
===================================================================
--- code/botlib/botlib.h	(revision 515)
+++ code/botlib/botlib.h	(working copy)
@@ -181,7 +181,7 @@
 	int (*AAS_AreaReachability)(int areanum);
 	int (*AAS_AreaTravelTimeToGoalArea)(int areanum, vec3_t origin, int goalareanum, int travelflags);
 	int (*AAS_EnableRoutingArea)(int areanum, int enable);
-	int (*AAS_PredictClientMovement)(struct aas_clientmove_s *move, int entnum, vec3_t origin, int presencetype, int onground, vec3_t velocity, vec3_t cmdmove, int cmdframes, int maxframes, float frametime, int stopevent, int stopareanum, int visualize);
+	int (*AAS_PredictClientMovement)(struct aas_clientmove_s *move, int entnum, vec3_t origin, int presencetype, int onground, int scoutmove, vec3_t velocity, vec3_t cmdmove, int cmdframes, int maxframes, float frametime, int stopevent, int stopareanum);
 	int (*AAS_PredictRoute)(struct aas_predictroute_s *route, int areanum, vec3_t origin, int goalareanum, int travelflags, int maxareas, int maxtime, int stopevent, int stopcontents, int stoptfl, int stopareanum);
 	int (*AAS_AlternativeRouteGoals)(vec3_t start, int startareanum, vec3_t goal, int goalareanum, int travelflags, struct aas_altroutegoal_s *altroutegoals, int maxaltroutegoals, int type);
 	int (*AAS_ValueForBSPEpairKey)(int ent, char *key, char *value, int size);
@@ -369,6 +369,7 @@
 "phys_waterfriction"		"1"			be_aas_move.c	water friction
 "phys_watergravity"			"400"		be_aas_move.c	gravity in water
 "phys_maxvelocity"			"260"		be_aas_move.c	maximum velocity
+"phys_maxscoutvelocity"		"390"		be_aas_move.c	maximum velocity (using the scout powerup)
 "phys_maxwalkvelocity"		"280"		be_aas_move.c	maximum walk velocity
 "phys_maxcrouchvelocity"	"100"		be_aas_move.c	maximum crouch velocity
 "phys_maxswimvelocity"		"45"		be_aas_move.c	maximum swim velocity
@@ -379,7 +380,9 @@
 "phys_maxsteepness"			"0.7"		be_aas_move.c	maximum floor steepness
 "phys_maxwaterjump"			"20"		be_aas_move.c	maximum waterjump height
 "phys_maxbarrier"			"43"		be_aas_move.c	maximum barrier height
+"phys_maxscoutbarrier"		"73"		be_aas_move.c	maximum barrier height (using the scout powerup)
 "phys_jumpvel"				"200"		be_aas_move.c	jump z velocity
+"phys_jumpvelscout"			"300"		be_aas_move.c	jump z velocity (using the scout powerup)
 "phys_falldelta5"			"40"		be_aas_move.c
 "phys_falldelta10"			"60"		be_aas_move.c
 "rs_waterjump"				"400"		be_aas_move.c
Index: code/bspc/bspc.c
===================================================================
--- code/bspc/bspc.c	(revision 515)
+++ code/bspc/bspc.c	(working copy)
@@ -49,6 +49,7 @@
 #include "be_aas_bspc.h"
 
 extern	int use_nodequeue;		//brushbsp.c
+extern	int calcscoutreach;		//be_aas_reach.c
 
 float			subdivide_size = 240;
 char			source[1024];
@@ -288,6 +289,7 @@
 	Log_Print(BSPC_NAME" version "BSPC_VERSION", %s %s\n", __DATE__, __TIME__);
 
 #ifdef ZTMAUTOARGS
+	calcscoutreach = true;
 	forcesidesvisible = true; // Currently always required or BSPC fails?
 #endif
 	DefaultCfg();
@@ -398,6 +400,18 @@
 			freetree = true;
 			Log_Print("freetree = true\n");
 		} //end else if
+		else if (!stricmp(argv[i], "-scoutreach"))
+		{
+			calcscoutreach = true;
+			Log_Print("scoutreach = true\n");
+		} //end else if
+#ifdef ZTMAUTOARGS
+		else if (!stricmp(argv[i], "-noscoutreach"))
+		{
+			calcscoutreach = false;
+			Log_Print("scoutreach = false\n");
+		} //end else if
+#endif
 		else if (!stricmp(argv[i], "-nobrushmerge"))
 		{
 			nobrushmerge = true;
@@ -715,8 +729,10 @@
 			"   nocsg                                = disables brush chopping\n"
 #ifdef ZTMAUTOARGS
 			"   noforcesidesvisible                  = don't force all sides to be visible\n"
+			"   noscoutreach                         = don't calculate scout reachabilities\n"
 #else
 			"   forcesidesvisible                    = force all sides to be visible\n"
+			"   scoutreach                           = calculate scout reachabilities\n"
 #endif
 /*			"   noweld     = disables weld\n"
 			"   noshare    = disables sharing\n"
Index: code/game/ai_dmnet.c
===================================================================
--- code/game/ai_dmnet.c	(revision 515)
+++ code/game/ai_dmnet.c	(working copy)
@@ -1634,6 +1634,10 @@
 	if (BotInLavaOrSlime(bs)) {
 		bs->tfl |= TFL_LAVA|TFL_SLIME;
 	}
+	// if the bot has the scout powerup
+	if (BotHasScout(bs)) {
+		bs->tfl |= TFL_SCOUTBARRIER|TFL_SCOUTJUMP;
+	}
 	// map specific code
 	BotMapScripts(bs);
 	// no enemy
@@ -1873,6 +1877,10 @@
 	if (BotInLavaOrSlime(bs)) {
 		bs->tfl |= TFL_LAVA|TFL_SLIME;
 	}
+	// if the bot has the scout powerup
+	if (BotHasScout(bs)) {
+		bs->tfl |= TFL_SCOUTBARRIER|TFL_SCOUTJUMP;
+	}
 
 	if (BotCanAndWantsToRocketJump(bs)) {
 		bs->tfl |= TFL_ROCKETJUMP;
@@ -2013,6 +2021,10 @@
 	if (BotInLavaOrSlime(bs)) {
 		bs->tfl |= TFL_LAVA|TFL_SLIME;
 	}
+	// if the bot has the scout powerup
+	if (BotHasScout(bs)) {
+		bs->tfl |= TFL_SCOUTBARRIER|TFL_SCOUTJUMP;
+	}
 
 	if (BotCanAndWantsToRocketJump(bs)) {
 		bs->tfl |= TFL_ROCKETJUMP;
@@ -2277,6 +2289,10 @@
 	if (BotInLavaOrSlime(bs)) {
 		bs->tfl |= TFL_LAVA|TFL_SLIME;
 	}
+	// if the bot has the scout powerup
+	if (BotHasScout(bs)) {
+		bs->tfl |= TFL_SCOUTBARRIER|TFL_SCOUTJUMP;
+	}
 
 	if (BotCanAndWantsToRocketJump(bs)) {
 		bs->tfl |= TFL_ROCKETJUMP;
@@ -2376,6 +2392,10 @@
 	if (BotInLavaOrSlime(bs)) {
 		bs->tfl |= TFL_LAVA|TFL_SLIME;
 	}
+	// if the bot has the scout powerup
+	if (BotHasScout(bs)) {
+		bs->tfl |= TFL_SCOUTBARRIER|TFL_SCOUTJUMP;
+	}
 
 	if (BotCanAndWantsToRocketJump(bs)) {
 		bs->tfl |= TFL_ROCKETJUMP;
@@ -2524,6 +2544,10 @@
 	if (BotInLavaOrSlime(bs)) {
 		bs->tfl |= TFL_LAVA|TFL_SLIME;
 	}
+	// if the bot has the scout powerup
+	if (BotHasScout(bs)) {
+		bs->tfl |= TFL_SCOUTBARRIER|TFL_SCOUTJUMP;
+	}
 	// map specific code
 	BotMapScripts(bs);
 	// update the attack inventory values
@@ -2705,6 +2729,10 @@
 	if (BotInLavaOrSlime(bs)) {
 		bs->tfl |= TFL_LAVA|TFL_SLIME;
 	}
+	// if the bot has the scout powerup
+	if (BotHasScout(bs)) {
+		bs->tfl |= TFL_SCOUTBARRIER|TFL_SCOUTJUMP;
+	}
 
 	if (BotCanAndWantsToRocketJump(bs)) {
 		bs->tfl |= TFL_ROCKETJUMP;
Index: code/game/ai_dmq3.c
===================================================================
--- code/game/ai_dmq3.c	(revision 515)
+++ code/game/ai_dmq3.c	(working copy)
@@ -4895,7 +4895,7 @@
 
 					VectorClear(cmdmove);
 					// movement prediction
-					trap_AAS_PredictClientMovement(&move, bs->enemy, origin, PRESENCE_CROUCH, qfalse, dir, cmdmove, 0, dist * 10 / wi.speed, 0.1f, 0, 0, qfalse);
+					trap_AAS_PredictClientMovement(&move, bs->enemy, origin, PRESENCE_CROUCH, qfalse, qfalse, dir, cmdmove, 0, dist * 10 / wi.speed, 0.1f, 0, 0);
 					VectorCopy(move.endpos, bestorigin);
 				// if not that skilled do linear prediction
 				} else if (aim_skill > 0.4) {
Index: code/game/g_local.h
===================================================================
--- code/game/g_local.h	(revision 515)
+++ code/game/g_local.h	(working copy)
@@ -591,7 +591,7 @@
 int trap_AAS_PredictRoute(void /*struct aas_predictroute_s*/ *route, int areanum, vec3_t origin, int goalareanum, int travelflags, int maxareas, int maxtime, int stopevent, int stopcontents, int stoptfl, int stopareanum);
 int trap_AAS_AlternativeRouteGoals(vec3_t start, int startareanum, vec3_t goal, int goalareanum, int travelflags, void /*struct aas_altroutegoal_s*/ *altroutegoals, int maxaltroutegoals, int type);
 int trap_AAS_Swimming(vec3_t origin);
-int trap_AAS_PredictClientMovement(void /*aas_clientmove_s*/ *move, int entnum, vec3_t origin, int presencetype, int onground, vec3_t velocity, vec3_t cmdmove, int cmdframes, int maxframes, float frametime, int stopevent, int stopareanum, int visualize);
+int trap_AAS_PredictClientMovement(void /*aas_clientmove_s*/ *move, int entnum, vec3_t origin, int presencetype, int onground, int scoutmove, vec3_t velocity, vec3_t cmdmove, int cmdframes, int maxframes, float frametime, int stopevent, int stopareanum);
 void trap_EA_Say(int client, char *str);
 void trap_EA_SayTeam(int client, char *str);
 void trap_EA_Command(int client, char *command);
Index: code/game/g_syscalls.c
===================================================================
--- code/game/g_syscalls.c	(revision 515)
+++ code/game/g_syscalls.c	(working copy)
@@ -799,8 +799,8 @@
 trap_AAS_PredictClientMovement
 =======================================================================================================================================
 */
-int trap_AAS_PredictClientMovement(void /*struct aas_clientmove_s*/ *move, int entnum, vec3_t origin, int presencetype, int onground, vec3_t velocity, vec3_t cmdmove, int cmdframes, int maxframes, float frametime, int stopevent, int stopareanum, int visualize) {
-	return syscall(BOTLIB_AAS_PREDICT_CLIENT_MOVEMENT, move, entnum, origin, presencetype, onground, velocity, cmdmove, cmdframes, maxframes, PASSFLOAT(frametime), stopevent, stopareanum, visualize);
+int trap_AAS_PredictClientMovement(void /*struct aas_clientmove_s*/ *move, int entnum, vec3_t origin, int presencetype, int onground, int scoutmove, vec3_t velocity, vec3_t cmdmove, int cmdframes, int maxframes, float frametime, int stopevent, int stopareanum) {
+	return syscall(BOTLIB_AAS_PREDICT_CLIENT_MOVEMENT, move, entnum, origin, presencetype, onground, scoutmove, velocity, cmdmove, cmdframes, maxframes, PASSFLOAT(frametime), stopevent, stopareanum);
 }
 
 /*
Index: code/server/sv_game.c
===================================================================
--- code/server/sv_game.c	(revision 515)
+++ code/server/sv_game.c	(working copy)
@@ -565,7 +565,7 @@
 		case BOTLIB_AAS_ENABLE_ROUTING_AREA:
 			return botlib_export->aas.AAS_EnableRoutingArea(args[1], args[2]);
 		case BOTLIB_AAS_PREDICT_CLIENT_MOVEMENT:
-			return botlib_export->aas.AAS_PredictClientMovement(VMA(1), args[2], VMA(3), args[4], args[5], VMA(6), VMA(7), args[8], args[9], VMF(10), args[11], args[12], args[13]);
+			return botlib_export->aas.AAS_PredictClientMovement(VMA(1), args[2], VMA(3), args[4], args[5], args[6], VMA(7), VMA(8), args[9], args[10], VMF(11), args[12], args[13]);
 		case BOTLIB_AAS_PREDICT_ROUTE:
 			return botlib_export->aas.AAS_PredictRoute(VMA(1), args[2], VMA(3), args[4], args[5], args[6], args[7], args[8], args[9], args[10], args[11]);
 		case BOTLIB_AAS_ALTERNATIVE_ROUTE_GOAL:
