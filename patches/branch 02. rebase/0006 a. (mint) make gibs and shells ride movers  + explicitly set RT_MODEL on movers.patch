Index: code/cgame/cg_ents.c
===================================================================
--- code/cgame/cg_ents.c	(revision 3362)
+++ code/cgame/cg_ents.c	(working copy)
@@ -580,6 +580,7 @@
 	VectorCopy( cent->lerpOrigin, ent.oldorigin);
 	AnglesToAxis( cent->lerpAngles, ent.axis );
 
+	ent.reType = RT_MODEL;
 	ent.renderfx = RF_NOSHADOW;
 
 	// flicker between two skins (FIXME?)
Index: code/cgame/cg_local.h
===================================================================
--- code/cgame/cg_local.h	(revision 3361)
+++ code/cgame/cg_local.h	(working copy)
@@ -274,6 +274,8 @@
 	leBounceSoundType_t	leBounceSoundType;
 
 	refEntity_t		refEntity;		
+
+	int				groundEntityNum;
 } localEntity_t;
 
 //======================================================================
Index: code/cgame/cg_localents.c
===================================================================
--- code/cgame/cg_localents.c	(revision 3359)
+++ code/cgame/cg_localents.c	(working copy)
@@ -215,13 +215,15 @@
 	float	dot;
 	int		hitTime;
 
-	// reflect the velocity on the trace plane
-	hitTime = cg.time - cg.frametime + cg.frametime * trace->fraction;
-	BG_EvaluateTrajectoryDelta( &le->pos, hitTime, velocity );
-	dot = DotProduct( velocity, trace->plane.normal );
-	VectorMA( velocity, -2*dot, trace->plane.normal, le->pos.trDelta );
+	if ( !trace->allsolid ) {
+		// reflect the velocity on the trace plane
+		hitTime = cg.time - cg.frametime + cg.frametime * trace->fraction;
+		BG_EvaluateTrajectoryDelta( &le->pos, hitTime, velocity );
+		dot = DotProduct( velocity, trace->plane.normal );
+		VectorMA( velocity, -2*dot, trace->plane.normal, le->pos.trDelta );
 
-	VectorScale( le->pos.trDelta, le->bounceFactor, le->pos.trDelta );
+		VectorScale( le->pos.trDelta, le->bounceFactor, le->pos.trDelta );
+	}
 
 	VectorCopy( trace->endpos, le->pos.trBase );
 	le->pos.trTime = cg.time;
@@ -232,6 +234,9 @@
 		( trace->plane.normal[2] > 0 && 
 		( le->pos.trDelta[2] < 40 || le->pos.trDelta[2] < -cg.frametime * le->pos.trDelta[2] ) ) ) {
 		le->pos.trType = TR_STATIONARY;
+		VectorCopy( trace->endpos, le->refEntity.origin );
+		vectoangles( le->refEntity.axis[0], le->angles.trBase );
+		le->groundEntityNum = trace->entityNum;
 	} else {
 
 	}
@@ -251,6 +256,12 @@
 		int		t;
 		float	oldZ;
 		
+		CG_AdjustPositionForMover( le->refEntity.origin, le->groundEntityNum,
+			le->pos.trTime, cg.time, le->refEntity.origin, le->angles.trBase, le->angles.trBase );
+
+		AnglesToAxis( le->angles.trBase, le->refEntity.axis );
+		le->pos.trTime = cg.time;
+
 		t = le->endTime - cg.time;
 		if ( t < SINK_TIME ) {
 			// we must use an explicit lighting origin, otherwise the
@@ -295,6 +306,43 @@
 		return;
 	}
 
+	// fragment inside mover, find the direction/origin of impact
+	if ( trace.allsolid && cg_entities[trace.entityNum].currentState.eType == ET_MOVER ) {
+		vec3_t	origin, angles, dir;
+		float	dist;
+		int		oldTime;
+		trace_t	tr;
+
+		// get last location
+		if ( cg.time == le->pos.trTime ) {
+			// fragment was added this frame. no good way to fix this.
+			CG_FreeLocalEntity( le );
+			return;
+		} else {
+			oldTime = le->pos.trTime;
+		}
+		BG_EvaluateTrajectory( &le->pos, oldTime, origin );
+
+		VectorClear( angles );
+
+		// add the distance mover has moved since then
+		CG_AdjustPositionForMover( origin, trace.entityNum,
+			oldTime, cg.time, origin, angles, angles );
+
+		// nudge the origin farther to avoid being co-planar
+		VectorSubtract( origin, newOrigin, dir );
+		dist = VectorNormalize( dir );
+		VectorMA( origin, dist, dir, origin );
+
+		CG_Trace( &tr, origin, NULL, NULL, newOrigin, -1, CONTENTS_SOLID );
+
+		// found impact. restore allsolid because trace fraction won't work correct in CG_ReflectVelocity
+		if ( !tr.allsolid ) {
+			trace = tr;
+			trace.allsolid = qtrue;
+		}
+	}
+
 	// if it is in a nodrop zone, remove it
 	// this keeps gibs from waiting at the bottom of pits of death
 	// and floating levels
@@ -807,7 +855,12 @@
 */
 void CG_AddLocalEntities( void ) {
 	localEntity_t	*le, *next;
+	int oldPhysicsTime;
 
+	// have local entities interact with movers (submodels) at their render position
+	oldPhysicsTime = cg.physicsTime;
+	cg.physicsTime = cg.time;
+
 	// walk the list backwards, so any new local entities generated
 	// (trails, marks, etc) will be present this frame
 	le = cg_activeLocalEntities.prev;
@@ -876,6 +929,8 @@
 #endif
 		}
 	}
+
+	cg.physicsTime = oldPhysicsTime;
 }
 
 
