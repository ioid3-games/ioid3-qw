Index: code/cgame/cg_draw.c
===================================================================
--- code/cgame/cg_draw.c	(revision 3386)
+++ code/cgame/cg_draw.c	(working copy)
@@ -260,11 +260,11 @@
 
 /*
 ================
-CG_Draw3DModel
+CG_Draw3DModelEx
 
 ================
 */
-void CG_Draw3DModel( float x, float y, float w, float h, qhandle_t model, cgSkin_t *skin, vec3_t origin, vec3_t angles ) {
+void CG_Draw3DModelEx( float x, float y, float w, float h, qhandle_t model, cgSkin_t *skin, vec3_t origin, vec3_t angles, const byte *rgba, entityState_t *state ) {
 	refdef_t		refdef;
 	refEntity_t		ent;
 
@@ -280,7 +280,7 @@
 	AnglesToAxis( angles, ent.axis );
 	VectorCopy( origin, ent.origin );
 	ent.hModel = model;
-	ent.customSkin = CG_AddSkinToFrame( skin );
+	ent.customSkin = CG_AddSkinToFrame( skin, state );
 	ent.renderfx = RF_NOSHADOW;		// no stencil shadows
 
 	refdef.rdflags = RDF_NOWORLDMODEL;
@@ -304,6 +304,16 @@
 
 /*
 ================
+CG_Draw3DModel
+
+================
+*/
+void CG_Draw3DModel( float x, float y, float w, float h, qhandle_t model, cgSkin_t *skin, vec3_t origin, vec3_t angles ) {
+	CG_Draw3DModelEx( x, y, w, h, model, skin, origin, angles, NULL, NULL );
+}
+
+/*
+================
 CG_DrawHead
 
 Used for both the status bar and the scoreboard
@@ -315,6 +325,8 @@
 	float			len;
 	vec3_t			origin;
 	vec3_t			mins, maxs;
+	entityState_t	*entityState;
+	byte			color[4];
 
 	ci = &cgs.clientinfo[ clientNum ];
 
@@ -338,7 +350,15 @@
 		// allow per-model tweaking
 		VectorAdd( origin, ci->headOffset, origin );
 
-		CG_Draw3DModel( x, y, w, h, ci->headModel, &ci->modelSkin, origin, headAngles );
+		// TODO: Use prediction entity state for local players?
+		entityState = &cg_entities[clientNum].currentState;
+
+		color[0] = ci->c1RGBA[0];
+		color[1] = ci->c1RGBA[1];
+		color[2] = ci->c1RGBA[2];
+		color[3] = entityState->skinFraction * 255;
+
+		CG_Draw3DModelEx( x, y, w, h, ci->headModel, &ci->modelSkin, origin, headAngles, color, entityState );
 	} else if ( cg_drawIcons.integer ) {
 		CG_DrawPic( x, y, w, h, ci->modelIcon );
 	}
@@ -2999,7 +3009,7 @@
 		}
 		ent.hModel = cgs.miscGameModels[i].model;
 
-		ent.customSkin = CG_AddSkinToFrame( &cgs.miscGameModels[i].skin );
+		ent.customSkin = CG_AddSkinToFrame( &cgs.miscGameModels[i].skin, NULL );
 		trap_R_AddRefEntityToScene( &ent );
 
 		drawn++;
Index: code/cgame/cg_ents.c
===================================================================
--- code/cgame/cg_ents.c	(revision 3386)
+++ code/cgame/cg_ents.c	(working copy)
@@ -968,11 +968,11 @@
 
 		if ( cent->currentState.modelindex == TEAM_RED ) {
 			model.hModel = cgs.media.harvesterModel;
-			model.customSkin = CG_AddSkinToFrame( &cgs.media.harvesterRedSkin );
+			model.customSkin = CG_AddSkinToFrame( &cgs.media.harvesterRedSkin, &cent->currentState );
 		}
 		else if ( cent->currentState.modelindex == TEAM_BLUE ) {
 			model.hModel = cgs.media.harvesterModel;
-			model.customSkin = CG_AddSkinToFrame( &cgs.media.harvesterBlueSkin );
+			model.customSkin = CG_AddSkinToFrame( &cgs.media.harvesterBlueSkin, &cent->currentState );
 		}
 		else {
 			model.hModel = cgs.media.harvesterNeutralModel;
Index: code/cgame/cg_local.h
===================================================================
--- code/cgame/cg_local.h	(revision 3386)
+++ code/cgame/cg_local.h	(working copy)
@@ -1285,7 +1285,7 @@
 void CG_Player( centity_t *cent );
 void CG_ResetPlayerEntity( centity_t *cent );
 void CG_AddRefEntityWithPowerups( refEntity_t *ent, entityState_t *state, int team );
-qhandle_t CG_AddSkinToFrame( const cgSkin_t *skin );
+qhandle_t CG_AddSkinToFrame( const cgSkin_t *skin, entityState_t *state );
 qboolean CG_RegisterSkin( const char *name, cgSkin_t *skin, qboolean append );
 void CG_NewClientInfo( int clientNum );
 sfxHandle_t	CG_CustomSound( int clientNum, const char *soundName );
Index: code/cgame/cg_players.c
===================================================================
--- code/cgame/cg_players.c	(revision 3386)
+++ code/cgame/cg_players.c	(working copy)
@@ -517,12 +517,30 @@
 CG_AddSkinToFrame
 ==========================
 */
-qhandle_t CG_AddSkinToFrame( const cgSkin_t *skin ) {
-	if ( !skin || !skin->numSurfaces ) {
+qhandle_t CG_AddSkinToFrame( const cgSkin_t *skin, entityState_t *state ) {
+	qhandle_t surfaces[MAX_CG_SKIN_SURFACES];
+	int i, index;
+	float skinFraction;
+
+	if ( !skin || !skin->numMeshes ) {
 		return 0;
 	}
 
-	return trap_R_AddSkinToFrame( skin->numSurfaces, skin->surfaces );
+	skinFraction = state ? state->skinFraction : 0.0f;
+
+	for ( i = 0; i < skin->numMeshes; i++ ) {
+		if ( skinFraction >= 1.0f ) {
+			index = skin->meshes[i].numShaders-1;
+		} else if ( skinFraction <= 0.0f ) {
+			index = 0;
+		} else { // > 0 && < 1
+			index = skinFraction * skin->meshes[i].numShaders;
+		}
+
+		surfaces[i] = skin->meshes[i].surfaces[index];
+	}
+
+	return trap_R_AddSkinToFrame( skin->numMeshes, surfaces );
 }
 
 /*
@@ -558,11 +576,11 @@
 	}
 
 	if ( !append ) {
-		skin->numSurfaces = 0;
+		skin->numMeshes = 0;
 	}
 
-	initialSurfaces = skin->numSurfaces;
-	totalSurfaces = skin->numSurfaces;
+	initialSurfaces = skin->numMeshes;
+	totalSurfaces = skin->numMeshes;
 
 	// load the file
 	len = trap_FS_FOpenFile( name, &f, FS_READ );
@@ -605,20 +623,35 @@
 			continue;
 		}
 
-		// parse the shader name
-		token = COM_ParseExt2( &text_p, qfalse, ',' );
-		Q_strncpyz( shaderName, token, sizeof( shaderName ) );
+		if ( skin->numMeshes < MAX_CG_SKIN_SURFACES ) {
+			int numShaders;
 
-		if ( skin->numSurfaces < MAX_CG_SKIN_SURFACES ) {
-			hShader = trap_R_RegisterShaderEx( shaderName, LIGHTMAP_NONE, qtrue );
+			for ( numShaders = 0; numShaders < MAX_CG_SKIN_SURFACE_SHADERS; numShaders++ ) {
+				if ( *text_p == ',' ) {
+					text_p++;
+				}
 
-			// for compatibility with quake3 skins, don't render missing shaders listed in skins
-			if ( !hShader ) {
-				hShader = cgs.media.nodrawShader;
+				// parse the shader name
+				token = COM_ParseExt2( &text_p, qfalse, ',' );
+				Q_strncpyz( shaderName, token, sizeof( shaderName ) );
+
+				if ( !token[0] ) {
+					// End of line
+					break;
+				}
+
+				hShader = trap_R_RegisterShaderEx( shaderName, LIGHTMAP_NONE, qtrue );
+
+				// for compatibility with quake3 skins, don't render missing shaders listed in skins
+				if ( !hShader ) {
+					hShader = cgs.media.nodrawShader;
+				}
+
+				skin->meshes[skin->numMeshes].surfaces[numShaders] = trap_R_AllocSkinSurface( surfName, hShader );
 			}
 
-			skin->surfaces[skin->numSurfaces] = trap_R_AllocSkinSurface( surfName, hShader );
-			skin->numSurfaces++;
+			skin->meshes[skin->numMeshes].numShaders = numShaders;
+			skin->numMeshes++;
 		}
 
 		totalSurfaces++;
@@ -630,7 +663,7 @@
 	}
 
 	// failed to load surfaces
-	if ( !skin->numSurfaces ) {
+	if ( !skin->numMeshes ) {
 		return qfalse;
 	}
 
@@ -1877,7 +1910,7 @@
 	// show the flag model
 	memset( &flag, 0, sizeof(flag) );
 	flag.hModel = cgs.media.flagFlapModel;
-	flag.customSkin = CG_AddSkinToFrame( skin );
+	flag.customSkin = CG_AddSkinToFrame( skin, &cent->currentState );
 	VectorCopy( torso->lightingOrigin, flag.lightingOrigin );
 	flag.shadowPlane = torso->shadowPlane;
 	flag.renderfx = torso->renderfx;
@@ -2524,7 +2557,7 @@
 	// add the legs
 	//
 	legs.hModel = ci->legsModel;
-	legs.customSkin = CG_AddSkinToFrame( &ci->modelSkin );
+	legs.customSkin = CG_AddSkinToFrame( &ci->modelSkin, &cent->currentState );
 
 	VectorCopy( cent->lerpOrigin, legs.origin );
 
@@ -2533,6 +2566,8 @@
 	legs.renderfx = renderfx;
 	VectorCopy (legs.origin, legs.oldorigin);	// don't positionally lerp at all
 
+	legs.shaderRGBA[3] = cent->currentState.skinFraction * 255;
+
 	CG_AddRefEntityWithPowerups( &legs, &cent->currentState, ci->team );
 
 	// if the model failed, allow the default nullmodel to be displayed
@@ -2557,8 +2592,12 @@
 	torso.shadowPlane = shadowPlane;
 	torso.renderfx = renderfx;
 
+	torso.shaderRGBA[3] = cent->currentState.skinFraction * 255;
+
 	CG_AddRefEntityWithPowerups( &torso, &cent->currentState, ci->team );
 
+	torso.shaderRGBA[3] = 255; // leave powerup entity alpha alone
+
 #ifdef MISSIONPACK
 	if ( cent->currentState.eFlags & EF_KAMIKAZE ) {
 
@@ -2783,6 +2822,8 @@
 	head.shadowPlane = shadowPlane;
 	head.renderfx = renderfx;
 
+	head.shaderRGBA[3] = cent->currentState.skinFraction * 255;
+
 	CG_AddRefEntityWithPowerups( &head, &cent->currentState, ci->team );
 
 	CG_AddBreathPuffs( cent, &head );
Index: code/game/bg_misc.c
===================================================================
--- code/game/bg_misc.c	(revision 3386)
+++ code/game/bg_misc.c	(working copy)
@@ -1467,6 +1467,14 @@
 	s->loopSound = ps->loopSound;
 	s->tokens = ps->tokens;
 	s->team = ps->persistant[PERS_TEAM];
+
+	if ( ps->stats[STAT_HEALTH] <= 0 ) {
+		s->skinFraction = 1.0f;
+	} else if ( ps->stats[STAT_HEALTH] >= ps->stats[STAT_MAX_HEALTH] ) {
+		s->skinFraction = 0.0f;
+	} else {
+		s->skinFraction = 1.0f - ( (float)ps->stats[STAT_HEALTH] / (float)ps->stats[STAT_MAX_HEALTH] );
+	}
 }
 
 /*
@@ -1548,6 +1556,14 @@
 	s->loopSound = ps->loopSound;
 	s->tokens = ps->tokens;
 	s->team = ps->persistant[PERS_TEAM];
+
+	if ( ps->stats[STAT_HEALTH] <= 0 ) {
+		s->skinFraction = 1.0f;
+	} else if ( ps->stats[STAT_HEALTH] >= ps->stats[STAT_MAX_HEALTH] ) {
+		s->skinFraction = 0.0f;
+	} else {
+		s->skinFraction = 1.0f - ( (float)ps->stats[STAT_HEALTH] / (float)ps->stats[STAT_MAX_HEALTH] );
+	}
 }
 
 
Index: code/game/bg_public.h
===================================================================
--- code/game/bg_public.h	(revision 3386)
+++ code/game/bg_public.h	(working copy)
@@ -546,10 +546,17 @@
 // flip the togglebit every time an animation
 // changes so a restart of the same anim can be detected
 #define	ANIM_TOGGLEBIT		128
-#define MAX_CG_SKIN_SURFACES 32
+// skin surfaces array shouldn't be dynamically allocated because players reuse the same skin structure when changing models
+#define MAX_CG_SKIN_SURFACES 100
+#define MAX_CG_SKIN_SURFACE_SHADERS 10
 typedef struct {
-	int numSurfaces;
-	qhandle_t surfaces[MAX_CG_SKIN_SURFACES];
+	qhandle_t surfaces[MAX_CG_SKIN_SURFACE_SHADERS]; // allocated skin surfaces (mesh name + shader)
+	int numShaders;
+} cgSkinMesh_t;
+
+typedef struct {
+	int numMeshes;
+	cgSkinMesh_t meshes[MAX_CG_SKIN_SURFACES];
 } cgSkin_t;
 
 #define DEFAULT_PLAYER_NAME		"UnnamedPlayer"
Index: code/q3_ui/ui_local.h
===================================================================
--- code/q3_ui/ui_local.h	(revision 3386)
+++ code/q3_ui/ui_local.h	(working copy)
@@ -584,7 +584,7 @@
 extern char			*UI_Cvar_VariableString( const char *var_name );
 extern void			UI_Refresh( int time );
 extern void			UI_StartDemoLoop( void );
-qhandle_t			UI_AddSkinToFrame( const cgSkin_t *skin );
+qhandle_t			UI_AddSkinToFrame( const cgSkin_t *skin, entityState_t *state );
 qboolean			UI_RegisterSkin( const char *name, cgSkin_t *skin, qboolean append );
 extern qboolean		m_entersound;
 extern uiStatic_t	uis;
Index: code/q3_ui/ui_players.c
===================================================================
--- code/q3_ui/ui_players.c	(revision 3386)
+++ code/q3_ui/ui_players.c	(working copy)
@@ -801,7 +801,7 @@
 	// add the legs
 	//
 	legs.hModel = pi->legsModel;
-	legs.customSkin = UI_AddSkinToFrame( &pi->modelSkin );
+	legs.customSkin = UI_AddSkinToFrame( &pi->modelSkin, NULL );
 
 	VectorCopy( origin, legs.origin );
 
@@ -943,12 +943,30 @@
 UI_AddSkinToFrame
 ==========================
 */
-qhandle_t UI_AddSkinToFrame( const cgSkin_t *skin ) {
-	if ( !skin || !skin->numSurfaces ) {
+qhandle_t UI_AddSkinToFrame( const cgSkin_t *skin, entityState_t *state ) {
+	qhandle_t surfaces[MAX_CG_SKIN_SURFACES];
+	int i, index;
+	float skinFraction;
+
+	if ( !skin || !skin->numMeshes ) {
 		return 0;
 	}
 
-	return trap_R_AddSkinToFrame( skin->numSurfaces, skin->surfaces );
+	skinFraction = state ? state->skinFraction : 0.0f;
+
+	for ( i = 0; i < skin->numMeshes; i++ ) {
+		if ( skinFraction >= 1.0f ) {
+			index = skin->meshes[i].numShaders-1;
+		} else if ( skinFraction <= 0.0f ) {
+			index = 0;
+		} else { // > 0 && < 1
+			index = skinFraction * skin->meshes[i].numShaders;
+		}
+
+		surfaces[i] = skin->meshes[i].surfaces[index];
+	}
+
+	return trap_R_AddSkinToFrame( skin->numMeshes, surfaces );
 }
 
 /*
@@ -984,11 +1002,11 @@
 	}
 
 	if ( !append ) {
-		skin->numSurfaces = 0;
+		skin->numMeshes = 0;
 	}
 
-	initialSurfaces = skin->numSurfaces;
-	totalSurfaces = skin->numSurfaces;
+	initialSurfaces = skin->numMeshes;
+	totalSurfaces = skin->numMeshes;
 
 	// load the file
 	len = trap_FS_FOpenFile( name, &f, FS_READ );
@@ -1031,15 +1049,29 @@
 			continue;
 		}
 
-		// parse the shader name
-		token = COM_ParseExt2( &text_p, qfalse, ',' );
-		Q_strncpyz( shaderName, token, sizeof( shaderName ) );
+		if ( skin->numMeshes < MAX_CG_SKIN_SURFACES ) {
+			int numShaders;
 
-		if ( skin->numSurfaces < MAX_CG_SKIN_SURFACES ) {
-			hShader = trap_R_RegisterShaderEx( shaderName, LIGHTMAP_NONE, qtrue );
+			for ( numShaders = 0; numShaders < MAX_CG_SKIN_SURFACE_SHADERS; numShaders++ ) {
+				if ( *text_p == ',' ) {
+					text_p++;
+				}
 
-			skin->surfaces[skin->numSurfaces] = trap_R_AllocSkinSurface( surfName, hShader );
-			skin->numSurfaces++;
+				// parse the shader name
+				token = COM_ParseExt2( &text_p, qfalse, ',' );
+				Q_strncpyz( shaderName, token, sizeof( shaderName ) );
+
+				if ( !token[0] ) {
+					// End of line
+					break;
+				}
+
+				hShader = trap_R_RegisterShaderEx( shaderName, LIGHTMAP_NONE, qtrue );
+				skin->meshes[skin->numMeshes].surfaces[numShaders] = trap_R_AllocSkinSurface( surfName, hShader );
+			}
+
+			skin->meshes[skin->numMeshes].numShaders = numShaders;
+			skin->numMeshes++;
 		}
 
 		totalSurfaces++;
@@ -1051,7 +1083,7 @@
 	}
 
 	// failed to load surfaces
-	if ( !skin->numSurfaces ) {
+	if ( !skin->numMeshes ) {
 		return qfalse;
 	}
 
Index: code/qcommon/msg.c
===================================================================
--- code/qcommon/msg.c	(revision 3386)
+++ code/qcommon/msg.c	(working copy)
@@ -765,6 +765,7 @@
 { NETF(origin[0]), 0 },
 { NETF(origin[1]), 0 },
 { NETF(origin[2]), 0 },
+{ NETF(skinFraction), 0 },
 { NETF(solid), 24 },
 { NETF(powerups), MAX_POWERUPS },
 { NETF(modelindex), MODELINDEX_BITS },
Index: code/qcommon/q_shared.h
===================================================================
--- code/qcommon/q_shared.h	(revision 3386)
+++ code/qcommon/q_shared.h	(working copy)
@@ -1329,6 +1329,7 @@
 	int		torsoAnim;		// mask off ANIM_TOGGLEBIT
 
 	int		tokens;			// harvester skulls
+	float	skinFraction;	// 0 = full health, 1 = dead
 } entityState_t;
 
 typedef enum {
Index: code/ui/ui_local.h
===================================================================
--- code/ui/ui_local.h	(revision 3386)
+++ code/ui/ui_local.h	(working copy)
@@ -490,7 +490,7 @@
 extern void			UI_Refresh( int time );
 extern void			UI_KeyEvent( int key );
 void UI_LoadBestScores(const char *map, int game);
-qhandle_t			UI_AddSkinToFrame( const cgSkin_t *skin );
+qhandle_t			UI_AddSkinToFrame( const cgSkin_t *skin, entityState_t *state );
 qboolean			UI_RegisterSkin( const char *name, cgSkin_t *skin, qboolean append );
 
 //
Index: code/ui/ui_players.c
===================================================================
--- code/ui/ui_players.c	(revision 3386)
+++ code/ui/ui_players.c	(working copy)
@@ -804,7 +804,7 @@
 	// add the legs
 	//
 	legs.hModel = pi->legsModel;
-	legs.customSkin = UI_AddSkinToFrame( &pi->modelSkin );
+	legs.customSkin = UI_AddSkinToFrame( &pi->modelSkin, NULL );
 
 	VectorCopy( origin, legs.origin );
 
@@ -1001,12 +1001,30 @@
 UI_AddSkinToFrame
 ==========================
 */
-qhandle_t UI_AddSkinToFrame( const cgSkin_t *skin ) {
-	if ( !skin || !skin->numSurfaces ) {
+qhandle_t UI_AddSkinToFrame( const cgSkin_t *skin, entityState_t *state ) {
+	qhandle_t surfaces[MAX_CG_SKIN_SURFACES];
+	int i, index;
+	float skinFraction;
+
+	if ( !skin || !skin->numMeshes ) {
 		return 0;
 	}
 
-	return trap_R_AddSkinToFrame( skin->numSurfaces, skin->surfaces );
+	skinFraction = state ? state->skinFraction : 0.0f;
+
+	for ( i = 0; i < skin->numMeshes; i++ ) {
+		if ( skinFraction >= 1.0f ) {
+			index = skin->meshes[i].numShaders-1;
+		} else if ( skinFraction <= 0.0f ) {
+			index = 0;
+		} else { // > 0 && < 1
+			index = skinFraction * skin->meshes[i].numShaders;
+		}
+
+		surfaces[i] = skin->meshes[i].surfaces[index];
+	}
+
+	return trap_R_AddSkinToFrame( skin->numMeshes, surfaces );
 }
 
 /*
@@ -1042,11 +1060,11 @@
 	}
 
 	if ( !append ) {
-		skin->numSurfaces = 0;
+		skin->numMeshes = 0;
 	}
 
-	initialSurfaces = skin->numSurfaces;
-	totalSurfaces = skin->numSurfaces;
+	initialSurfaces = skin->numMeshes;
+	totalSurfaces = skin->numMeshes;
 
 	// load the file
 	len = trap_FS_FOpenFile( name, &f, FS_READ );
@@ -1089,15 +1107,29 @@
 			continue;
 		}
 
-		// parse the shader name
-		token = COM_ParseExt2( &text_p, qfalse, ',' );
-		Q_strncpyz( shaderName, token, sizeof( shaderName ) );
+		if ( skin->numMeshes < MAX_CG_SKIN_SURFACES ) {
+			int numShaders;
 
-		if ( skin->numSurfaces < MAX_CG_SKIN_SURFACES ) {
-			hShader = trap_R_RegisterShaderEx( shaderName, LIGHTMAP_NONE, qtrue );
+			for ( numShaders = 0; numShaders < MAX_CG_SKIN_SURFACE_SHADERS; numShaders++ ) {
+				if ( *text_p == ',' ) {
+					text_p++;
+				}
 
-			skin->surfaces[skin->numSurfaces] = trap_R_AllocSkinSurface( surfName, hShader );
-			skin->numSurfaces++;
+				// parse the shader name
+				token = COM_ParseExt2( &text_p, qfalse, ',' );
+				Q_strncpyz( shaderName, token, sizeof( shaderName ) );
+
+				if ( !token[0] ) {
+					// End of line
+					break;
+				}
+
+				hShader = trap_R_RegisterShaderEx( shaderName, LIGHTMAP_NONE, qtrue );
+				skin->meshes[skin->numMeshes].surfaces[numShaders] = trap_R_AllocSkinSurface( surfName, hShader );
+			}
+
+			skin->meshes[skin->numMeshes].numShaders = numShaders;
+			skin->numMeshes++;
 		}
 
 		totalSurfaces++;
@@ -1109,7 +1141,7 @@
 	}
 
 	// failed to load surfaces
-	if ( !skin->numSurfaces ) {
+	if ( !skin->numMeshes ) {
 		return qfalse;
 	}
 
