Index: code/cgame/cg_draw.c
===================================================================
--- code/cgame/cg_draw.c	(revision 3386)
+++ code/cgame/cg_draw.c	(working copy)
@@ -325,7 +325,7 @@
 		}
 
 		// offset the origin y and z to center the head
-		trap_R_ModelBounds( cm, mins, maxs );
+		trap_R_ModelBounds( cm, mins, maxs, 0, 0, 0 );
 
 		origin[2] = -0.5 * ( mins[2] + maxs[2] );
 		origin[1] = 0.5 * ( mins[1] + maxs[1] );
@@ -370,7 +370,7 @@
 		cm = cgs.media.redFlagModel;
 
 		// offset the origin y and z to center the flag
-		trap_R_ModelBounds( cm, mins, maxs );
+		trap_R_ModelBounds( cm, mins, maxs, 0, 0, 0 );
 
 		origin[2] = -0.5 * ( mins[2] + maxs[2] );
 		origin[1] = 0.5 * ( mins[1] + maxs[1] );
Index: code/cgame/cg_ents.c
===================================================================
--- code/cgame/cg_ents.c	(revision 3386)
+++ code/cgame/cg_ents.c	(working copy)
@@ -33,14 +33,17 @@
 tag location
 ======================
 */
-void CG_PositionEntityOnTag( refEntity_t *entity, const refEntity_t *parent, 
+qboolean CG_PositionEntityOnTag( refEntity_t *entity, const refEntity_t *parent,
 							qhandle_t parentModel, char *tagName ) {
 	int				i;
 	orientation_t	lerped;
+	qboolean		returnValue;
 	
 	// lerp the tag
-	trap_R_LerpTag( &lerped, parentModel, parent->oldframe, parent->frame,
-		1.0 - parent->backlerp, tagName );
+	returnValue = trap_R_LerpTagFrameModel( &lerped, parentModel,
+		parent->oldframeModel, parent->oldframe,
+		parent->frameModel, parent->frame,
+		1.0 - parent->backlerp, tagName, NULL );
 
 	// FIXME: allow origin offsets along tag?
 	VectorCopy( parent->origin, entity->origin );
@@ -51,6 +54,8 @@
 	// had to cast away the const to avoid compiler problems...
 	MatrixMultiply( lerped.axis, ((refEntity_t *)parent)->axis, entity->axis );
 	entity->backlerp = parent->backlerp;
+
+	return returnValue;
 }
 
 
@@ -62,16 +67,19 @@
 tag location
 ======================
 */
-void CG_PositionRotatedEntityOnTag( refEntity_t *entity, const refEntity_t *parent, 
+qboolean CG_PositionRotatedEntityOnTag( refEntity_t *entity, const refEntity_t *parent,
 							qhandle_t parentModel, char *tagName ) {
 	int				i;
 	orientation_t	lerped;
 	vec3_t			tempAxis[3];
+	qboolean		returnValue;
 
 //AxisClear( entity->axis );
 	// lerp the tag
-	trap_R_LerpTag( &lerped, parentModel, parent->oldframe, parent->frame,
-		1.0 - parent->backlerp, tagName );
+	returnValue = trap_R_LerpTagFrameModel( &lerped, parentModel,
+		parent->oldframeModel, parent->oldframe,
+		parent->frameModel, parent->frame,
+		1.0 - parent->backlerp, tagName, NULL );
 
 	// FIXME: allow origin offsets along tag?
 	VectorCopy( parent->origin, entity->origin );
@@ -82,6 +90,8 @@
 	// had to cast away the const to avoid compiler problems...
 	MatrixMultiply( entity->axis, lerped.axis, tempAxis );
 	MatrixMultiply( tempAxis, ((refEntity_t *)parent)->axis, entity->axis );
+
+	return returnValue;
 }
 
 
Index: code/cgame/cg_local.h
===================================================================
--- code/cgame/cg_local.h	(revision 3386)
+++ code/cgame/cg_local.h	(working copy)
@@ -1320,9 +1320,9 @@
 void CG_Beam( centity_t *cent );
 void CG_AdjustPositionForMover(const vec3_t in, int moverNum, int fromTime, int toTime, vec3_t out, vec3_t angles_in, vec3_t angles_out);
 
-void CG_PositionEntityOnTag( refEntity_t *entity, const refEntity_t *parent, 
+qboolean CG_PositionEntityOnTag( refEntity_t *entity, const refEntity_t *parent,
 							qhandle_t parentModel, char *tagName );
-void CG_PositionRotatedEntityOnTag( refEntity_t *entity, const refEntity_t *parent, 
+qboolean CG_PositionRotatedEntityOnTag( refEntity_t *entity, const refEntity_t *parent,
 							qhandle_t parentModel, char *tagName );
 
 
@@ -1566,9 +1566,22 @@
 void		trap_R_SetClipRegion( const float *region );
 void		trap_R_DrawStretchPic( float x, float y, float w, float h, 
 			float s1, float t1, float s2, float t2, qhandle_t hShader );
-void		trap_R_ModelBounds( clipHandle_t model, vec3_t mins, vec3_t maxs );
-int			trap_R_LerpTag( orientation_t *tag, clipHandle_t mod, int startFrame, int endFrame, 
+int trap_R_ModelBounds( clipHandle_t handle, vec3_t mins, vec3_t maxs, int startFrame, int endFrame, float frac );
+int trap_R_LerpTag( orientation_t *tag, clipHandle_t handle, int startFrame, int endFrame,
 					   float frac, const char *tagName );
+int			trap_R_LerpTagFrameModel( orientation_t *tag, clipHandle_t mod,
+					   clipHandle_t frameModel, int startFrame,
+					   clipHandle_t endFrameModel, int endFrame,
+					   float frac, const char *tagName,
+					   int *tagIndex );
+int			trap_R_LerpTagTorso( orientation_t *tag, clipHandle_t mod,
+					   clipHandle_t frameModel, int startFrame,
+					   clipHandle_t endFrameModel, int endFrame,
+					   float frac, const char *tagName,
+					   int *tagIndex, const vec3_t *torsoAxis,
+					   qhandle_t torsoFrameModel, int torsoFrame,
+					   qhandle_t oldTorsoFrameModel, int oldTorsoFrame,
+					   float torsoFrac );
 
 // skin (entity model surface remap) management
 qhandle_t	trap_R_AllocSkinSurface( const char *surface, qhandle_t hShader );
Index: code/cgame/cg_main.c
===================================================================
--- code/cgame/cg_main.c	(revision 3386)
+++ code/cgame/cg_main.c	(working copy)
@@ -1042,7 +1042,7 @@
 
 		Com_sprintf( name, sizeof(name), "*%i", i );
 		cgs.inlineDrawModel[i] = trap_R_RegisterModel( name );
-		trap_R_ModelBounds( cgs.inlineDrawModel[i], mins, maxs );
+		trap_R_ModelBounds( cgs.inlineDrawModel[i], mins, maxs, 0, 0, 0 );
 		for ( j = 0 ; j < 3 ; j++ ) {
 			cgs.inlineModelMidpoints[i][j] = mins[j] + 0.5 * ( maxs[j] - mins[j] );
 		}
Index: code/cgame/cg_newdraw.c
===================================================================
--- code/cgame/cg_newdraw.c	(revision 3386)
+++ code/cgame/cg_newdraw.c	(working copy)
@@ -526,7 +526,7 @@
 	  	}
 
   		// offset the origin y and z to center the head
-  		trap_R_ModelBounds( cm, mins, maxs );
+		trap_R_ModelBounds( cm, mins, maxs, 0, 0, 0 );
 
 	  	origin[2] = -0.5 * ( mins[2] + maxs[2] );
   		origin[1] = 0.5 * ( mins[1] + maxs[1] );
Index: code/cgame/cg_public.h
===================================================================
--- code/cgame/cg_public.h	(revision 3386)
+++ code/cgame/cg_public.h	(working copy)
@@ -122,6 +122,8 @@
 	CG_R_DRAWSTRETCHPIC,
 	CG_R_MODELBOUNDS,
 	CG_R_LERPTAG,
+	CG_R_LERPTAG_FRAMEMODEL,
+	CG_R_LERPTAG_TORSO,
 	CG_GETGLCONFIG,
 	CG_GETGAMESTATE,
 	CG_GETCURRENTSNAPSHOTNUMBER,
Index: code/cgame/cg_syscalls.asm
===================================================================
--- code/cgame/cg_syscalls.asm	(revision 3386)
+++ code/cgame/cg_syscalls.asm	(working copy)
@@ -48,52 +48,54 @@
 equ	trap_R_RenderScene					-46
 equ	trap_R_SetColor						-47
 equ	trap_R_DrawStretchPic				-48
-equ	trap_R_ModelBounds					-49
-equ	trap_R_LerpTag						-50
-equ	trap_GetGlconfig					-51
-equ	trap_GetGameState					-52
-equ	trap_GetCurrentSnapshotNumber		-53
-equ	trap_GetSnapshot					-54
-equ	trap_GetServerCommand				-55
-equ	trap_GetCurrentCmdNumber			-56
-equ	trap_GetUserCmd						-57
-equ	trap_SetUserCmdValue				-58
-equ	trap_R_RegisterShaderNoMip			-59
-equ	trap_MemoryRemaining				-60
-equ trap_R_RegisterFont					-61
-equ trap_Key_IsDown						-62
-equ trap_Key_GetCatcher					-63
-equ trap_Key_SetCatcher					-64
-equ trap_Key_GetKey						-65
-equ trap_PC_AddGlobalDefine				-66
-equ	trap_PC_LoadSource					-67
-equ trap_PC_FreeSource					-68
-equ trap_PC_ReadToken					-69
-equ trap_PC_SourceFileAndLine			-70
-equ trap_S_StopBackgroundTrack			-71
-equ trap_RealTime						-72
-equ trap_SnapVector						-73
-equ trap_RemoveCommand					-74
-equ trap_R_LightForPoint				-75
-equ trap_CIN_PlayCinematic				-76
-equ trap_CIN_StopCinematic				-77
-equ trap_CIN_RunCinematic 				-78
-equ trap_CIN_DrawCinematic				-79
-equ trap_CIN_SetExtents					-80
-equ trap_R_RemapShader					-81
-equ trap_R_SetClipRegion				-82
-equ trap_R_AllocSkinSurface				-83
-equ trap_R_AddSkinToFrame				-84
-equ	trap_S_AddRealLoopingSound			-85
-equ trap_S_StopLoopingSound				-86
-equ trap_CM_TempCapsuleModel			-87
-equ trap_CM_CapsuleTrace				-88
-equ trap_CM_TransformedCapsuleTrace		-89
-equ trap_R_AddAdditiveLightToScene		-90
-equ trap_GetEntityToken					-91
-equ	trap_R_AddPolysToScene				-92
-equ trap_R_inPVS						-93
-equ trap_FS_Seek			-94
+equ trap_R_ModelBounds					-49
+equ trap_R_LerpTag						-50
+equ trap_R_LerpTagFrameModel			-51
+equ trap_R_LerpTagTorso					-52
+equ	trap_GetGlconfig					-53
+equ	trap_GetGameState					-54
+equ	trap_GetCurrentSnapshotNumber		-55
+equ	trap_GetSnapshot					-56
+equ	trap_GetServerCommand				-57
+equ	trap_GetCurrentCmdNumber			-58
+equ	trap_GetUserCmd						-59
+equ	trap_SetUserCmdValue				-60
+equ	trap_R_RegisterShaderNoMip			-61
+equ	trap_MemoryRemaining				-62
+equ trap_R_RegisterFont					-63
+equ trap_Key_IsDown						-64
+equ trap_Key_GetCatcher					-65
+equ trap_Key_SetCatcher					-66
+equ trap_Key_GetKey						-67
+equ trap_PC_AddGlobalDefine				-68
+equ	trap_PC_LoadSource					-69
+equ trap_PC_FreeSource					-70
+equ trap_PC_ReadToken					-71
+equ trap_PC_SourceFileAndLine			-72
+equ trap_S_StopBackgroundTrack			-73
+equ trap_RealTime						-74
+equ trap_SnapVector						-75
+equ trap_RemoveCommand					-76
+equ trap_R_LightForPoint				-77
+equ trap_CIN_PlayCinematic				-78
+equ trap_CIN_StopCinematic				-79
+equ trap_CIN_RunCinematic 				-80
+equ trap_CIN_DrawCinematic				-81
+equ trap_CIN_SetExtents					-82
+equ trap_R_RemapShader					-83
+equ trap_R_SetClipRegion				-84
+equ trap_R_AllocSkinSurface				-85
+equ trap_R_AddSkinToFrame				-86
+equ	trap_S_AddRealLoopingSound			-87
+equ trap_S_StopLoopingSound				-88
+equ trap_CM_TempCapsuleModel			-89
+equ trap_CM_CapsuleTrace				-90
+equ trap_CM_TransformedCapsuleTrace		-91
+equ trap_R_AddAdditiveLightToScene		-92
+equ trap_GetEntityToken					-93
+equ	trap_R_AddPolysToScene				-94
+equ trap_R_inPVS						-95
+equ trap_FS_Seek			-96
 
 equ	memset						-101
 equ	memcpy						-102
Index: code/cgame/cg_syscalls.c
===================================================================
--- code/cgame/cg_syscalls.c	(revision 3386)
+++ code/cgame/cg_syscalls.c	(working copy)
@@ -295,8 +295,8 @@
 	syscall( CG_R_DRAWSTRETCHPIC, PASSFLOAT(x), PASSFLOAT(y), PASSFLOAT(w), PASSFLOAT(h), PASSFLOAT(s1), PASSFLOAT(t1), PASSFLOAT(s2), PASSFLOAT(t2), hShader );
 }
 
-void	trap_R_ModelBounds( clipHandle_t model, vec3_t mins, vec3_t maxs ) {
-	syscall( CG_R_MODELBOUNDS, model, mins, maxs );
+int		trap_R_ModelBounds( clipHandle_t model, vec3_t mins, vec3_t maxs, int startFrame, int endFrame, float frac ) {
+	return syscall( CG_R_MODELBOUNDS, model, mins, maxs, startFrame, endFrame, PASSFLOAT(frac) );
 }
 
 int		trap_R_LerpTag( orientation_t *tag, clipHandle_t mod, int startFrame, int endFrame, 
@@ -304,6 +304,28 @@
 	return syscall( CG_R_LERPTAG, tag, mod, startFrame, endFrame, PASSFLOAT(frac), tagName );
 }
 
+int		trap_R_LerpTagFrameModel( orientation_t *tag, clipHandle_t mod,
+					   clipHandle_t frameModel, int startFrame,
+					   clipHandle_t endFrameModel, int endFrame,
+					   float frac, const char *tagName,
+					   int *tagIndex )
+{
+	return syscall( CG_R_LERPTAG_FRAMEMODEL, tag, mod, frameModel, startFrame, endFrameModel, endFrame, PASSFLOAT(frac), tagName, tagIndex );
+}
+
+int		trap_R_LerpTagTorso( orientation_t *tag, clipHandle_t mod,
+					   clipHandle_t frameModel, int startFrame,
+					   clipHandle_t endFrameModel, int endFrame,
+					   float frac, const char *tagName,
+					   int *tagIndex, const vec3_t *torsoAxis,
+					   qhandle_t torsoFrameModel, int torsoFrame,
+					   qhandle_t oldTorsoFrameModel, int oldTorsoFrame,
+					   float torsoFrac )
+{
+	return syscall( CG_R_LERPTAG_TORSO, tag, mod, frameModel, startFrame, endFrameModel, endFrame, PASSFLOAT(frac), tagName, tagIndex,
+										torsoAxis, torsoFrameModel, torsoFrame, oldTorsoFrameModel, oldTorsoFrame, PASSFLOAT(torsoFrac) );
+}
+
 void	trap_R_RemapShader( const char *oldShader, const char *newShader, const char *timeOffset ) {
 	syscall( CG_R_REMAP_SHADER, oldShader, newShader, timeOffset );
 }
Index: code/cgame/cg_weapons.c
===================================================================
--- code/cgame/cg_weapons.c	(revision 3386)
+++ code/cgame/cg_weapons.c	(working copy)
@@ -638,7 +638,7 @@
 	weaponInfo->weaponModel = trap_R_RegisterModel( item->world_model[0] );
 
 	// calc midpoint for rotation
-	trap_R_ModelBounds( weaponInfo->weaponModel, mins, maxs );
+	trap_R_ModelBounds( weaponInfo->weaponModel, mins, maxs, 0, 0, 0 );
 	for ( i = 0 ; i < 3 ; i++ ) {
 		weaponInfo->weaponMidpoint[i] = mins[i] + 0.5 * ( maxs[i] - mins[i] );
 	}
Index: code/client/cl_cgame.c
===================================================================
--- code/client/cl_cgame.c	(revision 3386)
+++ code/client/cl_cgame.c	(working copy)
@@ -575,10 +575,13 @@
 		re.DrawStretchPic( VMF(1), VMF(2), VMF(3), VMF(4), VMF(5), VMF(6), VMF(7), VMF(8), args[9] );
 		return 0;
 	case CG_R_MODELBOUNDS:
-		re.ModelBounds( args[1], VMA(2), VMA(3) );
-		return 0;
+		return re.ModelBounds( args[1], VMA(2), VMA(3), args[4], args[5], VMF(6) );
 	case CG_R_LERPTAG:
-		return re.LerpTag( VMA(1), args[2], args[3], args[4], VMF(5), VMA(6) );
+		return re.LerpTag( VMA(1), args[2], 0, args[3], 0, args[4], VMF(5), VMA(6), NULL, NULL, 0, 0, 0, 0, 0 );
+	case CG_R_LERPTAG_FRAMEMODEL:
+		return re.LerpTag( VMA(1), args[2], args[3], args[4], args[5], args[6], VMF(7), VMA(8), VMA(9), NULL, 0, 0, 0, 0, 0 );
+	case CG_R_LERPTAG_TORSO:
+		return re.LerpTag( VMA(1), args[2], args[3], args[4], args[5], args[6], VMF(7), VMA(8), VMA(9), VMA(10), args[11], args[12], args[13], args[14], VMF(15) );
 	case CG_GETGLCONFIG:
 		CL_GetGlconfig( VMA(1) );
 		return 0;
Index: code/client/cl_ui.c
===================================================================
--- code/client/cl_ui.c	(revision 3386)
+++ code/client/cl_ui.c	(working copy)
@@ -798,17 +798,21 @@
 		return 0;
 
   case UI_R_MODELBOUNDS:
-		re.ModelBounds( args[1], VMA(2), VMA(3) );
-		return 0;
+		return re.ModelBounds( args[1], VMA(2), VMA(3), args[4], args[5], VMF(6) );
 
 	case UI_UPDATESCREEN:
 		SCR_UpdateScreen();
 		return 0;
 
-	case UI_CM_LERPTAG:
-		re.LerpTag( VMA(1), args[2], args[3], args[4], VMF(5), VMA(6) );
-		return 0;
+	case UI_R_LERPTAG:
+		return re.LerpTag( VMA(1), args[2], 0, args[3], 0, args[4], VMF(5), VMA(6), NULL, NULL, 0, 0, 0, 0, 0 );
 
+	case UI_R_LERPTAG_FRAMEMODEL:
+		return re.LerpTag( VMA(1), args[2], args[3], args[4], args[5], args[6], VMF(7), VMA(8), VMA(9), NULL, 0, 0, 0, 0, 0 );
+
+	case UI_R_LERPTAG_TORSO:
+		return re.LerpTag( VMA(1), args[2], args[3], args[4], args[5], args[6], VMF(7), VMA(8), VMA(9), VMA(10), args[11], args[12], args[13], args[14], VMF(15) );
+
 	case UI_S_REGISTERSOUND:
 		return S_RegisterSound( VMA(1), args[2] );
 
Index: code/q3_ui/ui_local.h
===================================================================
--- code/q3_ui/ui_local.h	(revision 3386)
+++ code/q3_ui/ui_local.h	(working copy)
@@ -649,7 +649,22 @@
 void			trap_R_SetColor( const float *rgba );
 void			trap_R_DrawStretchPic( float x, float y, float w, float h, float s1, float t1, float s2, float t2, qhandle_t hShader );
 void			trap_UpdateScreen( void );
-int				trap_CM_LerpTag( orientation_t *tag, clipHandle_t mod, int startFrame, int endFrame, float frac, const char *tagName );
+int trap_R_ModelBounds( clipHandle_t handle, vec3_t mins, vec3_t maxs, int startFrame, int endFrame, float frac );
+int trap_R_LerpTag( orientation_t *tag, clipHandle_t handle, int startFrame, int endFrame,
+					   float frac, const char *tagName );
+int			trap_R_LerpTagFrameModel( orientation_t *tag, clipHandle_t mod,
+					   clipHandle_t frameModel, int startFrame,
+					   clipHandle_t endFrameModel, int endFrame,
+					   float frac, const char *tagName,
+					   int *tagIndex );
+int			trap_R_LerpTagTorso( orientation_t *tag, clipHandle_t mod,
+					   clipHandle_t frameModel, int startFrame,
+					   clipHandle_t endFrameModel, int endFrame,
+					   float frac, const char *tagName,
+					   int *tagIndex, const vec3_t *torsoAxis,
+					   qhandle_t torsoFrameModel, int torsoFrame,
+					   qhandle_t oldTorsoFrameModel, int oldTorsoFrame,
+					   float torsoFrac );
 // skin (entity model surface remap) management
 qhandle_t		trap_R_AllocSkinSurface( const char *surface, qhandle_t hShader );
 qhandle_t		trap_R_AddSkinToFrame( int numSurfaces, const qhandle_t *surfaces );
Index: code/q3_ui/ui_players.c
===================================================================
--- code/q3_ui/ui_players.c	(revision 3386)
+++ code/q3_ui/ui_players.c	(working copy)
@@ -300,14 +300,17 @@
 UI_PositionEntityOnTag
 ======================
 */
-static void UI_PositionEntityOnTag( refEntity_t *entity, const refEntity_t *parent, 
+static qboolean UI_PositionEntityOnTag( refEntity_t *entity, const refEntity_t *parent,
 							clipHandle_t parentModel, char *tagName ) {
 	int				i;
 	orientation_t	lerped;
+	qboolean		returnValue;
 	
 	// lerp the tag
-	trap_CM_LerpTag( &lerped, parentModel, parent->oldframe, parent->frame,
-		1.0 - parent->backlerp, tagName );
+	returnValue = trap_R_LerpTagFrameModel( &lerped, parentModel,
+		parent->oldframeModel, parent->oldframe,
+		parent->frameModel, parent->frame,
+		1.0 - parent->backlerp, tagName, NULL );
 
 	// FIXME: allow origin offsets along tag?
 	VectorCopy( parent->origin, entity->origin );
@@ -318,6 +321,8 @@
 	// cast away const because of compiler problems
 	MatrixMultiply( lerped.axis, ((refEntity_t*)parent)->axis, entity->axis );
 	entity->backlerp = parent->backlerp;
+
+	return returnValue;
 }
 
 
@@ -326,15 +331,18 @@
 UI_PositionRotatedEntityOnTag
 ======================
 */
-static void UI_PositionRotatedEntityOnTag( refEntity_t *entity, const refEntity_t *parent, 
+static qboolean UI_PositionRotatedEntityOnTag( refEntity_t *entity, const refEntity_t *parent,
 							clipHandle_t parentModel, char *tagName ) {
 	int				i;
 	orientation_t	lerped;
 	vec3_t			tempAxis[3];
+	qboolean		returnValue;
 
 	// lerp the tag
-	trap_CM_LerpTag( &lerped, parentModel, parent->oldframe, parent->frame,
-		1.0 - parent->backlerp, tagName );
+	returnValue = trap_R_LerpTagFrameModel( &lerped, parentModel,
+		parent->oldframeModel, parent->oldframe,
+		parent->frameModel, parent->frame,
+		1.0 - parent->backlerp, tagName, NULL );
 
 	// FIXME: allow origin offsets along tag?
 	VectorCopy( parent->origin, entity->origin );
@@ -345,9 +353,12 @@
 	// cast away const because of compiler problems
 	MatrixMultiply( entity->axis, lerped.axis, tempAxis );
 	MatrixMultiply( tempAxis, ((refEntity_t *)parent)->axis, entity->axis );
+
+	return returnValue;
 }
 
 
+
 /*
 ===============
 UI_SetLerpFrameAnimation
===================================================================
--- code/qcommon/vm_local.h	(revision 3428)
+++ code/qcommon/vm_local.h	(working copy)
@@ -27,8 +27,8 @@
 #define MAX_VMMAIN_ARGS 13
 
 // Max number of arguments to pass from a vm to engine's syscall handler function for the vm.
-// syscall number + 15 arguments
-#define MAX_VMSYSCALL_ARGS 16
+// qvm syscall number + vm syscall number + 15 args
+#define MAX_VMSYSCALL_ARGS 17
 
 // don't change, this is hardcoded into x86 VMs, opStack protection relies
 // on this
Index: code/renderercommon/tr_public.h
===================================================================
--- code/renderercommon/tr_public.h	(revision 3386)
+++ code/renderercommon/tr_public.h	(working copy)
@@ -89,9 +89,10 @@
 	int		(*MarkFragments)( int numPoints, const vec3_t *points, const vec3_t projection,
 				   int maxPoints, vec3_t pointBuffer, int maxFragments, markFragment_t *fragmentBuffer );
 
-	int		(*LerpTag)( orientation_t *tag,  qhandle_t model, int startFrame, int endFrame, 
-					 float frac, const char *tagName );
-	void	(*ModelBounds)( qhandle_t model, vec3_t mins, vec3_t maxs );
+	int		(*LerpTag)( orientation_t *tag,  qhandle_t model, qhandle_t frameModel, int startFrame, qhandle_t endFrameModel, int endFrame,
+					 float frac, const char *tagName, int *tagIndex, const vec3_t *torsoAxis, qhandle_t torsoFrameModel, int torsoFrame,
+					 qhandle_t oldTorsoFrameModel, int oldTorsoFrame, float torsoFrac );
+	int		(*ModelBounds)( qhandle_t model, vec3_t mins, vec3_t maxs, int startFrame, int endFrame, float frac );
 
 #ifdef __USEA3D
 	void    (*A3D_RenderGeometry) (void *pVoidA3D, void *pVoidGeom, void *pVoidMat, void *pVoidGeomStatus);
Index: code/renderercommon/tr_types.h
===================================================================
--- code/renderercommon/tr_types.h	(revision 3386)
+++ code/renderercommon/tr_types.h	(working copy)
@@ -105,10 +105,12 @@
 	qboolean	nonNormalizedAxes;	// axis are not normalized, i.e. they have scale
 	float		origin[3];			// also used as MODEL_BEAM's "from"
 	int			frame;				// also used as MODEL_BEAM's diameter
+	qhandle_t	frameModel;			// use skeleton from another model
 
 	// previous data for frame interpolation
 	float		oldorigin[3];		// also used as MODEL_BEAM's "to"
 	int			oldframe;
+	qhandle_t	oldframeModel;		// old skeleton model
 	float		backlerp;			// 0.0 = current, 1.0 = old
 
 	// texturing
Index: code/renderergl1/tr_local.h
===================================================================
--- code/renderergl1/tr_local.h	(revision 3386)
+++ code/renderergl1/tr_local.h	(working copy)
@@ -775,9 +775,16 @@
 
 void		R_ModelInit (void);
 model_t		*R_GetModelByHandle( qhandle_t hModel );
-int			R_LerpTag( orientation_t *tag, qhandle_t handle, int startFrame, int endFrame, 
-					 float frac, const char *tagName );
-void		R_ModelBounds( qhandle_t handle, vec3_t mins, vec3_t maxs );
+int			R_LerpTag( orientation_t *tag, qhandle_t handle,
+					 qhandle_t frameModel, int startFrame,
+					 qhandle_t endFrameModel, int endFrame,
+					 float frac, const char *tagName,
+					 int *pTagIndex,
+					 const vec3_t *torsoAxis, // vec3_t[3]
+					 qhandle_t torsoFrameModel, int torsoStartFrame,
+					 qhandle_t torsoEndFrameModel, int torsoEndFrame,
+					 float torsoFrac );
+int			R_ModelBounds( qhandle_t handle, vec3_t mins, vec3_t maxs, int startFrame, int endFrame, float frac );
 shader_t	*R_CustomSurfaceShader( const char *surfaceName, qhandle_t customShader, qhandle_t customSkin );
 
 void		R_Modellist_f (void);
@@ -1422,7 +1429,9 @@
 void R_AddIQMSurfaces( trRefEntity_t *ent );
 void RB_IQMSurfaceAnim( surfaceType_t *surface );
 int R_IQMLerpTag( orientation_t *tag, iqmData_t *data,
-                  int startFrame, int endFrame,
+                  int startTagIndex,
+                  qhandle_t frameMode, int startFrame,
+                  qhandle_t endFrameModel, int endFrame,
                   float frac, const char *tagName );
 
 /*
Index: code/renderergl1/tr_model.c
===================================================================
--- code/renderergl1/tr_model.c	(revision 3386)
+++ code/renderergl1/tr_model.c	(working copy)
@@ -1011,56 +1011,88 @@
 /*
 ================
 R_LerpTag
+
+"tag" can be NULL if just checking if tag exists.
+
+"pTagIndex" if not NULL specifies that starting tag index to loop for tagName.
+"pTagIndex" will be set to the tag index of the lerped tag or -1 if not found.
+
+returns 1 if tag was found or 0 if not found
 ================
 */
-int R_LerpTag( orientation_t *tag, qhandle_t handle, int startFrame, int endFrame, 
-					 float frac, const char *tagName ) {
-	md3Tag_t	*start, *end;
-	md3Tag_t	start_space, end_space;
+int R_LerpTag( orientation_t *tag, qhandle_t handle,
+					 qhandle_t frameModel, int startFrame,
+					 qhandle_t endFrameModel, int endFrame,
+					 float frac, const char *tagName,
+					 int *pTagIndex,
+					 const vec3_t *torsoAxis, // vec3_t[3]
+					 qhandle_t torsoFrameModel, int torsoStartFrame,
+					 qhandle_t torsoEndFrameModel, int torsoEndFrame,
+					 float torsoFrac )
+{
+	orientation_t	start, end;
+	qboolean		lerpTag;
 	int		i;
 	float		frontLerp, backLerp;
 	model_t		*model;
+	int			startTagIndex;
+	int			tagIndex;
 
+	if ( pTagIndex ) {
+		startTagIndex = *pTagIndex;
+
+		// specified invalid starting tag, return tag not found
+		if ( startTagIndex < 0 ) {
+			handle = 0;
+		}
+	} else {
+		startTagIndex = 0;
+	}
+
 	model = R_GetModelByHandle( handle );
-	if ( !model->md3[0] )
+
+	if ( model->type == MOD_IQM )
 	{
-		if(model->type == MOD_MDR)
-		{
-			start = R_GetAnimTag((mdrHeader_t *) model->modelData, startFrame, tagName, &start_space);
-			end = R_GetAnimTag((mdrHeader_t *) model->modelData, endFrame, tagName, &end_space);
-		}
-		else if( model->type == MOD_IQM ) {
-			return R_IQMLerpTag( tag, model->modelData,
-					startFrame, endFrame,
-					frac, tagName );
-		} else {
-			start = end = NULL;
-		}
+		lerpTag = qfalse;
+		tagIndex = R_IQMLerpTag( tag, model->modelData,
+				startTagIndex,
+				frameModel, startFrame,
+				endFrameModel, endFrame,
+				frac, tagName );
 	}
 	else
 	{
-		start = R_GetTag( model->md3[0], startFrame, tagName );
-		end = R_GetTag( model->md3[0], endFrame, tagName );
+		lerpTag = qfalse;
+		tagIndex = -1;
 	}
 
-	if ( !start || !end ) {
-		AxisClear( tag->axis );
-		VectorClear( tag->origin );
+	if ( pTagIndex ) {
+		*pTagIndex = tagIndex;
+	}
+
+	if ( tagIndex < 0 ) {
+		if ( tag ) {
+			AxisClear( tag->axis );
+			VectorClear( tag->origin );
+		}
 		return qfalse;
 	}
 
-	frontLerp = frac;
-	backLerp = 1.0f - frac;
+	if ( lerpTag && tag ) {
+		frontLerp = frac;
+		backLerp = 1.0f - frac;
 
-	for ( i = 0 ; i < 3 ; i++ ) {
-		tag->origin[i] = start->origin[i] * backLerp +  end->origin[i] * frontLerp;
-		tag->axis[0][i] = start->axis[0][i] * backLerp +  end->axis[0][i] * frontLerp;
-		tag->axis[1][i] = start->axis[1][i] * backLerp +  end->axis[1][i] * frontLerp;
-		tag->axis[2][i] = start->axis[2][i] * backLerp +  end->axis[2][i] * frontLerp;
+		for ( i = 0 ; i < 3 ; i++ ) {
+			tag->origin[i] = start.origin[i] * backLerp +  end.origin[i] * frontLerp;
+			tag->axis[0][i] = start.axis[0][i] * backLerp +  end.axis[0][i] * frontLerp;
+			tag->axis[1][i] = start.axis[1][i] * backLerp +  end.axis[1][i] * frontLerp;
+			tag->axis[2][i] = start.axis[2][i] * backLerp +  end.axis[2][i] * frontLerp;
+		}
+		VectorNormalize( tag->axis[0] );
+		VectorNormalize( tag->axis[1] );
+		VectorNormalize( tag->axis[2] );
 	}
-	VectorNormalize( tag->axis[0] );
-	VectorNormalize( tag->axis[1] );
-	VectorNormalize( tag->axis[2] );
+
 	return qtrue;
 }
 
@@ -1070,8 +1102,10 @@
 R_ModelBounds
 ====================
 */
-void R_ModelBounds( qhandle_t handle, vec3_t mins, vec3_t maxs ) {
+int R_ModelBounds( qhandle_t handle, vec3_t mins, vec3_t maxs, int startFrame, int endFrame, float frac ) {
 	model_t		*model;
+	float		frontLerp, backLerp;
+	int			i;
 
 	model = R_GetModelByHandle( handle );
 
@@ -1079,44 +1113,43 @@
 		VectorCopy( model->bmodel->bounds[0], mins );
 		VectorCopy( model->bmodel->bounds[1], maxs );
 		
-		return;
-	} else if (model->type == MOD_MESH) {
-		md3Header_t	*header;
-		md3Frame_t	*frame;
-
-		header = model->md3[0];
-		frame = (md3Frame_t *) ((byte *)header + header->ofsFrames);
-
-		VectorCopy( frame->bounds[0], mins );
-		VectorCopy( frame->bounds[1], maxs );
-		
-		return;
-	} else if (model->type == MOD_MDR) {
-		mdrHeader_t	*header;
-		mdrFrame_t	*frame;
-
-		header = (mdrHeader_t *)model->modelData;
-		frame = (mdrFrame_t *) ((byte *)header + header->ofsFrames);
-
-		VectorCopy( frame->bounds[0], mins );
-		VectorCopy( frame->bounds[1], maxs );
-		
-		return;
+		return qtrue;
 	} else if(model->type == MOD_IQM) {
 		iqmData_t *iqmData;
+		vec_t *startBounds, *endBounds;
 		
 		iqmData = model->modelData;
 
 		if(iqmData->bounds)
 		{
-			VectorCopy(iqmData->bounds, mins);
-			VectorCopy(iqmData->bounds + 3, maxs);
-			return;
+			if(iqmData->num_frames == 0) {
+				VectorCopy( iqmData->bounds, mins );
+				VectorCopy( iqmData->bounds+3, maxs );
+				return qtrue;
+			}
+
+			startBounds = iqmData->bounds + 6*(startFrame % iqmData->num_frames);
+			endBounds = iqmData->bounds + 6*(endFrame % iqmData->num_frames);
+
+			if ( startFrame == endFrame ) {
+				VectorCopy( startBounds, mins );
+				VectorCopy( startBounds+3, maxs );
+			} else {
+				frontLerp = frac;
+				backLerp = 1.0f - frac;
+
+				for ( i = 0 ; i < 3 ; i++ ) {
+					mins[i] = startBounds[i] * backLerp + endBounds[i] * frontLerp;
+					maxs[i] = startBounds[3+i] * backLerp + endBounds[3+i] * frontLerp;
+				}
+			}
+			return qtrue;
 		}
 	}
 
 	VectorClear( mins );
 	VectorClear( maxs );
+	return qfalse;
 }
 
 /*
Index: code/renderergl1/tr_model_iqm.c
===================================================================
--- code/renderergl1/tr_model_iqm.c	(revision 3386)
+++ code/renderergl1/tr_model_iqm.c	(working copy)
@@ -161,6 +161,21 @@
 	return length;
 }
 
+static iqmData_t *R_GetIQMModelDataByHandle( qhandle_t hModel, iqmData_t *defaultData ) {
+	model_t *mod;
+
+	if ( !hModel )
+		return defaultData;
+
+	mod = R_GetModelByHandle( hModel );
+
+	if ( mod->type != MOD_IQM ) {
+		return defaultData;
+	}
+
+	return mod->modelData;
+}
+
 /*
 =================
 R_LoadIQM
@@ -472,8 +487,8 @@
 		}
 	}
 
-	if( header->num_poses != header->num_joints && header->num_poses != 0 ) {
-		ri.Printf( PRINT_WARNING, "R_LoadIQM: %s has %d poses and %d joints, must have the same number or 0 poses\n",
+	if( header->num_poses != header->num_joints && header->num_poses != 0 && header->num_joints != 0 ) {
+		ri.Printf( PRINT_WARNING, "R_LoadIQM: %s has %d poses and %d joints, must have the same number or 0 poses or 0 joints\n",
 			  mod_name, header->num_poses, header->num_joints );
 		return qfalse;
 	}
@@ -965,26 +980,30 @@
 R_CullIQM
 =============
 */
-static int R_CullIQM( iqmData_t *data, trRefEntity_t *ent ) {
+static int R_CullIQM( iqmData_t *skeleton, iqmData_t *oldSkeleton, trRefEntity_t *ent ) {
 	vec3_t		bounds[2];
 	vec_t		*oldBounds, *newBounds;
 	int		i;
 
-	if (!data->bounds) {
+	if (skeleton->bounds && oldSkeleton->bounds) {
+		// compute bounds pointers
+		oldBounds = oldSkeleton->bounds + 6*ent->e.oldframe;
+		newBounds = skeleton->bounds + 6*ent->e.frame;
+
+		// calculate a bounding box in the current coordinate system
+		for (i = 0 ; i < 3 ; i++) {
+			bounds[0][i] = oldBounds[i] < newBounds[i] ? oldBounds[i] : newBounds[i];
+			bounds[1][i] = oldBounds[i+3] > newBounds[i+3] ? oldBounds[i+3] : newBounds[i+3];
+		}
+	} else if (skeleton->bounds) {
+		newBounds = skeleton->bounds + 6*ent->e.frame;
+		VectorCopy( newBounds, bounds[0] );
+		VectorCopy( (newBounds+3), bounds[1] );
+	} else {
 		tr.pc.c_box_cull_md3_clip++;
 		return CULL_CLIP;
 	}
 
-	// compute bounds pointers
-	oldBounds = data->bounds + 6*ent->e.oldframe;
-	newBounds = data->bounds + 6*ent->e.frame;
-
-	// calculate a bounding box in the current coordinate system
-	for (i = 0 ; i < 3 ; i++) {
-		bounds[0][i] = oldBounds[i] < newBounds[i] ? oldBounds[i] : newBounds[i];
-		bounds[1][i] = oldBounds[i+3] > newBounds[i+3] ? oldBounds[i+3] : newBounds[i+3];
-	}
-
 	switch ( R_CullLocalBox( bounds ) )
 	{
 	case CULL_IN:
@@ -1006,7 +1025,7 @@
 
 =================
 */
-int R_ComputeIQMFogNum( iqmData_t *data, trRefEntity_t *ent ) {
+int R_ComputeIQMFogNum( iqmData_t *skeleton, trRefEntity_t *ent ) {
 	int			i, j;
 	fog_t			*fog;
 	const vec_t		*bounds;
@@ -1020,8 +1039,8 @@
 	}
 
 	// FIXME: non-normalized axis issues
-	if (data->bounds) {
-		bounds = data->bounds + 6*ent->e.frame;
+	if (skeleton->bounds) {
+		bounds = skeleton->bounds + 6*ent->e.frame;
 	} else {
 		bounds = defaultBounds;
 	}
@@ -1057,23 +1076,32 @@
 */
 void R_AddIQMSurfaces( trRefEntity_t *ent ) {
 	iqmData_t		*data;
+	iqmData_t		*skeleton;
+	iqmData_t		*oldSkeleton;
 	srfIQModel_t		*surface;
-	int			i, j;
+	int			i;
 	qboolean		personalModel;
 	int			cull;
 	int			fogNum;
 	shader_t		*shader;
-	skin_t			*skin;
 
 	data = tr.currentModel->modelData;
 	surface = data->surfaces;
 
-	// don't add third_person objects if not in a portal
+	if ( !data->num_surfaces || !data->num_triangles || !data->num_vertexes ) {
+		ri.Printf( PRINT_WARNING, "WARNING: Tried to render IQM '%s' with no surfaces\n", tr.currentModel->name );
+		return;
+	}
+
+	skeleton = R_GetIQMModelDataByHandle( ent->e.frameModel, data );
+	oldSkeleton = R_GetIQMModelDataByHandle( ent->e.oldframeModel, data );
+
+	// don't add mirror only objects if not in a mirror/portal
 	personalModel = (ent->e.renderfx & RF_THIRD_PERSON) && !tr.viewParms.isPortal;
 
 	if ( ent->e.renderfx & RF_WRAP_FRAMES ) {
-		ent->e.frame %= data->num_frames;
-		ent->e.oldframe %= data->num_frames;
+		ent->e.frame %= skeleton->num_frames;
+		ent->e.oldframe %= oldSkeleton->num_frames;
 	}
 
 	//
@@ -1082,9 +1110,9 @@
 	// when the surfaces are rendered, they don't need to be
 	// range checked again.
 	//
-	if ( (ent->e.frame >= data->num_frames) 
+	if ( (ent->e.frame >= skeleton->num_frames) 
 	     || (ent->e.frame < 0)
-	     || (ent->e.oldframe >= data->num_frames)
+	     || (ent->e.oldframe >= oldSkeleton->num_frames)
 	     || (ent->e.oldframe < 0) ) {
 		ri.Printf( PRINT_DEVELOPER, "R_AddIQMSurfaces: no such frame %d to %d for '%s'\n",
 			   ent->e.oldframe, ent->e.frame,
@@ -1097,7 +1125,7 @@
 	// cull the entire model if merged bounding box of both frames
 	// is outside the view frustum.
 	//
-	cull = R_CullIQM ( data, ent );
+	cull = R_CullIQM ( skeleton, oldSkeleton, ent );
 	if ( cull == CULL_OUT ) {
 		return;
 	}
@@ -1112,7 +1140,7 @@
 	//
 	// see if we are in a fog volume
 	//
-	fogNum = R_ComputeIQMFogNum( data, ent );
+	fogNum = R_ComputeIQMFogNum( skeleton, ent );
 
 	for ( i = 0 ; i < data->num_surfaces ; i++ ) {
 		if ( ent->e.customShader || ent->e.customSkin ) {
@@ -1153,7 +1181,7 @@
 }
 
 
-static void ComputePoseMats( iqmData_t *data, int frame, int oldframe,
+static void ComputePoseMats( iqmData_t *data, iqmData_t *skeleton, iqmData_t *oldSkeleton, int frame, int oldframe,
 			      float backlerp, float *poseMats ) {
 	iqmTransform_t relativeJoints[IQM_MAX_JOINTS];
 	iqmTransform_t *relativeJoint;
@@ -1167,9 +1195,9 @@
 	relativeJoint = relativeJoints;
 
 	// copy or lerp animation frame pose
-	if ( oldframe == frame ) {
-		pose = &data->poses[frame * data->num_poses];
-		for ( i = 0; i < data->num_poses; i++, pose++, relativeJoint++ ) {
+	if ( oldframe == frame && skeleton == oldSkeleton ) {
+		pose = &skeleton->poses[frame * skeleton->num_poses];
+		for ( i = 0; i < skeleton->num_poses; i++, pose++, relativeJoint++ ) {
 			VectorCopy( pose->translate, relativeJoint->translate );
 			QuatCopy( pose->rotate, relativeJoint->rotate );
 			VectorCopy( pose->scale, relativeJoint->scale );
@@ -1176,9 +1204,9 @@
 		}
 	} else {
 		lerp = 1.0f - backlerp;
-		pose = &data->poses[frame * data->num_poses];
-		oldpose = &data->poses[oldframe * data->num_poses];
-		for ( i = 0; i < data->num_poses; i++, oldpose++, pose++, relativeJoint++ ) {
+		pose = &skeleton->poses[frame * skeleton->num_poses];
+		oldpose = &oldSkeleton->poses[oldframe * oldSkeleton->num_poses];
+		for ( i = 0; i < skeleton->num_poses; i++, oldpose++, pose++, relativeJoint++ ) {
 			relativeJoint->translate[0] = oldpose->translate[0] * backlerp + pose->translate[0] * lerp;
 			relativeJoint->translate[1] = oldpose->translate[1] * backlerp + pose->translate[1] * lerp;
 			relativeJoint->translate[2] = oldpose->translate[2] * backlerp + pose->translate[2] * lerp;
@@ -1196,7 +1224,7 @@
 	jointParent = data->jointParents;
 	invBindMat = data->invBindJoints;
 	poseMat = poseMats;
-	for ( i = 0; i < data->num_poses; i++, relativeJoint++, jointParent++, invBindMat += 12, poseMat += 12 ) {
+	for ( i = 0; i < skeleton->num_poses; i++, relativeJoint++, jointParent++, invBindMat += 12, poseMat += 12 ) {
 		float mat1[12], mat2[12];
 
 		JointToMatrix( relativeJoint->rotate, relativeJoint->scale, relativeJoint->translate, mat1 );
@@ -1211,17 +1239,17 @@
 	}
 }
 
-static void ComputeJointMats( iqmData_t *data, int frame, int oldframe,
+static void ComputeJointMats( iqmData_t *data, iqmData_t *skeleton, iqmData_t *oldSkeleton, int frame, int oldframe,
 			      float backlerp, float *mat ) {
 	float	*mat1;
 	int	i;
 
-	if ( data->num_poses == 0 ) {
+	if ( skeleton->num_poses == 0 ) {
 		Com_Memcpy( mat, data->bindJoints, data->num_joints * 12 * sizeof(float) );
 		return;
 	}
 
-	ComputePoseMats( data, frame, oldframe, backlerp, mat );
+	ComputePoseMats( data, skeleton, oldSkeleton, frame, oldframe, backlerp, mat );
 
 	for( i = 0; i < data->num_joints; i++ ) {
 		float outmat[12];
@@ -1233,7 +1261,6 @@
 	}
 }
 
-
 /*
 =================
 RB_AddIQMSurfaces
@@ -1258,8 +1285,11 @@
 	vec2_t		(*outTexCoord)[2];
 	color4ub_t	*outColor;
 
-	int	frame = data->num_frames ? backEnd.currentEntity->e.frame % data->num_frames : 0;
-	int	oldframe = data->num_frames ? backEnd.currentEntity->e.oldframe % data->num_frames : 0;
+	iqmData_t	*skeleton = R_GetIQMModelDataByHandle( backEnd.currentEntity->e.frameModel, data );
+	iqmData_t	*oldSkeleton = R_GetIQMModelDataByHandle( backEnd.currentEntity->e.oldframeModel, data );
+
+	int	frame = skeleton->num_frames ? backEnd.currentEntity->e.frame % skeleton->num_frames : 0;
+	int	oldframe = oldSkeleton->num_frames ? backEnd.currentEntity->e.oldframe % oldSkeleton->num_frames : 0;
 	float	backlerp = backEnd.currentEntity->e.backlerp;
 
 	int		*tri;
@@ -1266,6 +1296,18 @@
 	glIndex_t	*ptr;
 	glIndex_t	base;
 
+	if ( data != skeleton && data->num_joints != skeleton->num_poses ) {
+		ri.Printf( PRINT_WARNING, "WARNING: frameModel '%s' for model '%s' has different number of joints\n",
+				R_GetModelByHandle( backEnd.currentEntity->e.frameModel )->name, R_GetModelByHandle( backEnd.currentEntity->e.hModel )->name );
+		skeleton = data;
+	}
+
+	if ( data != oldSkeleton && data->num_joints != oldSkeleton->num_poses ) {
+		ri.Printf( PRINT_WARNING, "WARNING: oldframeModel '%s' for model '%s' has different number of joints\n",
+				R_GetModelByHandle( backEnd.currentEntity->e.oldframeModel )->name, R_GetModelByHandle( backEnd.currentEntity->e.hModel )->name );
+		oldSkeleton = data;
+	}
+
 	RB_CHECKOVERFLOW( surf->num_vertexes, surf->num_triangles * 3 );
 
 	xyz = &data->positions[surf->first_vertex * 3];
@@ -1283,9 +1325,9 @@
 	outTexCoord = &tess.texCoords[tess.numVertexes];
 	outColor = &tess.vertexColors[tess.numVertexes];
 
-	if ( data->num_poses > 0 ) {
+	if ( skeleton->num_poses > 0 ) {
 		// compute interpolated joint matrices
-		ComputePoseMats( data, frame, oldframe, backlerp, poseMats );
+		ComputePoseMats( data, skeleton, oldSkeleton, frame, oldframe, backlerp, poseMats );
 
 		// compute vertex blend influence matricies
 		for( i = 0; i < surf->num_influences; i++ ) {
@@ -1449,8 +1491,11 @@
 }
 
 int R_IQMLerpTag( orientation_t *tag, iqmData_t *data,
-		  int startFrame, int endFrame, 
+		  int startTagIndex,
+		  qhandle_t frameModel, int startFrame,
+		  qhandle_t endFrameModel, int endFrame,
 		  float frac, const char *tagName ) {
+	iqmData_t	*startSkeleton, *endSkeleton;
 	float	jointMats[IQM_MAX_JOINTS * 12];
 	int	joint;
 	char	*names = data->jointNames;
@@ -1457,18 +1502,24 @@
 
 	// get joint number by reading the joint names
 	for( joint = 0; joint < data->num_joints; joint++ ) {
-		if( !strcmp( tagName, names ) )
+		if( joint >= startTagIndex && !strcmp( tagName, names ) )
 			break;
 		names += strlen( names ) + 1;
 	}
 	if( joint >= data->num_joints ) {
-		AxisClear( tag->axis );
-		VectorClear( tag->origin );
-		return qfalse;
+		return -1;
 	}
 
-	ComputeJointMats( data, startFrame, endFrame, frac, jointMats );
+	// just checking if tag exists
+	if( !tag ) {
+		return joint;
+	}
 
+	startSkeleton = R_GetIQMModelDataByHandle( frameModel, data );
+	endSkeleton = R_GetIQMModelDataByHandle( endFrameModel, data );
+
+	ComputeJointMats( data, startSkeleton, endSkeleton, startFrame, endFrame, frac, jointMats );
+
 	tag->axis[0][0] = jointMats[12 * joint + 0];
 	tag->axis[1][0] = jointMats[12 * joint + 1];
 	tag->axis[2][0] = jointMats[12 * joint + 2];
@@ -1482,5 +1533,5 @@
 	tag->axis[2][2] = jointMats[12 * joint + 10];
 	tag->origin[2] = jointMats[12 * joint + 11];
 
-	return qtrue;
+	return joint;
 }
Index: code/renderergl2/tr_local.h
===================================================================
--- code/renderergl2/tr_local.h	(revision 3386)
+++ code/renderergl2/tr_local.h	(working copy)
@@ -1288,9 +1288,16 @@
 
 void		R_ModelInit (void);
 model_t		*R_GetModelByHandle( qhandle_t hModel );
-int			R_LerpTag( orientation_t *tag, qhandle_t handle, int startFrame, int endFrame, 
-					 float frac, const char *tagName );
-void		R_ModelBounds( qhandle_t handle, vec3_t mins, vec3_t maxs );
+int			R_LerpTag( orientation_t *tag, qhandle_t handle,
+					 qhandle_t frameModel, int startFrame,
+					 qhandle_t endFrameModel, int endFrame,
+					 float frac, const char *tagName,
+					 int *pTagIndex,
+					 const vec3_t *torsoAxis, // vec3_t[3]
+					 qhandle_t torsoFrameModel, int torsoStartFrame,
+					 qhandle_t torsoEndFrameModel, int torsoEndFrame,
+					 float torsoFrac );
+int			R_ModelBounds( qhandle_t handle, vec3_t mins, vec3_t maxs, int startFrame, int endFrame, float frac );
 shader_t	*R_CustomSurfaceShader( const char *surfaceName, qhandle_t customShader, qhandle_t customSkin );
 
 void		R_Modellist_f (void);
@@ -2294,7 +2301,9 @@
 void RB_IQMSurfaceAnim( surfaceType_t *surface );
 void RB_IQMSurfaceAnimVao( srfVaoIQModel_t *surface );
 int R_IQMLerpTag( orientation_t *tag, iqmData_t *data,
-                  int startFrame, int endFrame,
+                  int startTagIndex,
+                  qhandle_t frameMode, int startFrame,
+                  qhandle_t endFrameModel, int endFrame,
                   float frac, const char *tagName );
 
 /*
Index: code/renderergl2/tr_model.c
===================================================================
--- code/renderergl2/tr_model.c	(revision 3386)
+++ code/renderergl2/tr_model.c	(working copy)
@@ -1240,125 +1240,199 @@
 
 /*
 ================
-R_GetTag
+R_GetMDVTag
 ================
 */
-static mdvTag_t *R_GetTag( mdvModel_t *mod, int frame, const char *_tagName ) {
+static int R_GetMDVTagIndex( mdvModel_t *mod, const char *tagName, int startTagIndex ) {
+	mdvTagName_t    *tag;
 	int             i;
-	mdvTag_t       *tag;
-	mdvTagName_t   *tagName;
 
-	if ( frame >= mod->numFrames ) {
+	// ZTM: NOTE: Technically the names could be different for each MD3 frame. :(
+	tag = mod->tagNames + startTagIndex;
+	for ( i = startTagIndex ; i < mod->numTags ; i++, tag++ ) {
+		if ( !strcmp( tag->name, tagName ) ) {
+			return i; // found it
+		}
+	}
+
+	return -1;
+}
+
+static void R_GetMDVTag( mdvModel_t *mod, int frameNum, int tagIndex, orientation_t *outTag ) {
+	mdvTag_t        *tag;
+	int             i;
+
+	if ( frameNum >= mod->numFrames ) {
 		// it is possible to have a bad frame while changing models, so don't error
-		frame = mod->numFrames - 1;
+		frameNum = mod->numFrames - 1;
 	}
 
-	tag = mod->tags + frame * mod->numTags;
-	tagName = mod->tagNames;
-	for(i = 0; i < mod->numTags; i++, tag++, tagName++)
-	{
-		if(!strcmp(tagName->name, _tagName))
-		{
-			return tag;
+	assert( tagIndex >= 0 && tagIndex < mod->numTags );
+
+	tag = mod->tags + frameNum * mod->numTags + tagIndex;
+
+	VectorCopy( tag->origin, outTag->origin );
+	for ( i = 0; i < 3; i++ ) {
+		VectorCopy( tag->axis[i], outTag->axis[i] );
+	}
+}
+
+
+/*
+================
+R_GetMDRTag
+================
+*/
+static int R_GetMDRTagIndex( mdrHeader_t *mod, const char *tagName, int startTagIndex ) {
+	mdrTag_t        *tag;
+	int             i;
+
+	tag = (mdrTag_t *)((byte *)mod + mod->ofsTags) + startTagIndex;
+	for ( i = startTagIndex ; i < mod->numTags ; i++, tag++ ) {
+		if ( !strcmp( tag->name, tagName ) ) {
+			return i; // found it
 		}
 	}
 
-	return NULL;
+	return -1;
 }
 
-mdvTag_t *R_GetAnimTag( mdrHeader_t *mod, int framenum, const char *tagName, mdvTag_t * dest)
-{
-	int				i, j, k;
-	int				frameSize;
-	mdrFrame_t		*frame;
-	mdrTag_t		*tag;
+static void R_GetMDRTag( mdrHeader_t *mod, int frameNum, int tagIndex, orientation_t *outTag ) {
+	int             j, k;
+	int             frameSize;
+	mdrFrame_t      *frame;
+	mdrTag_t        *tag;
 
-	if ( framenum >= mod->numFrames ) 
-	{
+	if ( frameNum >= mod->numFrames ) {
 		// it is possible to have a bad frame while changing models, so don't error
-		framenum = mod->numFrames - 1;
+		frameNum = mod->numFrames - 1;
 	}
 
-	tag = (mdrTag_t *)((byte *)mod + mod->ofsTags);
-	for ( i = 0 ; i < mod->numTags ; i++, tag++ )
-	{
-		if ( !strcmp( tag->name, tagName ) )
-		{
-			// uncompressed model...
-			//
-			frameSize = (intptr_t)( &((mdrFrame_t *)0)->bones[ mod->numBones ] );
-			frame = (mdrFrame_t *)((byte *)mod + mod->ofsFrames + framenum * frameSize );
+	assert( tagIndex >= 0 && tagIndex < mod->numTags );
 
-			for (j = 0; j < 3; j++)
-			{
-				for (k = 0; k < 3; k++)
-					dest->axis[j][k]=frame->bones[tag->boneIndex].matrix[k][j];
-			}
+	tag = (mdrTag_t *)((byte *)mod + mod->ofsTags) + tagIndex;
 
-			dest->origin[0]=frame->bones[tag->boneIndex].matrix[0][3];
-			dest->origin[1]=frame->bones[tag->boneIndex].matrix[1][3];
-			dest->origin[2]=frame->bones[tag->boneIndex].matrix[2][3];				
+	// uncompressed model...
+	//
+	frameSize = (intptr_t)( &((mdrFrame_t *)0)->bones[ mod->numBones ] );
+	frame = (mdrFrame_t *)((byte *)mod + mod->ofsFrames + frameNum * frameSize );
 
-			return dest;
+	outTag->origin[0] = frame->bones[tag->boneIndex].matrix[0][3];
+	outTag->origin[1] = frame->bones[tag->boneIndex].matrix[1][3];
+	outTag->origin[2] = frame->bones[tag->boneIndex].matrix[2][3];
+
+	for ( j = 0; j < 3; j++ ) {
+		for ( k = 0; k < 3; k++ ) {
+			outTag->axis[j][k] = frame->bones[tag->boneIndex].matrix[k][j];
 		}
 	}
-
-	return NULL;
 }
 
 /*
 ================
 R_LerpTag
+
+"tag" can be NULL if just checking if tag exists.
+
+"pTagIndex" if not NULL specifies that starting tag index to loop for tagName.
+"pTagIndex" will be set to the tag index of the lerped tag or -1 if not found.
+
+returns 1 if tag was found or 0 if not found
 ================
 */
-int R_LerpTag( orientation_t *tag, qhandle_t handle, int startFrame, int endFrame, 
-					 float frac, const char *tagName ) {
-	mdvTag_t	*start, *end;
-	mdvTag_t	start_space, end_space;
+int R_LerpTag( orientation_t *tag, qhandle_t handle,
+					 qhandle_t frameModel, int startFrame,
+					 qhandle_t endFrameModel, int endFrame,
+					 float frac, const char *tagName,
+					 int *pTagIndex,
+					 const vec3_t *torsoAxis, // vec3_t[3]
+					 qhandle_t torsoFrameModel, int torsoStartFrame,
+					 qhandle_t torsoEndFrameModel, int torsoEndFrame,
+					 float torsoFrac )
+{
+	orientation_t	start, end;
+	qboolean		lerpTag;
 	int		i;
 	float		frontLerp, backLerp;
 	model_t		*model;
+	int			startTagIndex;
+	int			tagIndex;
 
+	if ( pTagIndex ) {
+		startTagIndex = *pTagIndex;
+
+		// specified invalid starting tag, return tag not found
+		if ( startTagIndex < 0 ) {
+			handle = 0;
+		}
+	} else {
+		startTagIndex = 0;
+	}
+
 	model = R_GetModelByHandle( handle );
-	if ( !model->mdv[0] )
+
+	if ( model->type == MOD_MESH )
 	{
-		if(model->type == MOD_MDR)
-		{
-			start = R_GetAnimTag((mdrHeader_t *) model->modelData, startFrame, tagName, &start_space);
-			end = R_GetAnimTag((mdrHeader_t *) model->modelData, endFrame, tagName, &end_space);
+		lerpTag = qtrue;
+		tagIndex = R_GetMDVTagIndex( model->mdv[0], tagName, startTagIndex );
+
+		if ( tagIndex >= 0 && tag ) {
+			R_GetMDVTag( model->mdv[0], startFrame, tagIndex, &start );
+			R_GetMDVTag( model->mdv[0], endFrame, tagIndex, &end );
 		}
-		else if( model->type == MOD_IQM ) {
-			return R_IQMLerpTag( tag, model->modelData,
-					startFrame, endFrame,
-					frac, tagName );
-		} else {
-			start = end = NULL;
+	}
+	else if ( model->type == MOD_MDR )
+	{
+		lerpTag = qtrue;
+		tagIndex = R_GetMDRTagIndex( (mdrHeader_t *) model->modelData, tagName, startTagIndex );
+
+		if ( tagIndex >= 0 && tag ) {
+			R_GetMDRTag( (mdrHeader_t *) model->modelData, startFrame, tagIndex, &start );
+			R_GetMDRTag( (mdrHeader_t *) model->modelData, endFrame, tagIndex, &end );
 		}
 	}
+	else if ( model->type == MOD_IQM )
+	{
+		lerpTag = qfalse;
+		tagIndex = R_IQMLerpTag( tag, model->modelData,
+				startTagIndex,
+				frameModel, startFrame,
+				endFrameModel, endFrame,
+				frac, tagName );
+	}
 	else
 	{
-		start = R_GetTag( model->mdv[0], startFrame, tagName );
-		end = R_GetTag( model->mdv[0], endFrame, tagName );
+		lerpTag = qfalse;
+		tagIndex = -1;
 	}
 
-	if ( !start || !end ) {
-		AxisClear( tag->axis );
-		VectorClear( tag->origin );
+	if ( pTagIndex ) {
+		*pTagIndex = tagIndex;
+	}
+
+	if ( tagIndex < 0 ) {
+		if ( tag ) {
+			AxisClear( tag->axis );
+			VectorClear( tag->origin );
+		}
 		return qfalse;
 	}
 
+	if ( lerpTag && tag ) {
 	frontLerp = frac;
 	backLerp = 1.0f - frac;
 
 	for ( i = 0 ; i < 3 ; i++ ) {
-		tag->origin[i] = start->origin[i] * backLerp +  end->origin[i] * frontLerp;
-		tag->axis[0][i] = start->axis[0][i] * backLerp +  end->axis[0][i] * frontLerp;
-		tag->axis[1][i] = start->axis[1][i] * backLerp +  end->axis[1][i] * frontLerp;
-		tag->axis[2][i] = start->axis[2][i] * backLerp +  end->axis[2][i] * frontLerp;
+			tag->origin[i] = start.origin[i] * backLerp +  end.origin[i] * frontLerp;
+			tag->axis[0][i] = start.axis[0][i] * backLerp +  end.axis[0][i] * frontLerp;
+			tag->axis[1][i] = start.axis[1][i] * backLerp +  end.axis[1][i] * frontLerp;
+			tag->axis[2][i] = start.axis[2][i] * backLerp +  end.axis[2][i] * frontLerp;
 	}
 	VectorNormalize( tag->axis[0] );
 	VectorNormalize( tag->axis[1] );
 	VectorNormalize( tag->axis[2] );
+	}
+
 	return qtrue;
 }
 
@@ -1368,8 +1442,10 @@
 R_ModelBounds
 ====================
 */
-void R_ModelBounds( qhandle_t handle, vec3_t mins, vec3_t maxs ) {
+int R_ModelBounds( qhandle_t handle, vec3_t mins, vec3_t maxs, int startFrame, int endFrame, float frac ) {
 	model_t		*model;
+	float		frontLerp, backLerp;
+	int			i;
 
 	model = R_GetModelByHandle( handle );
 
@@ -1377,44 +1453,85 @@
 		VectorCopy( model->bmodel->bounds[0], mins );
 		VectorCopy( model->bmodel->bounds[1], maxs );
 		
-		return;
+		return qtrue;
 	} else if (model->type == MOD_MESH) {
 		mdvModel_t	*header;
-		mdvFrame_t	*frame;
+		mdvFrame_t	*start, *end;
 
 		header = model->mdv[0];
-		frame = header->frames;
+		start = header->frames + startFrame % header->numFrames;
+		end = header->frames + endFrame % header->numFrames;
 
-		VectorCopy( frame->bounds[0], mins );
-		VectorCopy( frame->bounds[1], maxs );
+		if ( startFrame == endFrame ) {
+			VectorCopy( start->bounds[0], mins );
+			VectorCopy( start->bounds[1], maxs );
+		} else {
+			frontLerp = frac;
+			backLerp = 1.0f - frac;
+
+			for ( i = 0 ; i < 3 ; i++ ) {
+				mins[i] = start->bounds[0][i] * backLerp + end->bounds[0][i] * frontLerp;
+				maxs[i] = start->bounds[1][i] * backLerp + end->bounds[1][i] * frontLerp;
+			}
+		}
 		
-		return;
+		return qtrue;
 	} else if (model->type == MOD_MDR) {
 		mdrHeader_t	*header;
-		mdrFrame_t	*frame;
+		mdrFrame_t	*start, *end;
+		int frameSize;
 
 		header = (mdrHeader_t *)model->modelData;
-		frame = (mdrFrame_t *) ((byte *)header + header->ofsFrames);
 
-		VectorCopy( frame->bounds[0], mins );
-		VectorCopy( frame->bounds[1], maxs );
+		frameSize = (size_t)( &((mdrFrame_t *)0)->bones[ header->numBones ] );
+
+		start = (mdrFrame_t *)((byte *) header + header->ofsFrames + ( startFrame % header->numFrames ) * frameSize );
+		end = (mdrFrame_t *)((byte *) header + header->ofsFrames + ( endFrame % header->numFrames ) * frameSize );
+
+		if ( startFrame == endFrame ) {
+			VectorCopy( start->bounds[0], mins );
+			VectorCopy( start->bounds[1], maxs );
+		} else {
+			frontLerp = frac;
+			backLerp = 1.0f - frac;
+
+			for ( i = 0 ; i < 3 ; i++ ) {
+				mins[i] = start->bounds[0][i] * backLerp + end->bounds[0][i] * frontLerp;
+				maxs[i] = start->bounds[1][i] * backLerp + end->bounds[1][i] * frontLerp;
+			}
+		}
 		
-		return;
+		return qtrue;
 	} else if(model->type == MOD_IQM) {
 		iqmData_t *iqmData;
+		vec_t *startBounds, *endBounds;
 		
 		iqmData = model->modelData;
 
 		if(iqmData->bounds)
 		{
-			VectorCopy(iqmData->bounds, mins);
-			VectorCopy(iqmData->bounds + 3, maxs);
-			return;
+			startBounds = iqmData->bounds + 6*(startFrame % iqmData->num_frames);
+			endBounds = iqmData->bounds + 6*(endFrame % iqmData->num_frames);
+
+			if ( startFrame == endFrame ) {
+				VectorCopy( startBounds, mins );
+				VectorCopy( startBounds+3, maxs );
+			} else {
+				frontLerp = frac;
+				backLerp = 1.0f - frac;
+
+				for ( i = 0 ; i < 3 ; i++ ) {
+					mins[i] = startBounds[i] * backLerp + endBounds[i] * frontLerp;
+					maxs[i] = startBounds[3+i] * backLerp + endBounds[3+i] * frontLerp;
+				}
+			}
+			return qtrue;
 		}
 	}
 
 	VectorClear( mins );
 	VectorClear( maxs );
+	return qfalse;
 }
 
 /*
Index: code/renderergl2/tr_model_iqm.c
===================================================================
--- code/renderergl2/tr_model_iqm.c	(revision 3386)
+++ code/renderergl2/tr_model_iqm.c	(working copy)
@@ -161,6 +161,21 @@
 	return length;
 }
 
+static iqmData_t *R_GetIQMModelDataByHandle( qhandle_t hModel, iqmData_t *defaultData ) {
+	model_t *mod;
+
+	if ( !hModel )
+		return defaultData;
+
+	mod = R_GetModelByHandle( hModel );
+
+	if ( mod->type != MOD_IQM ) {
+		return defaultData;
+	}
+
+	return mod->modelData;
+}
+
 /*
 =================
 R_LoadIQM
@@ -475,8 +490,8 @@
 		}
 	}
 
-	if( header->num_poses != header->num_joints && header->num_poses != 0 ) {
-		ri.Printf( PRINT_WARNING, "R_LoadIQM: %s has %d poses and %d joints, must have the same number or 0 poses\n",
+	if( header->num_poses != header->num_joints && header->num_poses != 0 && header->num_joints != 0 ) {
+		ri.Printf( PRINT_WARNING, "R_LoadIQM: %s has %d poses and %d joints, must have the same number or 0 poses or 0 joints\n",
 			  mod_name, header->num_poses, header->num_joints );
 		return qfalse;
 	}
@@ -1132,26 +1147,30 @@
 R_CullIQM
 =============
 */
-static int R_CullIQM( iqmData_t *data, trRefEntity_t *ent ) {
+static int R_CullIQM( iqmData_t *skeleton, iqmData_t *oldSkeleton, trRefEntity_t *ent ) {
 	vec3_t		bounds[2];
 	vec_t		*oldBounds, *newBounds;
 	int		i;
 
-	if (!data->bounds) {
+	if (skeleton->bounds && oldSkeleton->bounds) {
+		// compute bounds pointers
+		oldBounds = oldSkeleton->bounds + 6*ent->e.oldframe;
+		newBounds = skeleton->bounds + 6*ent->e.frame;
+
+		// calculate a bounding box in the current coordinate system
+		for (i = 0 ; i < 3 ; i++) {
+			bounds[0][i] = oldBounds[i] < newBounds[i] ? oldBounds[i] : newBounds[i];
+			bounds[1][i] = oldBounds[i+3] > newBounds[i+3] ? oldBounds[i+3] : newBounds[i+3];
+		}
+	} else if (skeleton->bounds) {
+		newBounds = skeleton->bounds + 6*ent->e.frame;
+		VectorCopy( newBounds, bounds[0] );
+		VectorCopy( (newBounds+3), bounds[1] );
+	} else {
 		tr.pc.c_box_cull_md3_clip++;
 		return CULL_CLIP;
 	}
 
-	// compute bounds pointers
-	oldBounds = data->bounds + 6*ent->e.oldframe;
-	newBounds = data->bounds + 6*ent->e.frame;
-
-	// calculate a bounding box in the current coordinate system
-	for (i = 0 ; i < 3 ; i++) {
-		bounds[0][i] = oldBounds[i] < newBounds[i] ? oldBounds[i] : newBounds[i];
-		bounds[1][i] = oldBounds[i+3] > newBounds[i+3] ? oldBounds[i+3] : newBounds[i+3];
-	}
-
 	switch ( R_CullLocalBox( bounds ) )
 	{
 	case CULL_IN:
@@ -1173,7 +1192,7 @@
 
 =================
 */
-int R_ComputeIQMFogNum( iqmData_t *data, trRefEntity_t *ent ) {
+int R_ComputeIQMFogNum( iqmData_t *skeleton, trRefEntity_t *ent ) {
 	int			i, j;
 	fog_t			*fog;
 	const vec_t		*bounds;
@@ -1187,8 +1206,8 @@
 	}
 
 	// FIXME: non-normalized axis issues
-	if (data->bounds) {
-		bounds = data->bounds + 6*ent->e.frame;
+	if (skeleton->bounds) {
+		bounds = skeleton->bounds + 6*ent->e.frame;
 	} else {
 		bounds = defaultBounds;
 	}
@@ -1224,6 +1243,8 @@
 */
 void R_AddIQMSurfaces( trRefEntity_t *ent ) {
 	iqmData_t		*data;
+	iqmData_t		*skeleton;
+	iqmData_t		*oldSkeleton;
 	srfIQModel_t		*surface;
 	void			*drawSurf;
 	int			i;
@@ -1236,13 +1257,21 @@
 	data = tr.currentModel->modelData;
 	surface = data->surfaces;
 
-	// don't add third_person objects if not in a mirror/portal
+	if ( !data->num_surfaces || !data->num_triangles || !data->num_vertexes ) {
+		ri.Printf( PRINT_WARNING, "WARNING: Tried to render IQM '%s' with no surfaces\n", tr.currentModel->name );
+		return;
+	}
+
+	skeleton = R_GetIQMModelDataByHandle( ent->e.frameModel, data );
+	oldSkeleton = R_GetIQMModelDataByHandle( ent->e.oldframeModel, data );
+
+	// don't add mirror only objects if not in a mirror/portal
 	personalModel = (ent->e.renderfx & RF_THIRD_PERSON) && !(tr.viewParms.isPortal
 	                 || (tr.viewParms.flags & (VPF_SHADOWMAP | VPF_DEPTHSHADOW)));
 
 	if ( ent->e.renderfx & RF_WRAP_FRAMES ) {
-		ent->e.frame %= data->num_frames;
-		ent->e.oldframe %= data->num_frames;
+		ent->e.frame %= skeleton->num_frames;
+		ent->e.oldframe %= oldSkeleton->num_frames;
 	}
 
 	//
@@ -1251,9 +1280,9 @@
 	// when the surfaces are rendered, they don't need to be
 	// range checked again.
 	//
-	if ( (ent->e.frame >= data->num_frames) 
+	if ( (ent->e.frame >= skeleton->num_frames) 
 	     || (ent->e.frame < 0)
-	     || (ent->e.oldframe >= data->num_frames)
+	     || (ent->e.oldframe >= oldSkeleton->num_frames)
 	     || (ent->e.oldframe < 0) ) {
 		ri.Printf( PRINT_DEVELOPER, "R_AddIQMSurfaces: no such frame %d to %d for '%s'\n",
 			   ent->e.oldframe, ent->e.frame,
@@ -1266,7 +1295,7 @@
 	// cull the entire model if merged bounding box of both frames
 	// is outside the view frustum.
 	//
-	cull = R_CullIQM ( data, ent );
+	cull = R_CullIQM ( skeleton, oldSkeleton, ent );
 	if ( cull == CULL_OUT ) {
 		return;
 	}
@@ -1281,7 +1310,7 @@
 	//
 	// see if we are in a fog volume
 	//
-	fogNum = R_ComputeIQMFogNum( data, ent );
+	fogNum = R_ComputeIQMFogNum( skeleton, ent );
 
 	cubemapIndex = R_CubemapForPoint(ent->e.origin);
 
@@ -1330,7 +1359,7 @@
 }
 
 
-static void ComputePoseMats( iqmData_t *data, int frame, int oldframe,
+static void ComputePoseMats( iqmData_t *data, iqmData_t *skeleton, iqmData_t *oldSkeleton, int frame, int oldframe,
 			      float backlerp, float *poseMats ) {
 	iqmTransform_t relativeJoints[IQM_MAX_JOINTS];
 	iqmTransform_t *relativeJoint;
@@ -1344,9 +1373,9 @@
 	relativeJoint = relativeJoints;
 
 	// copy or lerp animation frame pose
-	if ( oldframe == frame ) {
-		pose = &data->poses[frame * data->num_poses];
-		for ( i = 0; i < data->num_poses; i++, pose++, relativeJoint++ ) {
+	if ( oldframe == frame && skeleton == oldSkeleton ) {
+		pose = &skeleton->poses[frame * skeleton->num_poses];
+		for ( i = 0; i < skeleton->num_poses; i++, pose++, relativeJoint++ ) {
 			VectorCopy( pose->translate, relativeJoint->translate );
 			QuatCopy( pose->rotate, relativeJoint->rotate );
 			VectorCopy( pose->scale, relativeJoint->scale );
@@ -1353,9 +1382,9 @@
 		}
 	} else {
 		lerp = 1.0f - backlerp;
-		pose = &data->poses[frame * data->num_poses];
-		oldpose = &data->poses[oldframe * data->num_poses];
-		for ( i = 0; i < data->num_poses; i++, oldpose++, pose++, relativeJoint++ ) {
+		pose = &skeleton->poses[frame * skeleton->num_poses];
+		oldpose = &oldSkeleton->poses[oldframe * oldSkeleton->num_poses];
+		for ( i = 0; i < skeleton->num_poses; i++, oldpose++, pose++, relativeJoint++ ) {
 			relativeJoint->translate[0] = oldpose->translate[0] * backlerp + pose->translate[0] * lerp;
 			relativeJoint->translate[1] = oldpose->translate[1] * backlerp + pose->translate[1] * lerp;
 			relativeJoint->translate[2] = oldpose->translate[2] * backlerp + pose->translate[2] * lerp;
@@ -1373,7 +1402,7 @@
 	jointParent = data->jointParents;
 	invBindMat = data->invBindJoints;
 	poseMat = poseMats;
-	for ( i = 0; i < data->num_poses; i++, relativeJoint++, jointParent++, invBindMat += 12, poseMat += 12 ) {
+	for ( i = 0; i < skeleton->num_poses; i++, relativeJoint++, jointParent++, invBindMat += 12, poseMat += 12 ) {
 		float mat1[12], mat2[12];
 
 		JointToMatrix( relativeJoint->rotate, relativeJoint->scale, relativeJoint->translate, mat1 );
@@ -1388,7 +1417,7 @@
 	}
 }
 
-static void ComputeJointMats( iqmData_t *data, int frame, int oldframe,
+static void ComputeJointMats( iqmData_t *data, iqmData_t *skeleton, iqmData_t *oldSkeleton, int frame, int oldframe,
 			      float backlerp, float *mat ) {
 	float	*mat1;
 	int	i;
@@ -1398,7 +1427,7 @@
 		return;
 	}
 
-	ComputePoseMats( data, frame, oldframe, backlerp, mat );
+	ComputePoseMats( data, skeleton, oldSkeleton, frame, oldframe, backlerp, mat );
 
 	for( i = 0; i < data->num_joints; i++ ) {
 		float outmat[12];
@@ -1410,7 +1439,6 @@
 	}
 }
 
-
 /*
 =================
 RB_AddIQMSurfaces
@@ -1437,8 +1465,11 @@
 	vec2_t		*outTexCoord;
 	uint16_t *outColor;
 
-	int	frame = data->num_frames ? backEnd.currentEntity->e.frame % data->num_frames : 0;
-	int	oldframe = data->num_frames ? backEnd.currentEntity->e.oldframe % data->num_frames : 0;
+	iqmData_t	*skeleton = R_GetIQMModelDataByHandle( backEnd.currentEntity->e.frameModel, data );
+	iqmData_t	*oldSkeleton = R_GetIQMModelDataByHandle( backEnd.currentEntity->e.oldframeModel, data );
+
+	int	frame = skeleton->num_frames ? backEnd.currentEntity->e.frame % skeleton->num_frames : 0;
+	int	oldframe = oldSkeleton->num_frames ? backEnd.currentEntity->e.oldframe % oldSkeleton->num_frames : 0;
 	float	backlerp = backEnd.currentEntity->e.backlerp;
 
 	int		*tri;
@@ -1445,6 +1476,18 @@
 	glIndex_t	*ptr;
 	glIndex_t	base;
 
+	if ( data != skeleton && data->num_joints != skeleton->num_poses ) {
+		ri.Printf( PRINT_WARNING, "WARNING: frameModel '%s' for model '%s' has different number of joints\n",
+				R_GetModelByHandle( backEnd.currentEntity->e.frameModel )->name, R_GetModelByHandle( backEnd.currentEntity->e.hModel )->name );
+		skeleton = data;
+	}
+
+	if ( data != oldSkeleton && data->num_joints != oldSkeleton->num_poses ) {
+		ri.Printf( PRINT_WARNING, "WARNING: oldframeModel '%s' for model '%s' has different number of joints\n",
+				R_GetModelByHandle( backEnd.currentEntity->e.oldframeModel )->name, R_GetModelByHandle( backEnd.currentEntity->e.hModel )->name );
+		oldSkeleton = data;
+	}
+
 	RB_CHECKOVERFLOW( surf->num_vertexes, surf->num_triangles * 3 );
 
 	xyz = &data->positions[surf->first_vertex * 3];
@@ -1464,9 +1507,9 @@
 	outTexCoord = &tess.texCoords[tess.numVertexes];
 	outColor = tess.color[tess.numVertexes];
 
-	if ( data->num_poses > 0 ) {
+	if ( skeleton->num_poses > 0 ) {
 		// compute interpolated joint matrices
-		ComputePoseMats( data, frame, oldframe, backlerp, poseMats );
+		ComputePoseMats( data, skeleton, oldSkeleton, frame, oldframe, backlerp, poseMats );
 
 		// compute vertex blend influence matricies
 		for( i = 0; i < surf->num_influences; i++ ) {
@@ -1652,6 +1695,25 @@
 {
 	iqmData_t *data = surface->iqmData;
 
+	iqmData_t	*skeleton = R_GetIQMModelDataByHandle( backEnd.currentEntity->e.frameModel, data );
+	iqmData_t	*oldSkeleton = R_GetIQMModelDataByHandle( backEnd.currentEntity->e.oldframeModel, data );
+
+	int	frame = skeleton->num_frames ? backEnd.currentEntity->e.frame % skeleton->num_frames : 0;
+	int	oldframe = oldSkeleton->num_frames ? backEnd.currentEntity->e.oldframe % oldSkeleton->num_frames : 0;
+	float	backlerp = backEnd.currentEntity->e.backlerp;
+
+	if ( data != skeleton && data->num_joints != skeleton->num_poses ) {
+		ri.Printf( PRINT_WARNING, "WARNING: frameModel '%s' for model '%s' has different number of joints\n",
+				R_GetModelByHandle( backEnd.currentEntity->e.frameModel )->name, R_GetModelByHandle( backEnd.currentEntity->e.hModel )->name );
+		skeleton = data;
+	}
+
+	if ( data != oldSkeleton && data->num_joints != oldSkeleton->num_poses ) {
+		ri.Printf( PRINT_WARNING, "WARNING: oldframeModel '%s' for model '%s' has different number of joints\n",
+				R_GetModelByHandle( backEnd.currentEntity->e.oldframeModel )->name, R_GetModelByHandle( backEnd.currentEntity->e.hModel )->name );
+		oldSkeleton = data;
+	}
+
 	if (ShaderRequiresCPUDeforms(tess.shader))
 	{
 		RB_IQMSurfaceAnim((surfaceType_t*)surface->iqmSurface);
@@ -1672,17 +1734,14 @@
 	tess.numIndexes = surface->numIndexes;
 	tess.numVertexes = surface->numVerts;
 
-	glState.boneAnimation = data->num_poses;
+	glState.boneAnimation = skeleton->num_poses;
 
 	if ( glState.boneAnimation ) {
 		float		jointMats[IQM_MAX_JOINTS * 12];
-		int			frame = data->num_frames ? backEnd.currentEntity->e.frame % data->num_frames : 0;
-		int			oldframe = data->num_frames ? backEnd.currentEntity->e.oldframe % data->num_frames : 0;
-		float		backlerp = backEnd.currentEntity->e.backlerp;
 		int i;
 
 		// compute interpolated joint matrices
-		ComputePoseMats( surface->iqmData, frame, oldframe, backlerp, jointMats );
+		ComputePoseMats( data, skeleton, oldSkeleton, frame, oldframe, backlerp, jointMats );
 
 		// convert row-major order 3x4 matrix to column-major order 4x4 matrix
 		for ( i = 0; i < data->num_poses; i++ ) {
@@ -1711,8 +1770,11 @@
 }
 
 int R_IQMLerpTag( orientation_t *tag, iqmData_t *data,
-		  int startFrame, int endFrame, 
+		  int startTagIndex,
+		  qhandle_t frameModel, int startFrame,
+		  qhandle_t endFrameModel, int endFrame,
 		  float frac, const char *tagName ) {
+	iqmData_t	*startSkeleton, *endSkeleton;
 	float	jointMats[IQM_MAX_JOINTS * 12];
 	int	joint;
 	char	*names = data->jointNames;
@@ -1719,18 +1781,24 @@
 
 	// get joint number by reading the joint names
 	for( joint = 0; joint < data->num_joints; joint++ ) {
-		if( !strcmp( tagName, names ) )
+		if( joint >= startTagIndex && !strcmp( tagName, names ) )
 			break;
 		names += strlen( names ) + 1;
 	}
 	if( joint >= data->num_joints ) {
-		AxisClear( tag->axis );
-		VectorClear( tag->origin );
-		return qfalse;
+		return -1;
 	}
 
-	ComputeJointMats( data, startFrame, endFrame, frac, jointMats );
+	// just checking if tag exists
+	if( !tag ) {
+		return joint;
+	}
 
+	startSkeleton = R_GetIQMModelDataByHandle( frameModel, data );
+	endSkeleton = R_GetIQMModelDataByHandle( endFrameModel, data );
+
+	ComputeJointMats( data, startSkeleton, endSkeleton, startFrame, endFrame, frac, jointMats );
+
 	tag->axis[0][0] = jointMats[12 * joint + 0];
 	tag->axis[1][0] = jointMats[12 * joint + 1];
 	tag->axis[2][0] = jointMats[12 * joint + 2];
@@ -1744,5 +1812,5 @@
 	tag->axis[2][2] = jointMats[12 * joint + 10];
 	tag->origin[2] = jointMats[12 * joint + 11];
 
-	return qtrue;
+	return joint;
 }
Index: code/ui/ui_local.h
===================================================================
--- code/ui/ui_local.h	(revision 3386)
+++ code/ui/ui_local.h	(working copy)
@@ -525,10 +525,24 @@
 void			trap_R_RenderScene( const refdef_t *fd );
 void			trap_R_SetColor( const float *rgba );
 void			trap_R_DrawStretchPic( float x, float y, float w, float h, float s1, float t1, float s2, float t2, qhandle_t hShader );
-void			trap_R_ModelBounds( clipHandle_t model, vec3_t mins, vec3_t maxs );
+int trap_R_ModelBounds( clipHandle_t handle, vec3_t mins, vec3_t maxs, int startFrame, int endFrame, float frac );
+int trap_R_LerpTag( orientation_t *tag, clipHandle_t handle, int startFrame, int endFrame,
+					   float frac, const char *tagName );
+int			trap_R_LerpTagFrameModel( orientation_t *tag, clipHandle_t mod,
+					   clipHandle_t frameModel, int startFrame,
+					   clipHandle_t endFrameModel, int endFrame,
+					   float frac, const char *tagName,
+					   int *tagIndex );
+int			trap_R_LerpTagTorso( orientation_t *tag, clipHandle_t mod,
+					   clipHandle_t frameModel, int startFrame,
+					   clipHandle_t endFrameModel, int endFrame,
+					   float frac, const char *tagName,
+					   int *tagIndex, const vec3_t *torsoAxis,
+					   qhandle_t torsoFrameModel, int torsoFrame,
+					   qhandle_t oldTorsoFrameModel, int oldTorsoFrame,
+					   float torsoFrac );
 void			trap_UpdateScreen( void );
 void			trap_R_SetClipRegion( const float *region );
-int				trap_CM_LerpTag( orientation_t *tag, clipHandle_t mod, int startFrame, int endFrame, float frac, const char *tagName );
 // skin (entity model surface remap) management
 qhandle_t		trap_R_AllocSkinSurface( const char *surface, qhandle_t hShader );
 qhandle_t		trap_R_AddSkinToFrame( int numSurfaces, const qhandle_t *surfaces );
Index: code/ui/ui_players.c
===================================================================
--- code/ui/ui_players.c	(revision 3386)
+++ code/ui/ui_players.c	(working copy)
@@ -298,14 +298,17 @@
 UI_PositionEntityOnTag
 ======================
 */
-static void UI_PositionEntityOnTag( refEntity_t *entity, const refEntity_t *parent, 
+static qboolean UI_PositionEntityOnTag( refEntity_t *entity, const refEntity_t *parent,
 							clipHandle_t parentModel, char *tagName ) {
 	int				i;
 	orientation_t	lerped;
+	qboolean		returnValue;
 	
 	// lerp the tag
-	trap_CM_LerpTag( &lerped, parentModel, parent->oldframe, parent->frame,
-		1.0 - parent->backlerp, tagName );
+	returnValue = trap_R_LerpTagFrameModel( &lerped, parentModel,
+		parent->oldframeModel, parent->oldframe,
+		parent->frameModel, parent->frame,
+		1.0 - parent->backlerp, tagName, NULL );
 
 	// FIXME: allow origin offsets along tag?
 	VectorCopy( parent->origin, entity->origin );
@@ -316,6 +319,8 @@
 	// cast away const because of compiler problems
 	MatrixMultiply( lerped.axis, ((refEntity_t*)parent)->axis, entity->axis );
 	entity->backlerp = parent->backlerp;
+
+	return returnValue;
 }
 
 
@@ -324,15 +329,18 @@
 UI_PositionRotatedEntityOnTag
 ======================
 */
-static void UI_PositionRotatedEntityOnTag( refEntity_t *entity, const refEntity_t *parent, 
+static qboolean UI_PositionRotatedEntityOnTag( refEntity_t *entity, const refEntity_t *parent,
 							clipHandle_t parentModel, char *tagName ) {
 	int				i;
 	orientation_t	lerped;
 	vec3_t			tempAxis[3];
+	qboolean		returnValue;
 
 	// lerp the tag
-	trap_CM_LerpTag( &lerped, parentModel, parent->oldframe, parent->frame,
-		1.0 - parent->backlerp, tagName );
+	returnValue = trap_R_LerpTagFrameModel( &lerped, parentModel,
+		parent->oldframeModel, parent->oldframe,
+		parent->frameModel, parent->frame,
+		1.0 - parent->backlerp, tagName, NULL );
 
 	// FIXME: allow origin offsets along tag?
 	VectorCopy( parent->origin, entity->origin );
@@ -343,6 +351,8 @@
 	// cast away const because of compiler problems
 	MatrixMultiply( entity->axis, lerped.axis, tempAxis );
 	MatrixMultiply( tempAxis, ((refEntity_t *)parent)->axis, entity->axis );
+
+	return returnValue;
 }
 
 
Index: code/ui/ui_public.h
===================================================================
--- code/ui/ui_public.h	(revision 3386)
+++ code/ui/ui_public.h	(working copy)
@@ -66,7 +66,9 @@
 	UI_R_SETCOLOR,
 	UI_R_DRAWSTRETCHPIC,
 	UI_UPDATESCREEN,
-	UI_CM_LERPTAG,
+	UI_R_LERPTAG,
+	UI_R_LERPTAG_FRAMEMODEL,
+	UI_R_LERPTAG_TORSO,
 	UI_CM_LOADMODEL,
 	UI_S_REGISTERSOUND,
 	UI_S_STARTLOCALSOUND,
Index: code/ui/ui_shared.c
===================================================================
--- code/ui/ui_shared.c	(revision 3386)
+++ code/ui/ui_shared.c	(working copy)
@@ -3662,7 +3662,7 @@
 	refdef.width = w;
 	refdef.height = h;
 
-	DC->modelBounds( item->asset, mins, maxs );
+	DC->modelBounds( item->asset, mins, maxs, 0, 0, 0 );
 
 	origin[2] = -0.5 * ( mins[2] + maxs[2] );
 	origin[1] = 0.5 * ( mins[1] + maxs[1] );
Index: code/ui/ui_shared.h
===================================================================
--- code/ui/ui_shared.h	(revision 3386)
+++ code/ui/ui_shared.h	(working copy)
@@ -325,7 +325,7 @@
   int (*textWidth) (const char *text, float scale, int limit);
   int (*textHeight) (const char *text, float scale, int limit);
   qhandle_t (*registerModel) (const char *p);
-  void (*modelBounds) (qhandle_t model, vec3_t min, vec3_t max);
+  int (*modelBounds) (qhandle_t model, vec3_t min, vec3_t max, int startFrame, int endFrame, float frac);
   void (*fillRect) ( float x, float y, float w, float h, const vec4_t color);
   void (*drawRect) ( float x, float y, float w, float h, float size, const vec4_t color);
   void (*drawSides) (float x, float y, float w, float h, float size);
Index: code/ui/ui_syscalls.asm
===================================================================
--- code/ui/ui_syscalls.asm	(revision 3386)
+++ code/ui/ui_syscalls.asm	(working copy)
@@ -31,64 +31,66 @@
 equ	trap_R_SetColor							-29
 equ	trap_R_DrawStretchPic					-30
 equ	trap_UpdateScreen						-31
-equ	trap_CM_LerpTag							-32
-equ	trap_CM_LoadModel						-33
-equ	trap_S_RegisterSound					-34
-equ	trap_S_StartLocalSound					-35
-equ	trap_Key_KeynumToStringBuf				-36
-equ	trap_Key_GetBindingBuf					-37
-equ	trap_Key_SetBinding						-38
-equ	trap_Key_IsDown							-39
-equ	trap_Key_GetOverstrikeMode				-40
-equ	trap_Key_SetOverstrikeMode				-41
-equ	trap_Key_ClearStates					-42
-equ	trap_Key_GetCatcher						-43
-equ	trap_Key_SetCatcher						-44
-equ	trap_GetClipboardData					-45
-equ	trap_GetGlconfig						-46
-equ	trap_GetClientState						-47
-equ	trap_GetConfigString					-48
-equ	trap_LAN_GetPingQueueCount				-49
-equ	trap_LAN_ClearPing						-50
-equ	trap_LAN_GetPing						-51
-equ	trap_LAN_GetPingInfo					-52
-equ	trap_Cvar_Register						-53
-equ trap_Cvar_Update						-54
-equ trap_MemoryRemaining					-55
-equ trap_R_RegisterFont						-56
-equ trap_R_ModelBounds						-57
-equ trap_PC_AddGlobalDefine					-58
-equ	trap_PC_LoadSource						-59
-equ trap_PC_FreeSource						-60
-equ trap_PC_ReadToken						-61
-equ trap_PC_SourceFileAndLine				-62
-equ trap_S_StopBackgroundTrack				-63
-equ trap_S_StartBackgroundTrack				-64
-equ trap_RealTime							-65
-equ trap_LAN_GetServerCount					-66
-equ trap_LAN_GetServerAddressString			-67
-equ trap_LAN_GetServerInfo					-68
-equ trap_LAN_MarkServerVisible 				-69
-equ trap_LAN_UpdateVisiblePings				-70
-equ trap_LAN_ResetPings						-71
-equ trap_LAN_LoadCachedServers				-72
-equ trap_LAN_SaveCachedServers				-73
-equ trap_LAN_AddServer						-74
-equ trap_LAN_RemoveServer	 				-75
-equ trap_CIN_PlayCinematic					-76
-equ trap_CIN_StopCinematic					-77
-equ trap_CIN_RunCinematic 					-78
-equ trap_CIN_DrawCinematic					-79
-equ trap_CIN_SetExtents						-80
-equ trap_R_RemapShader						-81
-equ trap_R_SetClipRegion					-82
-equ trap_R_AllocSkinSurface					-83
-equ trap_R_AddSkinToFrame					-84
-equ trap_LAN_ServerStatus					-85
-equ trap_LAN_GetServerPing					-86
-equ trap_LAN_ServerIsVisible				-87
-equ trap_LAN_CompareServers					-88
-equ trap_FS_Seek		-89
+equ	trap_CM_LoadModel						-32
+equ	trap_S_RegisterSound					-33
+equ	trap_S_StartLocalSound					-34
+equ	trap_Key_KeynumToStringBuf				-35
+equ	trap_Key_GetBindingBuf					-36
+equ	trap_Key_SetBinding						-37
+equ	trap_Key_IsDown							-38
+equ	trap_Key_GetOverstrikeMode				-39
+equ	trap_Key_SetOverstrikeMode				-40
+equ	trap_Key_ClearStates					-41
+equ	trap_Key_GetCatcher						-42
+equ	trap_Key_SetCatcher						-43
+equ	trap_GetClipboardData					-44
+equ	trap_GetGlconfig						-45
+equ	trap_GetClientState						-46
+equ	trap_GetConfigString					-47
+equ	trap_LAN_GetPingQueueCount				-48
+equ	trap_LAN_ClearPing						-49
+equ	trap_LAN_GetPing						-50
+equ	trap_LAN_GetPingInfo					-51
+equ	trap_Cvar_Register						-52
+equ trap_Cvar_Update						-53
+equ trap_MemoryRemaining					-54
+equ trap_R_RegisterFont						-55
+equ trap_R_ModelBounds						-56
+equ trap_R_LerpTag							-57
+equ trap_R_LerpTagFrameModel				-58
+equ trap_R_LerpTagTorso						-59
+equ trap_PC_AddGlobalDefine					-60
+equ	trap_PC_LoadSource						-61
+equ trap_PC_FreeSource						-62
+equ trap_PC_ReadToken						-63
+equ trap_PC_SourceFileAndLine				-64
+equ trap_S_StopBackgroundTrack				-65
+equ trap_S_StartBackgroundTrack				-66
+equ trap_RealTime							-67
+equ trap_LAN_GetServerCount					-68
+equ trap_LAN_GetServerAddressString			-79
+equ trap_LAN_GetServerInfo					-70
+equ trap_LAN_MarkServerVisible 				-71
+equ trap_LAN_UpdateVisiblePings				-72
+equ trap_LAN_ResetPings						-73
+equ trap_LAN_LoadCachedServers				-74
+equ trap_LAN_SaveCachedServers				-75
+equ trap_LAN_AddServer						-76
+equ trap_LAN_RemoveServer	 				-77
+equ trap_CIN_PlayCinematic					-78
+equ trap_CIN_StopCinematic					-79
+equ trap_CIN_RunCinematic 					-80
+equ trap_CIN_DrawCinematic					-81
+equ trap_CIN_SetExtents						-82
+equ trap_R_RemapShader						-83
+equ trap_R_SetClipRegion					-84
+equ trap_R_AllocSkinSurface					-85
+equ trap_R_AddSkinToFrame					-86
+equ trap_LAN_ServerStatus					-87
+equ trap_LAN_GetServerPing					-88
+equ trap_LAN_ServerIsVisible				-89
+equ trap_LAN_CompareServers					-90
+equ trap_FS_Seek		-91
 
 equ	memset						-101
 equ	memcpy						-102
Index: code/ui/ui_syscalls.c
===================================================================
--- code/ui/ui_syscalls.c	(revision 3386)
+++ code/ui/ui_syscalls.c	(working copy)
@@ -181,8 +181,8 @@
 	syscall( UI_R_DRAWSTRETCHPIC, PASSFLOAT(x), PASSFLOAT(y), PASSFLOAT(w), PASSFLOAT(h), PASSFLOAT(s1), PASSFLOAT(t1), PASSFLOAT(s2), PASSFLOAT(t2), hShader );
 }
 
-void	trap_R_ModelBounds( clipHandle_t model, vec3_t mins, vec3_t maxs ) {
-	syscall( UI_R_MODELBOUNDS, model, mins, maxs );
+int		trap_R_ModelBounds( clipHandle_t model, vec3_t mins, vec3_t maxs, int startFrame, int endFrame, float frac ) {
+	return syscall( UI_R_MODELBOUNDS, model, mins, maxs, startFrame, endFrame, PASSFLOAT(frac) );
 }
 
 void trap_UpdateScreen( void ) {
@@ -189,10 +189,33 @@
 	syscall( UI_UPDATESCREEN );
 }
 
-int trap_CM_LerpTag( orientation_t *tag, clipHandle_t mod, int startFrame, int endFrame, float frac, const char *tagName ) {
-	return syscall( UI_CM_LERPTAG, tag, mod, startFrame, endFrame, PASSFLOAT(frac), tagName );
+int		trap_R_LerpTag( orientation_t *tag, clipHandle_t mod, int startFrame, int endFrame, 
+					   float frac, const char *tagName ) {
+	return syscall( UI_R_LERPTAG, tag, mod, startFrame, endFrame, PASSFLOAT(frac), tagName );
 }
 
+int		trap_R_LerpTagFrameModel( orientation_t *tag, clipHandle_t mod,
+					   clipHandle_t frameModel, int startFrame,
+					   clipHandle_t endFrameModel, int endFrame,
+					   float frac, const char *tagName,
+					   int *tagIndex )
+{
+	return syscall( UI_R_LERPTAG_FRAMEMODEL, tag, mod, frameModel, startFrame, endFrameModel, endFrame, PASSFLOAT(frac), tagName, tagIndex );
+}
+
+int		trap_R_LerpTagTorso( orientation_t *tag, clipHandle_t mod,
+					   clipHandle_t frameModel, int startFrame,
+					   clipHandle_t endFrameModel, int endFrame,
+					   float frac, const char *tagName,
+					   int *tagIndex, const vec3_t *torsoAxis,
+					   qhandle_t torsoFrameModel, int torsoFrame,
+					   qhandle_t oldTorsoFrameModel, int oldTorsoFrame,
+					   float torsoFrac )
+{
+	return syscall( UI_R_LERPTAG_TORSO, tag, mod, frameModel, startFrame, endFrameModel, endFrame, PASSFLOAT(frac), tagName, tagIndex,
+										torsoAxis, torsoFrameModel, torsoFrame, oldTorsoFrameModel, oldTorsoFrame, PASSFLOAT(torsoFrac) );
+}
+
 void trap_S_StartLocalSound( sfxHandle_t sfx, int channelNum ) {
 	syscall( UI_S_STARTLOCALSOUND, sfx, channelNum );
 }
