Index: code/cgame/cg_local.h
===================================================================
--- code/cgame/cg_local.h	(revision 3336)
+++ code/cgame/cg_local.h	(working copy)
@@ -1736,7 +1736,6 @@
 void		testPrintFloat( char *string, float f );
 
 int			trap_MemoryRemaining( void );
-void		trap_R_RegisterFont(const char *fontName, int pointSize, fontInfo_t *font);
 qboolean	trap_Key_IsDown( int keynum );
 int			trap_Key_GetCatcher( void );
 void		trap_Key_SetCatcher( int catcher );
Index: code/cgame/cg_main.c
===================================================================
--- code/cgame/cg_main.c	(revision 3336)
+++ code/cgame/cg_main.c	(working copy)
@@ -1312,7 +1312,7 @@
 			if (!PC_String_Parse(handle, &tempStr) || !PC_Int_Parse(handle, &pointSize)) {
 				return qfalse;
 			}
-			cgDC.registerFont(tempStr, pointSize, &cgDC.Assets.textFont);
+			cgDC.registerFont(tempStr, pointSize, 0, qfalse, &cgDC.Assets.textFont);
 			continue;
 		}
 
@@ -1322,7 +1322,7 @@
 			if (!PC_String_Parse(handle, &tempStr) || !PC_Int_Parse(handle, &pointSize)) {
 				return qfalse;
 			}
-			cgDC.registerFont(tempStr, pointSize, &cgDC.Assets.smallFont);
+			cgDC.registerFont(tempStr, pointSize, 0, qfalse, &cgDC.Assets.smallFont);
 			continue;
 		}
 
@@ -1332,7 +1332,7 @@
 			if (!PC_String_Parse(handle, &tempStr) || !PC_Int_Parse(handle, &pointSize)) {
 				return qfalse;
 			}
-			cgDC.registerFont(tempStr, pointSize, &cgDC.Assets.bigFont);
+			cgDC.registerFont(tempStr, pointSize, 0, qfalse, &cgDC.Assets.bigFont);
 			continue;
 		}
 
@@ -1889,7 +1889,7 @@
 
 void CG_AssetCache( void ) {
 	//if (Assets.textFont == NULL) {
-	//  trap_R_RegisterFont("fonts/arial.ttf", 72, &Assets.textFont);
+	//  trap_R_RegisterFont("fonts/arial.ttf", 72, 0, qfalse, &Assets.textFont);
 	//}
 	//Assets.background = trap_R_RegisterShaderNoMip( ASSET_BACKGROUND );
 	//Com_Printf("Menu Size: %i bytes\n", sizeof(Menus));
Index: code/cgame/cg_syscalls.c
===================================================================
--- code/cgame/cg_syscalls.c	(revision 3336)
+++ code/cgame/cg_syscalls.c	(working copy)
@@ -567,8 +567,8 @@
 trap_R_RegisterFont
 =======================================================================================================================================
 */
-void trap_R_RegisterFont(const char *fontName, int pointSize, fontInfo_t *font) {
-	syscall(CG_R_REGISTERFONT, fontName, pointSize, font);
+void trap_R_RegisterFont(const char *fontName, int pointSize, float borderWidth, qboolean forceAutoHint, fontInfo_t *font) {
+	syscall( CG_R_REGISTERFONT, fontName, pointSize, PASSFLOAT( borderWidth ), forceAutoHint, font );
 }
 
 /*
Index: code/client/cl_cgame.c
===================================================================
--- code/client/cl_cgame.c	(revision 3336)
+++ code/client/cl_cgame.c	(working copy)
@@ -572,14 +572,14 @@
 			return re.RegisterShaderEx(VMA(1), args[2], args[3]);
 		case CG_R_REGISTERSHADER:
 			return re.RegisterShader(VMA(1));
-		case CG_R_REGISTERSHADERNOMIP:
-			return re.RegisterShaderNoMip(VMA(1));
-		case CG_R_REGISTERFONT:
-			re.RegisterFont( VMA(1), args[2], VMA(3));
+	case CG_R_REGISTERSHADERNOMIP:
+		return re.RegisterShaderNoMip( VMA(1) );
+	case CG_R_REGISTERFONT:
+		re.RegisterFont( VMA(1), args[2], VMF(3), args[4], VMA(5));
+		return 0;
+	case CG_R_RENDERSCENE:
+		re.RenderScene( VMA(1) );
 			return 0;
-		case CG_R_RENDERSCENE:
-			re.RenderScene(VMA(1));
-			return 0;
 		case CG_R_CLEARSCENE:
 			re.ClearScene();
 			return 0;
Index: code/client/cl_ui.c
===================================================================
--- code/client/cl_ui.c	(revision 3336)
+++ code/client/cl_ui.c	(working copy)
@@ -841,9 +841,9 @@
 			return re.RegisterShader(VMA(1));
 		case UI_R_REGISTERSHADERNOMIP:
 			return re.RegisterShaderNoMip(VMA(1));
-		case UI_R_REGISTERFONT:
-			re.RegisterFont( VMA(1), args[2], VMA(3));
-			return 0;
+	case UI_R_REGISTERFONT:
+		re.RegisterFont( VMA(1), args[2], VMF(3), args[4], VMA(5));
+		return 0;
 		case UI_R_RENDERSCENE:
 			re.RenderScene(VMA(1));
 			return 0;
Index: code/game/bg_public.h
===================================================================
--- code/game/bg_public.h	(revision 3336)
+++ code/game/bg_public.h	(working copy)
@@ -794,4 +794,5 @@
 
 void	trap_Cmd_ExecuteText( int exec_when, const char *text ); // ui: don't use EXEC_NOW!
 void	trap_Cvar_SetValue( const char *var_name, float value );
+void	trap_R_RegisterFont(const char *fontName, int pointSize, float borderWidth, qboolean forceAutoHint, fontInfo_t *font);
 float	trap_Cvar_VariableValue( const char *var_name );
Index: code/qcommon/q_shared.h
===================================================================
--- code/qcommon/q_shared.h	(revision 3336)
+++ code/qcommon/q_shared.h	(working copy)
@@ -1386,7 +1386,7 @@
 typedef struct {
   int height;       // number of scan lines
   int top;          // top of glyph in buffer
-  int bottom;       // bottom of glyph in buffer
+  int left;         // left of glyph in buffer
   int pitch;        // width for copying
   int xSkip;        // x adjustment
   int imageWidth;   // width of actual image
@@ -1399,10 +1399,15 @@
   char shaderName[32];
 } glyphInfo_t;
 
+#define FONTFLAG_CURSORS	0x0001 // font has extra glyphs (notably cursors) like Q3's bigchars font
+#define FONTFLAG_BORDER		0x0002 // font has a border
+
 typedef struct {
   glyphInfo_t glyphs [GLYPHS_PER_FONT];
   float glyphScale;
   char name[MAX_QPATH];
+  int pointSize;
+  int flags;
 } fontInfo_t;
 
 #define Square(x) ((x)*(x))
Index: code/renderercommon/tr_common.h
===================================================================
--- code/renderercommon/tr_common.h	(revision 3336)
+++ code/renderercommon/tr_common.h	(working copy)
@@ -118,6 +118,8 @@
 extern cvar_t *r_stereoEnabled;
 
 extern	cvar_t	*r_saveFontData;
+extern	cvar_t	*r_fontBorderWidth;
+extern	cvar_t	*r_fontForceAutoHint;
 
 qboolean	R_GetModeInfo( int *width, int *height, float *windowAspect, int mode );
 
@@ -138,7 +140,7 @@
 // font stuff
 void R_InitFreeType( void );
 void R_DoneFreeType( void );
-void RE_RegisterFont(const char *fontName, int pointSize, fontInfo_t *font);
+void RE_RegisterFont(const char *fontName, int pointSize, float borderWidth, qboolean forceAutoHint, fontInfo_t *font);
 
 /*
 =============================================================
Index: code/renderercommon/tr_font.c
===================================================================
--- code/renderercommon/tr_font.c	(revision 3336)
+++ code/renderercommon/tr_font.c	(working copy)
@@ -27,28 +27,19 @@
 // about 90% of the cgame presentation. A few areas of the CGAME were left uses the old 
 // fonts since the code is shared with standard Q3A.
 //
-// If you include this font rendering code in a commercial product you MUST include the
-// following somewhere with your product, see www.freetype.org for specifics or changes.
-// The Freetype code also uses some hinting techniques that MIGHT infringe on patents 
-// held by apple so be aware of that also.
-//
-// As of Q3A 1.25+ and Team Arena, we are shipping the game with the font rendering code
-// disabled. This removes any potential patent issues and it keeps us from having to 
+// Q3A 1.25+ and Team Arena were shipped with the font rendering code disabled, there was
+// a patent held by Apple at the time which FreeType MIGHT infringe on.
+// This removed any potential patent issues and it kept us (id Software) from having to 
 // distribute an actual TrueTrype font which is 1. expensive to do and 2. seems to require
-// an act of god to accomplish. 
+// an act of god to accomplish.
 //
 // What we did was pre-render the fonts using FreeType ( which is why we leave the FreeType
 // credit in the credits ) and then saved off the glyph data and then hand touched up the 
 // font bitmaps so they scale a bit better in GL.
 //
-// There are limitations in the way fonts are saved and reloaded in that it is based on 
-// point size and not name. So if you pre-render Helvetica in 18 point and Impact in 18 point
-// you will end up with a single 18 point data file and image set. Typically you will want to 
-// choose 3 sizes to best approximate the scaling you will be doing in the ui scripting system
-// 
 // In the UI Scripting code, a scale of 1.0 is equal to a 48 point font. In Team Arena, we
 // use three or four scales, most of them exactly equaling the specific rendered size. We 
-// rendered three sizes in Team Arena, 12, 16, and 20. 
+// rendered three sizes in Team Arena, 12, 16, and 20.
 //
 // To generate new font data you need to go through the following steps.
 // 1. delete the fontImage_x_xx.tga files and fontImage_xx.dat files from the fonts path.
@@ -58,7 +49,7 @@
 // 4. Exit the game and there will be three dat files and at least three tga files. The 
 //    tga's are in 256x256 pages so if it takes three images to render a 24 point font you 
 //    will end up with fontImage_0_24.tga through fontImage_2_24.tga
-// 5. In future runs of the game, the system looks for these images and data files when a s
+// 5. In future runs of the game, the system looks for these images and data files when a
 //    specific point sized font is rendered and loads them for use. 
 // 6. Because of the original beta nature of the FreeType code you will probably want to hand
 //    touch the font bitmaps.
@@ -78,6 +69,7 @@
 #include FT_SYSTEM_H
 #include FT_IMAGE_H
 #include FT_OUTLINE_H
+#include FT_STROKER_H
 
 #define _FLOOR(x)  ((x) & -64)
 #define _CEIL(x)   (((x)+63) & -64)
@@ -86,11 +78,253 @@
 FT_Library ftLibrary = NULL;  
 #endif
 
-#define MAX_FONTS 6
+#define MAX_FONTS 12
 static int registeredFontCount = 0;
 static fontInfo_t registeredFont[MAX_FONTS];
 
 #ifdef BUILD_FREETYPE
+// A horizontal pixel span generated by the FreeType renderer.
+typedef struct
+{
+	int x, y, width, coverage;
+} Span;
+
+typedef struct
+{
+	int numSpans, maxSpans;
+	Span *spans;
+} SpanList;
+
+void SpanList_Init( SpanList *list ) {
+	list->spans = NULL;
+	list->numSpans = 0;
+	list->maxSpans = 0;
+}
+
+void SpanList_Free( SpanList *list ) {
+	if ( list->spans ) {
+		free( list->spans );
+	}
+	list->spans = NULL;
+	list->numSpans = 0;
+	list->maxSpans = 0;
+}
+
+// Expand list as needed like a C++ std::vector
+void SpanList_Add( SpanList *list, int x, int y, int width, int coverage ) {
+	// First time, allocate initial list size
+	if ( !list->spans ) {
+		list->maxSpans = 1024;
+		list->spans = (Span *)malloc( list->maxSpans * sizeof ( Span ) );
+
+		if ( !list->spans ) {
+			ri.Error( ERR_DROP, "Font rendering out of memory" );
+		}
+	}
+
+	// Ran out of space, expand the list
+	if ( list->numSpans >= list->maxSpans ) {
+		list->maxSpans *= 2;
+		list->spans = (Span *)realloc( list->spans, list->maxSpans * sizeof ( Span ) );
+
+		if ( !list->spans ) {
+			ri.Error( ERR_DROP, "Font rendering out of memory" );
+		}
+	}
+
+	list->spans[list->numSpans].x = x;
+	list->spans[list->numSpans].y = y;
+	list->spans[list->numSpans].width = width;
+	list->spans[list->numSpans].coverage = coverage;
+	list->numSpans++;
+}
+
+
+// Each time the renderer calls us back we just push another span entry on
+// our list.
+void
+RasterCallback(const int y,
+				const int count,
+				const FT_Span * const spans,
+				void * const user)
+{
+	SpanList *list = (SpanList *)user;
+	int i;
+
+	for (i = 0; i < count; ++i) {
+		SpanList_Add(list, spans[i].x, y, spans[i].len, spans[i].coverage);
+	}
+}
+
+
+// Set up the raster parameters and render the outline.
+void
+RenderSpans(FT_Library library,
+			FT_Outline * const outline,
+			SpanList *list)
+{
+	FT_Raster_Params params;
+
+	memset(&params, 0, sizeof(params));
+
+	params.flags = FT_RASTER_FLAG_AA | FT_RASTER_FLAG_DIRECT;
+	params.gray_spans = RasterCallback;
+	params.user = list;
+
+	FT_Outline_Render(library, outline, &params);
+}
+
+/*
+==================
+R_RenderOutlineBitmap
+
+Render an outline glyph with a optional border around it.
+
+This function and the "span" rendering code is based on freetype2 example2.cpp
+by Erik MÃ¶ller, which was released into the public domain.
+==================
+*/
+qboolean R_RenderOutlineBitmap( FT_GlyphSlot glyph, FT_Bitmap *bit2, float borderWidth ) {
+	// Spans for glyph face and border
+	SpanList glyphSpans, borderSpans;
+	// Iterators
+	Span *s;
+	int i, w;
+	unsigned char *dst;
+	// Span bounds
+	int xmin, xmax, ymin, ymax;
+	// Image metrics
+	int imgWidth, imgHeight;
+	// RGB colors
+	unsigned char glyphColor[3] = { 255, 255, 255 };
+	unsigned char borderColor[3] = { 0, 0, 0 };
+
+	// Initialize the span lists
+	SpanList_Init( &glyphSpans );
+	SpanList_Init( &borderSpans );
+
+	// Render the basic glyph to a span list.
+	RenderSpans(ftLibrary, &glyph->outline, &glyphSpans);
+
+	if ( glyphSpans.numSpans == 0 ) {
+		// This happens with space character and maybe others that are invisible.
+		return qfalse;
+	}
+
+	// Next we need the spans for the border.
+	if ( borderWidth > 0 ) {
+		FT_Glyph glyphTemp;
+
+		if (FT_Get_Glyph(glyph, &glyphTemp) == 0)
+		{
+			// This needs to be an outline glyph to work.
+			if (glyphTemp->format == FT_GLYPH_FORMAT_OUTLINE)
+			{
+				FT_Stroker stroker;
+
+				// Set up a stroker.
+				FT_Stroker_New(ftLibrary, &stroker);
+				FT_Stroker_Set(stroker,
+					(int)(borderWidth * 64),
+					FT_STROKER_LINECAP_ROUND,
+					FT_STROKER_LINEJOIN_ROUND,
+					0);
+
+				FT_Glyph_StrokeBorder(&glyphTemp, stroker, 0, 1);
+
+				// Render the border spans to the span list
+				FT_Outline *o = &((FT_OutlineGlyph)(glyphTemp))->outline;
+				RenderSpans(ftLibrary, o, &borderSpans);
+
+				// Clean up afterwards.
+				FT_Stroker_Done(stroker);
+			}
+
+			FT_Done_Glyph(glyphTemp);
+		}
+	}
+
+	// Now we need to put it all together.
+
+	// Figure out what the bounding rect is for both the span lists.
+	xmin = glyphSpans.spans[0].x;
+	xmax = glyphSpans.spans[0].x;
+	ymin = glyphSpans.spans[0].y;
+	ymax = glyphSpans.spans[0].y;
+
+	for (i = 0, s = glyphSpans.spans; i < glyphSpans.numSpans; ++i, ++s)
+	{
+		xmin = MIN(xmin, s->x);
+		xmax = MAX(xmax, s->x);
+
+		ymin = MIN(ymin, s->y);
+		ymax = MAX(ymax, s->y);
+
+		xmin = MIN(xmin, s->x + s->width - 1);
+		xmax = MAX(xmax, s->x + s->width - 1);
+	}
+	for (i = 0, s = borderSpans.spans; i < borderSpans.numSpans; ++i, ++s)
+	{
+		xmin = MIN(xmin, s->x);
+		xmax = MAX(xmax, s->x);
+
+		ymin = MIN(ymin, s->y);
+		ymax = MAX(ymax, s->y);
+
+		xmin = MIN(xmin, s->x + s->width - 1);
+		xmax = MAX(xmax, s->x + s->width - 1);
+	}
+
+	// Get some metrics of our image.
+	imgWidth = xmax - xmin + 1;
+	imgHeight = ymax - ymin + 1;
+
+	// Allocate data for our image and clear it out to transparent.
+	bit2->width      = imgWidth;
+	bit2->rows       = imgHeight;
+	bit2->pitch      = imgWidth*4;
+	bit2->pixel_mode = FT_PIXEL_MODE_BGRA;
+	bit2->buffer     = ri.Malloc(bit2->pitch*bit2->rows);
+
+	Com_Memset( bit2->buffer, 0, bit2->pitch*bit2->rows );
+
+	// Loop over the border spans and just draw them into the image.
+	for (i = 0, s = borderSpans.spans; i < borderSpans.numSpans; ++i, ++s)
+	{
+		dst = &bit2->buffer[(int)((imgHeight - 1 - (s->y - ymin)) * bit2->pitch + (s->x - xmin/* + w*/) * 4)];
+
+		for (w = 0; w < s->width; ++w, dst += 4)
+		{
+			// Flip border color RGB to BGR
+			dst[0] = borderColor[2];
+			dst[1] = borderColor[1];
+			dst[2] = borderColor[0];
+			dst[3] = s->coverage;
+		}
+	}
+
+	// Then loop over the regular glyph spans and blend them into the image.
+	for (i = 0, s = glyphSpans.spans; i < glyphSpans.numSpans; ++i, ++s)
+	{
+		dst = &bit2->buffer[(int)((imgHeight - 1 - (s->y - ymin)) * bit2->pitch + (s->x - xmin/* + w*/) * 4)];
+
+		for (w = 0; w < s->width; ++w, dst += 4)
+		{
+			// Flip glyph color RGB to BGR
+			dst[0] = (int)(dst[0] + ((glyphColor[2] - dst[0]) * s->coverage) / 255.0f);
+			dst[1] = (int)(dst[1] + ((glyphColor[1] - dst[1]) * s->coverage) / 255.0f);
+			dst[2] = (int)(dst[2] + ((glyphColor[0] - dst[2]) * s->coverage) / 255.0f);
+			dst[3] = MIN(255, dst[3] + s->coverage);
+		}
+	}
+
+	SpanList_Free( &glyphSpans );
+	SpanList_Free( &borderSpans );
+
+	return qtrue;
+}
+
+
 void R_GetGlyphInfo(FT_GlyphSlot glyph, int *left, int *right, int *width, int *top, int *bottom, int *height, int *pitch) {
 	*left  = _FLOOR( glyph->metrics.horiBearingX );
 	*right = _CEIL( glyph->metrics.horiBearingX + glyph->metrics.width );
@@ -103,24 +337,44 @@
 }
 
 
-FT_Bitmap *R_RenderGlyph(FT_GlyphSlot glyph, glyphInfo_t* glyphOut) {
+FT_Bitmap *R_RenderGlyph(FT_GlyphSlot glyph, glyphInfo_t* glyphOut, float borderWidth) {
 	FT_Bitmap  *bit2;
 	int left, right, width, top, bottom, height, pitch, size;
+	int borderSizeX, borderSizeY;
 
 	R_GetGlyphInfo(glyph, &left, &right, &width, &top, &bottom, &height, &pitch);
 
-	if ( glyph->format == ft_glyph_format_outline ) {
-		size   = pitch*height; 
-
+	if ( glyph->format == FT_GLYPH_FORMAT_OUTLINE ) {
 		bit2 = ri.Malloc(sizeof(FT_Bitmap));
+		bit2->buffer = NULL;
 
+		// ZTM: FIXME: Why is R_RenderOutlineBitmap with borderWidth == 0 different than FT_Outline_Get_Bitmap?
+		if ( borderWidth != 0 && R_RenderOutlineBitmap( glyph, bit2, borderWidth ) ) {
+			// check how much the border increased the size of the glyph
+			borderSizeX = bit2->width - width;
+			borderSizeY = bit2->rows - height;
+
+			glyphOut->height = bit2->rows;
+			glyphOut->pitch = bit2->pitch;
+
+			glyphOut->top = _TRUNC(glyph->metrics.horiBearingY) + borderSizeY / 2;// + 1;
+			glyphOut->left = _TRUNC(glyph->metrics.horiBearingX) - borderSizeX / 2;// + 1;
+			glyphOut->xSkip = _TRUNC(glyph->metrics.horiAdvance) + borderSizeX / 2;// + 1;
+
+			return bit2;
+		}
+
+		// If not able to load the glyph by rendering spans, fallback to original Q3 method.
+		// This fixes 'space' (character 32) not having xSkip.
+
+		size             = pitch*height;
 		bit2->width      = width;
 		bit2->rows       = height;
 		bit2->pitch      = pitch;
-		bit2->pixel_mode = ft_pixel_mode_grays;
-		//bit2->pixel_mode = ft_pixel_mode_mono;
-		bit2->buffer     = ri.Malloc(pitch*height);
-		bit2->num_grays = 256;
+		bit2->pixel_mode = FT_PIXEL_MODE_GRAY;
+		//bit2->pixel_mode = FT_PIXEL_MODE_MONO;
+		bit2->buffer     = ri.Malloc( size );
+		bit2->num_grays  = 256;
 
 		Com_Memset( bit2->buffer, 0, size );
 
@@ -130,17 +384,30 @@
 
 		glyphOut->height = height;
 		glyphOut->pitch = pitch;
-		glyphOut->top = (glyph->metrics.horiBearingY >> 6) + 1;
-		glyphOut->bottom = bottom;
 
+		glyphOut->top = _TRUNC(glyph->metrics.horiBearingY);// + 1;
+		glyphOut->left = _TRUNC(glyph->metrics.horiBearingX);// + 1;
+
+		glyphOut->xSkip = _TRUNC(glyph->metrics.horiAdvance);// + 1;
+
 		return bit2;
-	} else {
-		ri.Printf(PRINT_ALL, "Non-outline fonts are not supported\n");
+	} else if ( glyph->format == FT_GLYPH_FORMAT_BITMAP ) {
+		glyphOut->height = height;
+		glyphOut->pitch = pitch;
+
+		glyphOut->top = _TRUNC(glyph->metrics.horiBearingY);// + 1;
+		glyphOut->left = _TRUNC(glyph->metrics.horiBearingX);// + 1;
+
+		glyphOut->xSkip = _TRUNC(glyph->metrics.horiAdvance);// + 1;
+
+		return &glyph->bitmap;
+	} else if ( glyph->format != FT_GLYPH_FORMAT_NONE ) {
+		ri.Printf( PRINT_ALL, "Only outline and bitmap font glyphs are supported\n" );
 	}
 	return NULL;
 }
 
-void WriteTGA (char *filename, byte *data, int width, int height) {
+static void WriteTGA (char *filename, byte *data, int width, int height) {
 	byte			*buffer;
 	int				i, c;
 	int             row;
@@ -188,77 +455,77 @@
 	ri.Free (buffer);
 }
 
-static glyphInfo_t *RE_ConstructGlyphInfo(unsigned char *imageOut, int *xOut, int *yOut, int *maxHeight, FT_Face face, const unsigned char c, qboolean calcHeight) {
-	int i;
+// returns NULL if glyph does not fit in image
+static glyphInfo_t *RE_ConstructGlyphInfo(const char *fontName, int imageSize, unsigned char *imageOut, int *xOut, int *yOut, int *rowHeight, FT_Face face, unsigned long c, float borderWidth, qboolean forceAutoHint) {
+	int i, loadFlags;
 	static glyphInfo_t glyph;
 	unsigned char *src, *dst;
-	float scaled_width, scaled_height;
 	FT_Bitmap *bitmap = NULL;
 
 	Com_Memset(&glyph, 0, sizeof(glyphInfo_t));
 	// make sure everything is here
 	if (face != NULL) {
-		FT_Load_Glyph(face, FT_Get_Char_Index( face, c), FT_LOAD_DEFAULT );
-		bitmap = R_RenderGlyph(face->glyph, &glyph);
-		if (bitmap) {
-			glyph.xSkip = (face->glyph->metrics.horiAdvance >> 6) + 1;
-		} else {
-			return &glyph;
+		loadFlags = FT_LOAD_DEFAULT | FT_LOAD_COLOR;
+
+		if ( forceAutoHint ) {
+			loadFlags |= FT_LOAD_FORCE_AUTOHINT;
 		}
 
-		if (glyph.height > *maxHeight) {
-			*maxHeight = glyph.height;
+		FT_Load_Glyph( face, FT_Get_Char_Index( face, c ), loadFlags );
+		bitmap = R_RenderGlyph(face->glyph, &glyph, borderWidth);
+		if (!bitmap) {
+			return &glyph;
 		}
 
-		if (calcHeight) {
-			ri.Free(bitmap->buffer);
-			ri.Free(bitmap);
+		if (bitmap->pixel_mode != FT_PIXEL_MODE_MONO && bitmap->pixel_mode != FT_PIXEL_MODE_GRAY && bitmap->pixel_mode != FT_PIXEL_MODE_BGRA) {
+			ri.Printf(PRINT_WARNING, "RE_ConstructGlyphInfo: Unknown pixel format 0x%X for codepoint 0x%lX in '%s'\n", bitmap->pixel_mode, c, fontName);
+			if (bitmap != &face->glyph->bitmap) {
+				ri.Free(bitmap->buffer);
+				ri.Free(bitmap);
+			}
 			return &glyph;
 		}
 
-/*
-		// need to convert to power of 2 sizes so we do not get 
-		// any scaling from the gl upload
-		for (scaled_width = 1 ; scaled_width < glyph.pitch ; scaled_width<<=1)
-			;
-		for (scaled_height = 1 ; scaled_height < glyph.height ; scaled_height<<=1)
-			;
-*/
-
-		scaled_width = glyph.pitch;
-		scaled_height = glyph.height;
-
 		// we need to make sure we fit
-		if (*xOut + scaled_width + 1 >= 255) {
+		if (*xOut + bitmap->width + 1 >= imageSize-1) {
 			*xOut = 0;
-			*yOut += *maxHeight + 1;
+			*yOut += *rowHeight + 1;
+			*rowHeight = 0;
 		}
 
-		if (*yOut + *maxHeight + 1 >= 255) {
-			*yOut = -1;
-			*xOut = -1;
-			ri.Free(bitmap->buffer);
-			ri.Free(bitmap);
-			return &glyph;
+		if (*yOut + bitmap->rows + 1 >= imageSize-1) {
+			if (bitmap != &face->glyph->bitmap) {
+				ri.Free(bitmap->buffer);
+				ri.Free(bitmap);
+			}
+			return NULL;
 		}
 
+		// reserve vertical space in image
+		if (bitmap->rows > *rowHeight) {
+			*rowHeight = bitmap->rows;
+		}
 
+		// convert glyph image into a 32 bit RGBA image
 		src = bitmap->buffer;
-		dst = imageOut + (*yOut * 256) + *xOut;
+		dst = imageOut + (*yOut * imageSize * 4) + *xOut * 4;
 
-		if (bitmap->pixel_mode == ft_pixel_mode_mono) {
-			for (i = 0; i < glyph.height; i++) {
+		if (bitmap->pixel_mode == FT_PIXEL_MODE_MONO) {
+			for (i = 0; i < bitmap->rows; i++) {
 				int j;
 				unsigned char *_src = src;
 				unsigned char *_dst = dst;
 				unsigned char mask = 0x80;
 				unsigned char val = *_src;
-				for (j = 0; j < glyph.pitch; j++) {
+				for (j = 0; j < bitmap->width; j++) {
 					if (mask == 0x80) {
 						val = *_src++;
 					}
 					if (val & mask) {
-						*_dst = 0xff;
+						_dst[0] = 0xff;
+						_dst[1] = 0xff;
+						_dst[2] = 0xff;
+						_dst[3] = 0xff;
 					}
 					mask >>= 1;
 
@@ -265,34 +532,58 @@
 					if ( mask == 0 ) {
 						mask = 0x80;
 					}
-					_dst++;
+					_dst += 4;
 				}
 
-				src += glyph.pitch;
-				dst += 256;
+				src += bitmap->pitch;
+				dst += imageSize * 4;
 			}
-		} else {
-			for (i = 0; i < glyph.height; i++) {
-				Com_Memcpy(dst, src, glyph.pitch);
-				src += glyph.pitch;
-				dst += 256;
+		} else if (bitmap->pixel_mode == FT_PIXEL_MODE_GRAY) {
+			for (i = 0; i < bitmap->rows; i++) {
+				int j;
+				unsigned char *_src = src;
+				unsigned char *_dst = dst;
+				for ( j = 0; j < bitmap->width; j++ ) {
+					_dst[0] = 255;
+					_dst[1] = 255;
+					_dst[2] = 255;
+					_dst[3] = *_src++;
+					_dst += 4;
+				}
+				src += bitmap->pitch;
+				dst += imageSize * 4;
 			}
+		} else if (bitmap->pixel_mode == FT_PIXEL_MODE_BGRA) {
+			// swap BGRA src to RGBA dst
+			for (i = 0; i < bitmap->rows; i++) {
+				int j;
+				unsigned char *_src = src;
+				unsigned char *_dst = dst;
+				for ( j = 0; j < bitmap->width; j++ ) {
+					_dst[0] = _src[2];	// red
+					_dst[1] = _src[1];	// green
+					_dst[2] = _src[0];	// blue
+					_dst[3] = _src[3];	// alpha
+					_src += 4;
+					_dst += 4;
+				}
+				src += bitmap->pitch;
+				dst += imageSize * 4;
+			}
 		}
 
-		// we now have an 8 bit per pixel grey scale bitmap 
-		// that is width wide and pf->ftSize->metrics.y_ppem tall
+		// store the pixel values in texture coords until the image height is known
+		glyph.s = *xOut;
+		glyph.t = *yOut;
+		glyph.imageWidth = bitmap->width;
+		glyph.imageHeight = bitmap->rows;
 
-		glyph.imageHeight = scaled_height;
-		glyph.imageWidth = scaled_width;
-		glyph.s = (float)*xOut / 256;
-		glyph.t = (float)*yOut / 256;
-		glyph.s2 = glyph.s + (float)scaled_width / 256;
-		glyph.t2 = glyph.t + (float)scaled_height / 256;
+		*xOut += bitmap->width + 1;
 
-		*xOut += scaled_width + 1;
-
-		ri.Free(bitmap->buffer);
-		ri.Free(bitmap);
+		if (bitmap != &face->glyph->bitmap) {
+			ri.Free(bitmap->buffer);
+			ri.Free(bitmap);
+		}
 	}
 
 	return &glyph;
@@ -329,126 +620,288 @@
 	fdOffset += 4;
 	return me.ffred;
 }
-
-void RE_RegisterFont(const char *fontName, int pointSize, fontInfo_t *font) {
 #ifdef BUILD_FREETYPE
-	FT_Face face;
-	int j, k, xOut, yOut, lastStart, imageNumber;
-	int scaledSize, newSize, maxHeight, left;
-	unsigned char *out, *imageBuff;
-	glyphInfo_t *glyph;
-	image_t *image;
-	qhandle_t h;
-	float max;
-	float dpi = 72;
-	float glyphScale;
-#endif
-	void *faceData;
-	int i, len;
-	char name[1024];
+// Q3A's gfx/2d/bigchars some additional symbols, by default these glyphs would just be default missing glyph anyway
+unsigned long R_RemapGlyphCharacter( FT_Face face, int charIndex ) {
+	switch ( charIndex ) {
+		// thick box drawing characters
+		// - top
+		case 1:
+			return 0x2554; // box drawings double down and right
+		case 2:
+			return 0x2550; // box drawings double horizontal
+		case 3:
+			return 0x2557; // box drawings double down and left
+		// - middle
+		case 4:
+			return 0x2551; // box drawings double vertical
+		case 5:
+			return ' '; // blank
+		case 6:
+			return 0x2551; // box drawings double vertical
+		// - bottom
+		case 7:
+			return 0x255A; // box drawings double up and right
+		case 8:
+			return 0x2550; // box drawings double horizontal
+		case 9:
+			return 0x255D; // box drawings double up and left
 
-	if (!fontName) {
-		ri.Printf(PRINT_ALL, "RE_RegisterFont: called with empty name\n");
-		return;
-	}
+		//
+		// cursors
+		//
+		case 10:
+			return 0xFF3F; // full width low line (underline)
+		case 11:
+			return 0x2588; // full block
+		case 13:
+			// Many fonts have up/down pointing triangle but matching left/right triangle
+			// are in slot for pointer. So if triangle is missing fallback to pointer.
+			if ( FT_Get_Char_Index( face, 0x25B6 ) != 0 ) {
+				return 0x25B6; // black right-pointing triangle
+			}
+			return 0x25BA; // black right-pointing pointer
 
-	if (pointSize <= 0) {
-		pointSize = 12;
-	}
+		//
+		// misc
+		//
+		case 16:
+			return 0x301A; // left white square bracket
+		case 17:
+			return 0x301B; // right white square bracket
 
-	R_IssuePendingRenderCommands();
+		// thin box drawing characters
+		// - top
+		case 18:
+			return 0x250C; // box drawings light down and right
+		case 19:
+			return 0x2500; // box drawings light horizontal
+		case 20:
+			return 0x2510; // box drawings light down and left
+		// - middle
+		case 21:
+			return 0x2502; // box drawings light vertical
+		case 22:
+			return ' '; // blank
+		case 23:
+			return 0x2502; // box drawings light vertical
+		// - bottom
+		case 24:
+			return 0x2514; // box drawings light up and right
+		case 25:
+			return 0x2500; // box drawings light horizontal
+		case 26:
+			return 0x2518; // box drawings light up and left
 
-	if (registeredFontCount >= MAX_FONTS) {
-		ri.Printf(PRINT_WARNING, "RE_RegisterFont: Too many fonts registered already.\n");
-		return;
-	}
+		//
+		// misc
+		//
+		case 27:
+			return 0xFFE3; // full width macron (overline)
 
-	Com_sprintf(name, sizeof(name), "fonts/fontImage_%i.dat",pointSize);
-	for (i = 0; i < registeredFontCount; i++) {
-		if (Q_stricmp(name, registeredFont[i].name) == 0) {
-			Com_Memcpy(font, &registeredFont[i], sizeof(fontInfo_t));
-			return;
-		}
-	}
+		// horzontal bar
+		case 29:
+			return 0x2576; // box drawings light right
+		case 30:
+			return 0x2500; // box drawings light horizontal
+		case 31:
+			return 0x2574; // box drawings light left
 
-	len = ri.FS_ReadFile(name, NULL);
-	if (len == sizeof(fontInfo_t)) {
-		ri.FS_ReadFile(name, &faceData);
-		fdOffset = 0;
-		fdFile = faceData;
-		for(i=0; i<GLYPHS_PER_FONT; i++) {
-			font->glyphs[i].height		= readInt();
-			font->glyphs[i].top			= readInt();
-			font->glyphs[i].bottom		= readInt();
-			font->glyphs[i].pitch		= readInt();
-			font->glyphs[i].xSkip		= readInt();
-			font->glyphs[i].imageWidth	= readInt();
-			font->glyphs[i].imageHeight = readInt();
-			font->glyphs[i].s			= readFloat();
-			font->glyphs[i].t			= readFloat();
-			font->glyphs[i].s2			= readFloat();
-			font->glyphs[i].t2			= readFloat();
-			font->glyphs[i].glyph		= readInt();
-			Q_strncpyz(font->glyphs[i].shaderName, (const char *)&fdFile[fdOffset], sizeof(font->glyphs[i].shaderName));
-			fdOffset += sizeof(font->glyphs[i].shaderName);
-		}
-		font->glyphScale = readFloat();
-		Com_Memcpy(font->name, &fdFile[fdOffset], MAX_QPATH);
+		case 127:
+			return 0x2B05; // leftward black arrow
 
-//		Com_Memcpy(font, faceData, sizeof(fontInfo_t));
-		Q_strncpyz(font->name, name, sizeof(font->name));
-		for (i = GLYPH_START; i <= GLYPH_END; i++) {
-			font->glyphs[i].glyph = RE_RegisterShaderNoMip(font->glyphs[i].shaderName);
-		}
-		Com_Memcpy(&registeredFont[registeredFontCount++], font, sizeof(fontInfo_t));
-		ri.FS_FreeFile(faceData);
-		return;
+		// old slider bar characters
+		case 128:
+			return 0x255E; // box drawings vertical single and right double
+		case 129:
+			return 0x2550; // box drawings double horizontal
+		case 130:
+			return 0x2561; // box drawings vertical single and left double
+
+		// 131 is a half width block but unicode doesn't seem to have one that doesn't include space on left or right side
+		// 132 is a transparent square
+
+		case 134:
+			return 0x25BC; // black down-pointing triangle
+		case 135:
+			return 0x25B2; // black up-pointing triangle
+		case 136:
+			// Many fonts have up/down pointing triangle but matching left/right triangle
+			// are in slot for pointer. So if triangle is missing fallback to pointer.
+			if ( FT_Get_Char_Index( face, 0x25C0 ) != 0 ) {
+				return 0x25C0; // black left-pointing triangle
+			}
+			return 0x25C4; // black left-pointing pointer
+
+		case 139: // same as index 11
+			return 0x2588; // full block
+
+		case 141: // same as index 13
+			// Many fonts have up/down pointing triangle but matching left/right triangle
+			// are in slot for pointer. So if triangle is missing fallback to pointer.
+			if ( FT_Get_Char_Index( face, 0x25B6 ) != 0 ) {
+				return 0x25B6; // black right-pointing triangle
+			}
+			return 0x25BA; // black right-pointing pointer
+
+		default:
+			break;
 	}
 
-#ifndef BUILD_FREETYPE
-	ri.Printf(PRINT_WARNING, "RE_RegisterFont: FreeType code not available\n");
-#else
+	return charIndex;
+}
+
+/*
+===============
+R_LoadDynamicFont
+
+Load an outline/bitmap font using Freetype for the current game window resolution.
+===============
+*/
+qboolean R_LoadDynamicFont( const char *fontName, int pointSize, float borderWidth, qboolean forceAutoHint, fontInfo_t *font ) {
+	FT_Face		face;
+	int			j, k, xOut, yOut, lastStart, imageNumber;
+	int			scaledSize, rowHeight;
+	unsigned char *out;
+	glyphInfo_t *glyph;
+	image_t		*image;
+	qhandle_t	h;
+	float		max;
+	int			imageSize;
+	float		dpi;
+	float		glyphScale;
+	void		*faceData;
+	int			i, len;
+	char		imageName[MAX_QPATH];
+	char		datName[MAX_QPATH];
+	char		strippedName[MAX_QPATH];
+	float		windowScale;
+	int			saveHeight;
+
 	if (ftLibrary == NULL) {
 		ri.Printf(PRINT_WARNING, "RE_RegisterFont: FreeType not initialized.\n");
-		return;
+		return qfalse;
 	}
 
+	COM_StripExtension( fontName, strippedName, sizeof ( strippedName ) );
+
+	if (registeredFontCount >= MAX_FONTS) {
+		len = ri.FS_ReadFile(fontName, NULL);
+		if (len <= 0) {
+			ri.Printf(PRINT_DEVELOPER, "RE_RegisterFont: Unable to read font file '%s'\n", fontName);
+		} else {
+			ri.Printf(PRINT_WARNING, "RE_RegisterFont: No free slot to load font file '%s'\n", fontName);
+		}
+		return qfalse;
+	}
+
 	len = ri.FS_ReadFile(fontName, &faceData);
-	if (len <= 0) {
-		ri.Printf(PRINT_WARNING, "RE_RegisterFont: Unable to read font file '%s'\n", fontName);
-		return;
+	if (!faceData) {
+		ri.Printf(PRINT_DEVELOPER, "RE_RegisterFont: Unable to read font file '%s'\n", fontName);
+		return qfalse;
 	}
 
 	// allocate on the stack first in case we fail
 	if (FT_New_Memory_Face( ftLibrary, faceData, len, 0, &face )) {
 		ri.Printf(PRINT_WARNING, "RE_RegisterFont: FreeType, unable to allocate new face.\n");
-		return;
+		ri.FS_FreeFile(faceData);
+		return qfalse;
 	}
 
+	FT_Select_Charmap( face, ft_encoding_unicode );
 
+	// point sizes are for a virtual 640x480 window
+	if ( glConfig.vidWidth * 480 > glConfig.vidHeight * 640 ) {
+		windowScale = glConfig.vidHeight / 480.0f;
+	} else {
+		windowScale = glConfig.vidWidth / 640.0f;
+	}
+
+	// scale dpi based on window resolution
+	dpi = 72.0f * windowScale;
+
+	// change the scale to be relative to 1 based on 72 dpi ( so dpi of 144 means a scale of .5 )
+	glyphScale = 72.0f / dpi;
+
 	if (FT_Set_Char_Size( face, pointSize << 6, pointSize << 6, dpi, dpi)) {
-		ri.Printf(PRINT_WARNING, "RE_RegisterFont: FreeType, unable to set face char size.\n");
-		return;
+		if (face->num_fixed_sizes > 0) {
+			FT_Pos	desired_y_ppem, largerDiff, smallerDiff, diff;
+			int		largerSize, smallerSize, selectSize;
+
+			desired_y_ppem = (FT_Pos)(pointSize*windowScale) << 6;
+			largerSize = smallerSize = -1;
+			largerDiff = smallerDiff = -1;
+
+			// choose closest size; prefer larger closest size.
+			for (i = 0; i < face->num_fixed_sizes; i++) {
+				ri.Printf(PRINT_DEVELOPER, "RE_RegisterFont: Bitmap size %d: %dx%d (y_ppem: %ld) in '%s'\n",
+						i, face->available_sizes[i].height, face->available_sizes[i].width, (long)face->available_sizes[i].y_ppem>>6, fontName );
+
+				diff = abs( face->available_sizes[i].y_ppem - desired_y_ppem );
+
+				if ( face->available_sizes[i].y_ppem < desired_y_ppem ) {
+					if ( smallerDiff == -1 || diff < smallerDiff ) {
+						smallerDiff = diff;
+						smallerSize = i;
+					}
+				} else {
+					if ( largerDiff == -1 || diff < largerDiff ) {
+						largerDiff = diff;
+						largerSize = i;
+					}
+				}
+			}
+
+			if ( largerSize != -1 ) {
+				selectSize = largerSize;
+			} else if ( smallerSize != -1 ) {
+				selectSize = smallerSize;
+			} else {
+				selectSize = 0;
+			}
+
+			glyphScale = (pointSize<<6) / (float)face->available_sizes[selectSize].y_ppem;
+
+			ri.Printf(PRINT_DEVELOPER, "RE_RegisterFont: Using bitmap strike size %d (%dx%d, y_ppem: %ld) from %s (target y_ppem %ld)\n",
+					selectSize, face->available_sizes[selectSize].height, face->available_sizes[selectSize].width, (long)face->available_sizes[selectSize].y_ppem>>6, fontName, desired_y_ppem>>6);
+
+			if (FT_Select_Size(face, selectSize)) {
+				ri.Printf(PRINT_WARNING, "RE_RegisterFont: FreeType, unable to select size for %s.\n", fontName);
+				FT_Done_Face(face);
+				ri.FS_FreeFile(faceData);
+				return qfalse;
+			}
+		} else {
+			ri.Printf(PRINT_WARNING, "RE_RegisterFont: FreeType, unable to set face char size for %s.\n", fontName);
+			FT_Done_Face(face);
+			ri.FS_FreeFile(faceData);
+			return qfalse;
+		}
 	}
 
 	//*font = &registeredFonts[registeredFontCount++];
 
+	// scale image size based on screen height, use the next higher power of two
+	for (imageSize = 256; imageSize < 256.0f * dpi / 72.0f; imageSize<<=1);
+
+	// do not exceed maxTextureSize
+	if (imageSize > glConfig.maxTextureSize) {
+		imageSize = glConfig.maxTextureSize;
+	}
+
 	// make a 256x256 image buffer, once it is full, register it, clean it and keep going 
 	// until all glyphs are rendered
 
-	out = ri.Malloc(256*256);
+	out = ri.Malloc(imageSize*imageSize*4);
 	if (out == NULL) {
 		ri.Printf(PRINT_WARNING, "RE_RegisterFont: ri.Malloc failure during output image creation.\n");
-		return;
+		FT_Done_Face(face);
+		ri.FS_FreeFile(faceData);
+		return qfalse;
 	}
-	Com_Memset(out, 0, 256*256);
+	Com_Memset(out, 0, imageSize*imageSize*4);
 
-	maxHeight = 0;
-
-	for (i = GLYPH_START; i <= GLYPH_END; i++) {
-		RE_ConstructGlyphInfo(out, &xOut, &yOut, &maxHeight, face, (unsigned char)i, qtrue);
-	}
-
+	rowHeight = 0;
 	xOut = 0;
 	yOut = 0;
 	i = GLYPH_START;
@@ -459,24 +912,22 @@
 
 		if ( i == GLYPH_END + 1 ) {
 			// upload/save current image buffer
-			xOut = yOut = -1;
+			glyph = NULL;
 		} else {
-			glyph = RE_ConstructGlyphInfo(out, &xOut, &yOut, &maxHeight, face, (unsigned char)i, qfalse);
+			glyph = RE_ConstructGlyphInfo(fontName, imageSize, out, &xOut, &yOut, &rowHeight, face, R_RemapGlyphCharacter( face, i ), borderWidth, forceAutoHint);
 		}
 
-		if (xOut == -1 || yOut == -1)  {
+		if (!glyph)  {
 			// ran out of room
 			// we need to create an image from the bitmap, set all the handles in the glyphs to this point
 			// 
 
-			scaledSize = 256*256;
-			newSize = scaledSize * 4;
-			imageBuff = ri.Malloc(newSize);
-			left = 0;
+			// scale alpha
+			scaledSize = imageSize*imageSize*4;
 			max = 0;
-			for ( k = 0; k < (scaledSize) ; k++ ) {
-				if (max < out[k]) {
-					max = out[k];
+			for ( k = 0; k < scaledSize; k += 4 ) {
+				if (max < out[k+3]) {
+					max = out[k+3];
 				}
 			}
 
@@ -484,31 +935,46 @@
 				max = 255/max;
 			}
 
-			for ( k = 0; k < (scaledSize) ; k++ ) {
-				imageBuff[left++] = 255;
-				imageBuff[left++] = 255;
-				imageBuff[left++] = 255;
+			for ( k = 0; k < scaledSize; k += 4 ) {
+				out[k+3] = ((float)out[k+3] * max);
+			}
 
-				imageBuff[left++] = ((float)out[k] * max);
+			// make sure last row doesn't get cut off when reducing image height
+			yOut += rowHeight + 1;
+
+			// check if image height can be reduced to a lower power of two
+			for ( saveHeight = 1; saveHeight < yOut; saveHeight <<= 1 );
+
+			if ( saveHeight > imageSize ) {
+				saveHeight = imageSize;
 			}
 
-			Com_sprintf (name, sizeof(name), "fonts/fontImage_%i_%i.tga", imageNumber++, pointSize);
-			if (r_saveFontData->integer) { 
-				WriteTGA(name, imageBuff, 256, 256);
+			if ( borderWidth != 0 ) {
+				Com_sprintf(imageName, sizeof(imageName), "%s_%i_%i_b%g.tga", strippedName, imageNumber++, pointSize, borderWidth);
+			} else {
+				Com_sprintf(imageName, sizeof(imageName), "%s_%i_%i.tga", strippedName, imageNumber++, pointSize);
 			}
+			if(r_saveFontData->integer && !ri.FS_FileExists(imageName)) {
+				WriteTGA(imageName, out, imageSize, saveHeight);
+			}
 
-			//Com_sprintf (name, sizeof(name), "fonts/fontImage_%i_%i", imageNumber++, pointSize);
-			image = R_CreateImage(name, imageBuff, 256, 256, IMGTYPE_COLORALPHA, IMGFLAG_CLAMPTOEDGE, 0 );
-			h = RE_RegisterShaderFromImage(name, LIGHTMAP_2D, image, qfalse);
+			image = R_CreateImage(imageName, out, imageSize, saveHeight, IMGTYPE_COLORALPHA, IMGFLAG_CLAMPTOEDGE|IMGFLAG_MIPMAP, 0 );
+			h = RE_RegisterShaderFromImage(imageName, LIGHTMAP_2D, image, qfalse);
 			for (j = lastStart; j < i; j++) {
 				font->glyphs[j].glyph = h;
-				Q_strncpyz(font->glyphs[j].shaderName, name, sizeof(font->glyphs[j].shaderName));
+				COM_StripExtension(imageName, font->glyphs[j].shaderName, sizeof(font->glyphs[j].shaderName));
+
+				// fill in the texture coords now that image height is known
+				font->glyphs[j].s = (float)font->glyphs[j].s / imageSize;
+				font->glyphs[j].t = (float)font->glyphs[j].t / saveHeight;
+				font->glyphs[j].s2 = font->glyphs[j].s + (float)font->glyphs[j].imageWidth / imageSize;
+				font->glyphs[j].t2 = font->glyphs[j].t + (float)font->glyphs[j].imageHeight / saveHeight;
 			}
 			lastStart = i;
-			Com_Memset(out, 0, 256*256);
+			Com_Memset(out, 0, imageSize*imageSize*4);
 			xOut = 0;
 			yOut = 0;
-			ri.Free(imageBuff);
+			rowHeight = 0;
 			if ( i == GLYPH_END + 1 )
 				i++;
 		} else {
@@ -517,28 +983,153 @@
 		}
 	}
 
-	// change the scale to be relative to 1 based on 72 dpi ( so dpi of 144 means a scale of .5 )
-	glyphScale = 72.0f / dpi;
-
 	// we also need to adjust the scale based on point size relative to 48 points as the ui scaling is based on a 48 point font
 	glyphScale *= 48.0f / pointSize;
 
-	registeredFont[registeredFontCount].glyphScale = glyphScale;
 	font->glyphScale = glyphScale;
+	font->pointSize = pointSize;
+	font->flags = FONTFLAG_CURSORS;
+
+	if ( borderWidth > 0 ) {
+		font->flags |= FONTFLAG_BORDER;
+	}
+
+	if ( borderWidth != 0 ) {
+		Com_sprintf(datName, sizeof(datName), "%s_%i_b%g.dat", strippedName, pointSize, borderWidth);
+	} else {
+		Com_sprintf(datName, sizeof(datName), "%s_%i.dat", strippedName, pointSize);
+	}
+	Q_strncpyz(font->name, datName, sizeof(font->name));
 	Com_Memcpy(&registeredFont[registeredFontCount++], font, sizeof(fontInfo_t));
 
-	if (r_saveFontData->integer) {
-		ri.FS_WriteFile(va("fonts/fontImage_%i.dat", pointSize), font, sizeof(fontInfo_t));
+	if(r_saveFontData->integer && !ri.FS_FileExists(datName)) {
+#if defined Q3_BIG_ENDIAN
+		Com_Printf( S_COLOR_YELLOW "WARNING: Cannot write font data on big endian systems\n" );
+#else
+		// ZTM: FIXME: need to swap for big endian systems
+		ri.FS_WriteFile(datName, font, sizeof(fontInfo_t));
+#endif
 	}
 
 	ri.Free(out);
 
+	FT_Done_Face(face);
 	ri.FS_FreeFile(faceData);
+	return qtrue;
+}
 #endif
+
+/*
+==================
+R_GetFont
+
+Get already registered font or load a dynamic font or a pre-rendered legacy font.
+==================
+*/
+static qboolean R_GetFont(const char *name, int pointSize, float borderWidth, qboolean forceAutoHint, fontInfo_t *font) {
+	int			i;
+	char		strippedName[MAX_QPATH];
+	char		datName[MAX_QPATH];
+#ifdef BUILD_FREETYPE
+	char		altName[MAX_QPATH];
+	char		*fontExts[] = { "ttf", "otf", "ttc", "otc", "fon", NULL };
+	const char	*ext;
+#endif
+
+	COM_StripExtension( name, strippedName, sizeof ( strippedName ) );
+	if ( borderWidth != 0 ) {
+		Com_sprintf( datName, sizeof ( datName ), "%s_%i_b%g.dat", strippedName, pointSize, borderWidth );
+	} else {
+		Com_sprintf( datName, sizeof ( datName ), "%s_%i.dat", strippedName, pointSize );
+	}
+
+	for (i = 0; i < registeredFontCount; i++) {
+		if (Q_stricmp(datName, registeredFont[i].name) == 0) {
+			Com_Memcpy(font, &registeredFont[i], sizeof(fontInfo_t));
+			return qtrue;
+		}
+	}
+
+#ifdef BUILD_FREETYPE
+	ext = COM_GetExtension( name );
+
+	// if there is an extension, check if it's a supported format
+	if ( *ext ) {
+		for ( i = 0; fontExts[i] != NULL; i++ ) {
+			if ( Q_stricmp( ext, fontExts[i] ) != 0 ) {
+				continue;
+			}
+
+			if ( R_LoadDynamicFont( name, pointSize, borderWidth, forceAutoHint, font ) ) {
+				return qtrue;
+			}
+			break;
+		}
+	}
+
+	// fallback to all formats, but don't retry the original extension
+	for ( i = 0; fontExts[i] != NULL; i++ ) {
+		if ( *ext && Q_stricmp( ext, fontExts[i] ) == 0 ) {
+			continue;
+		}
+
+		Com_sprintf( altName, sizeof (altName), "%s.%s", strippedName, fontExts[i] );
+
+		if ( R_LoadDynamicFont( altName, pointSize, borderWidth, forceAutoHint, font ) ) {
+			return qtrue;
+		}
+	}
+#endif
+	return qfalse;
 }
 
+/*
+===============
+RE_RegisterFont
+===============
+*/
+void RE_RegisterFont(const char *fontName, int pointSize, float borderWidth, qboolean forceAutoHint, fontInfo_t *font) {
+	char		strippedName[MAX_QPATH];
 
+	if ( borderWidth < r_fontBorderWidth->value ) {
+		borderWidth = r_fontBorderWidth->value;
+	}
+	if ( r_fontForceAutoHint->integer ) {
+		forceAutoHint = qtrue;
+	}
 
+	if (!fontName) {
+		ri.Printf(PRINT_ALL, "RE_RegisterFont: called with empty name\n");
+		return;
+	}
+
+	if (pointSize <= 0) {
+		pointSize = 12;
+	}
+
+	R_IssuePendingRenderCommands();
+
+	if ( R_GetFont( fontName, pointSize, borderWidth, forceAutoHint, font ) ) {
+		return;
+	}
+
+	COM_StripExtension( fontName, strippedName, sizeof ( strippedName ) );
+
+	// If there is no extension, assume this is loading one of the legacy fonts
+	if( !Q_stricmpn( strippedName, fontName, strlen( fontName ) ) ) {
+		if ( R_GetFont( "fonts/fontImage", pointSize, borderWidth, forceAutoHint, font ) ){
+			return;
+		}
+	}
+
+#ifdef BUILD_FREETYPE
+	ri.Printf( PRINT_DEVELOPER, "RE_RegisterFont: Failed to register font %s.\n", fontName );
+#else
+	ri.Printf( PRINT_DEVELOPER, "RE_RegisterFont: Failed to register font %s (Note: FreeType code is not available).\n", fontName );
+#endif
+}
+
+
 void R_InitFreeType(void) {
 #ifdef BUILD_FREETYPE
 	if (FT_Init_FreeType( &ftLibrary )) {
Index: code/renderercommon/tr_public.h
===================================================================
--- code/renderercommon/tr_public.h	(revision 3336)
+++ code/renderercommon/tr_public.h	(working copy)
@@ -102,7 +102,7 @@
 #ifdef __USEA3D
 	void    (*A3D_RenderGeometry) (void *pVoidA3D, void *pVoidGeom, void *pVoidMat, void *pVoidGeomStatus);
 #endif
-	void	(*RegisterFont)(const char *fontName, int pointSize, fontInfo_t *font);
+	void	(*RegisterFont)(const char *fontName, int pointSize, float borderWidth, qboolean forceAutoHint, fontInfo_t *font);
 	void	(*RemapShader)(const char *oldShader, const char *newShader, const char *offsetTime);
 	qboolean (*GetEntityToken)( char *buffer, int size );
 	qboolean (*inPVS)( const vec3_t p1, const vec3_t p2 );
Index: code/renderergl1/tr_init.c
===================================================================
--- code/renderergl1/tr_init.c	(revision 3336)
+++ code/renderergl1/tr_init.c	(working copy)
@@ -1338,6 +1338,8 @@
 	r_debugSort = ri.Cvar_Get( "r_debugSort", "0", CVAR_CHEAT );
 	r_printShaders = ri.Cvar_Get( "r_printShaders", "0", 0 );
 	r_saveFontData = ri.Cvar_Get( "r_saveFontData", "0", 0 );
+	r_fontBorderWidth = ri.Cvar_Get( "r_fontBorderWidth", "1", 0 );
+	r_fontForceAutoHint = ri.Cvar_Get( "r_fontForceAutoHint", "0", 0 );
 
 	r_nocurves = ri.Cvar_Get ("r_nocurves", "0", CVAR_CHEAT );
 	r_drawworld = ri.Cvar_Get ("r_drawworld", "1", CVAR_CHEAT );
Index: code/renderergl2/tr_init.c
===================================================================
--- code/renderergl2/tr_init.c	(revision 3336)
+++ code/renderergl2/tr_init.c	(working copy)
@@ -1338,6 +1338,8 @@
 	r_debugSort = ri.Cvar_Get( "r_debugSort", "0", CVAR_CHEAT );
 	r_printShaders = ri.Cvar_Get( "r_printShaders", "0", 0 );
 	r_saveFontData = ri.Cvar_Get( "r_saveFontData", "0", 0 );
+	r_fontBorderWidth = ri.Cvar_Get( "r_fontBorderWidth", "1", 0 );
+	r_fontForceAutoHint = ri.Cvar_Get( "r_fontForceAutoHint", "0", 0 );
 
 	r_nocurves = ri.Cvar_Get ("r_nocurves", "0", CVAR_CHEAT );
 	r_drawworld = ri.Cvar_Get ("r_drawworld", "1", CVAR_CHEAT );
Index: code/ui/ui_local.h
===================================================================
--- code/ui/ui_local.h	(revision 3336)
+++ code/ui/ui_local.h	(working copy)
@@ -589,7 +589,6 @@
 int				trap_LAN_ServerStatus( const char *serverAddress, char *serverStatus, int maxLen );
 int				trap_LAN_CompareServers( int source, int sortKey, int sortDir, int s1, int s2 );
 int				trap_MemoryRemaining( void );
-void			trap_R_RegisterFont(const char *pFontname, int pointSize, fontInfo_t *font);
 void			trap_S_StopBackgroundTrack( void );
 void			trap_S_StartBackgroundTrack( const char *intro, const char *loop);
 int				trap_CIN_PlayCinematic( const char *arg0, int xpos, int ypos, int width, int height, int bits);
Index: code/ui/ui_main.c
===================================================================
--- code/ui/ui_main.c	(revision 3336)
+++ code/ui/ui_main.c	(working copy)
@@ -688,7 +688,7 @@
 			if (!PC_String_Parse(handle, &tempStr) || !PC_Int_Parse(handle,&pointSize)) {
 				return qfalse;
 			}
-			trap_R_RegisterFont(tempStr, pointSize, &uiInfo.uiDC.Assets.textFont);
+			trap_R_RegisterFont(tempStr, pointSize, 0, qfalse, &uiInfo.uiDC.Assets.textFont);
 			uiInfo.uiDC.Assets.fontRegistered = qtrue;
 			continue;
 		}
@@ -698,7 +698,7 @@
 			if (!PC_String_Parse(handle, &tempStr) || !PC_Int_Parse(handle,&pointSize)) {
 				return qfalse;
 			}
-			trap_R_RegisterFont(tempStr, pointSize, &uiInfo.uiDC.Assets.smallFont);
+			trap_R_RegisterFont(tempStr, pointSize, 0, qfalse, &uiInfo.uiDC.Assets.smallFont);
 			continue;
 		}
 
@@ -707,7 +707,7 @@
 			if (!PC_String_Parse(handle, &tempStr) || !PC_Int_Parse(handle,&pointSize)) {
 				return qfalse;
 			}
-			trap_R_RegisterFont(tempStr, pointSize, &uiInfo.uiDC.Assets.bigFont);
+			trap_R_RegisterFont(tempStr, pointSize, 0, qfalse, &uiInfo.uiDC.Assets.bigFont);
 			continue;
 		}
 
Index: code/ui/ui_shared.c
===================================================================
--- code/ui/ui_shared.c	(revision 3336)
+++ code/ui/ui_shared.c	(working copy)
@@ -5478,7 +5478,7 @@
 		return qfalse;
 	}
 	if (!DC->Assets.fontRegistered) {
-		DC->registerFont(menu->font, 48, &DC->Assets.textFont);
+		DC->registerFont(menu->font, 48, 0, qfalse, &DC->Assets.textFont);
 		DC->Assets.fontRegistered = qtrue;
 	}
 	return qtrue;
Index: code/ui/ui_shared.h
===================================================================
--- code/ui/ui_shared.h	(revision 3336)
+++ code/ui/ui_shared.h	(working copy)
@@ -333,7 +333,7 @@
   void (*clearScene) ( void );
   void (*addRefEntityToScene) (const refEntity_t *re );
   void (*renderScene) ( const refdef_t *fd );
-  void (*registerFont) (const char *pFontname, int pointSize, fontInfo_t *font);
+  void (*registerFont) (const char *pFontname, int pointSize, float borderWidth, qboolean forceAutoHint, fontInfo_t *font);
   void (*ownerDrawItem) (float x, float y, float w, float h, float text_x, float text_y, int ownerDraw, int ownerDrawFlags, int align, float special, float scale, vec4_t color, qhandle_t shader, int textStyle);
 	float (*getValue) (int ownerDraw);
 	qboolean (*ownerDrawVisible) (int flags);
Index: code/ui/ui_syscalls.c
===================================================================
--- code/ui/ui_syscalls.c	(revision 3336)
+++ code/ui/ui_syscalls.c	(working copy)
@@ -575,8 +575,8 @@
 trap_R_RegisterFont
 =======================================================================================================================================
 */
-void trap_R_RegisterFont(const char *fontName, int pointSize, fontInfo_t *font) {
-	syscall(UI_R_REGISTERFONT, fontName, pointSize, font);
+void trap_R_RegisterFont(const char *fontName, int pointSize, float borderWidth, qboolean forceAutoHint, fontInfo_t *font) {
+	syscall( UI_R_REGISTERFONT, fontName, pointSize, PASSFLOAT( borderWidth ), forceAutoHint, font );
 }
 
 /*
Index: Makefile
===================================================================
--- Makefile	(revision 3336)
+++ Makefile	(working copy)
@@ -192,7 +192,7 @@
 endif
 
 ifndef USE_FREETYPE
-USE_FREETYPE=0
+USE_FREETYPE=1
 endif
 
 ifndef USE_INTERNAL_LIBS
@@ -219,6 +219,10 @@
 USE_INTERNAL_JPEG=$(USE_INTERNAL_LIBS)
 endif
 
+ifndef USE_INTERNAL_FREETYPE
+USE_INTERNAL_FREETYPE=$(USE_INTERNAL_LIBS)
+endif
+
 ifndef USE_LOCAL_HEADERS
 USE_LOCAL_HEADERS=$(USE_INTERNAL_LIBS)
 endif
@@ -263,6 +267,7 @@
 OPUSDIR=$(MOUNT_DIR)/opus-1.3.1
 OPUSFILEDIR=$(MOUNT_DIR)/opusfile-0.11
 ZDIR=$(MOUNT_DIR)/zlib
+FTDIR=$(MOUNT_DIR)/freetype-2.10.1
 Q3ASMDIR=$(MOUNT_DIR)/tools/asm
 LBURGDIR=$(MOUNT_DIR)/tools/lcc/lburg
 Q3CPPDIR=$(MOUNT_DIR)/tools/lcc/cpp
@@ -646,7 +651,9 @@
   RENDERER_LIBS = -lgdi32 -lole32 -static-libgcc
 
   ifeq ($(USE_FREETYPE),1)
-    FREETYPE_CFLAGS = -Ifreetype2
+    ifneq ($(USE_INTERNAL_FREETYPE),1)
+      FREETYPE_CFLAGS = -Ifreetype2
+    endif
   endif
 
   ifeq ($(USE_CURL),1)
@@ -1135,8 +1142,12 @@
 endif
 
 ifeq ($(USE_FREETYPE),1)
-  FREETYPE_CFLAGS ?= $(shell $(PKG_CONFIG) --silence-errors --cflags freetype2 || true)
-  FREETYPE_LIBS ?= $(shell $(PKG_CONFIG) --silence-errors --libs freetype2 || echo -lfreetype)
+  ifeq ($(USE_INTERNAL_FREETYPE),1)
+    FREETYPE_CFLAGS += -I$(FTDIR)/include -DFT2_BUILD_LIBRARY
+  else
+    FREETYPE_CFLAGS ?= $(shell $(PKG_CONFIG) --silence-errors --cflags freetype2 || true)
+    FREETYPE_LIBS ?= $(shell $(PKG_CONFIG) --silence-errors --libs freetype2 || echo -lfreetype)
+  endif
 
   BASE_CFLAGS += -DBUILD_FREETYPE $(FREETYPE_CFLAGS)
   RENDERER_LIBS += $(FREETYPE_LIBS)
@@ -1979,6 +1990,41 @@
     $(B)/renderergl1/jutils.o
 endif
 
+ifeq ($(USE_FREETYPE),1)
+ifneq ($(USE_INTERNAL_FREETYPE),0)
+  FTOBJ += \
+    $(B)/renderergl1/ftbase.o \
+    $(B)/renderergl1/ftbitmap.o \
+    $(B)/renderergl1/ftfntfmt.o \
+    $(B)/renderergl1/ftglyph.o \
+    $(B)/renderergl1/ftinit.o \
+    $(B)/renderergl1/ftlcdfil.o \
+    $(B)/renderergl1/ftstroke.o \
+    $(B)/renderergl1/ftsystem.o \
+	\
+    $(B)/renderergl1/ftbzip2.o \
+    $(B)/renderergl1/ftgzip.o \
+    $(B)/renderergl1/ftlzw.o \
+	\
+    $(B)/renderergl1/autofit.o \
+    $(B)/renderergl1/bdf.o \
+    $(B)/renderergl1/cff.o \
+    $(B)/renderergl1/pcf.o \
+    $(B)/renderergl1/pfr.o \
+    $(B)/renderergl1/psaux.o \
+    $(B)/renderergl1/pshinter.o \
+    $(B)/renderergl1/psnames.o \
+    $(B)/renderergl1/raster.o \
+    $(B)/renderergl1/sfnt.o \
+    $(B)/renderergl1/smooth.o \
+    $(B)/renderergl1/truetype.o \
+    $(B)/renderergl1/type1.o \
+    $(B)/renderergl1/type1cid.o \
+    $(B)/renderergl1/type42.o \
+    $(B)/renderergl1/winfnt.o
+endif
+endif
+
 ifeq ($(ARCH),x86)
   Q3OBJ += \
     $(B)/client/snd_mixa.o \
@@ -2228,26 +2274,26 @@
 		-o $@ $(Q3OBJ) \
 		$(LIBSDLMAIN) $(CLIENT_LIBS) $(LIBS)
 
-$(B)/renderer_opengl1_$(SHLIBNAME): $(Q3ROBJ) $(Q3R1STRINGOBJ) $(JPGOBJ)
+$(B)/renderer_opengl1_$(SHLIBNAME): $(Q3ROBJ) $(Q3R1STRINGOBJ) $(JPGOBJ) $(FTOBJ)
 	$(echo_cmd) "LD $@"
-	$(Q)$(CC) $(CFLAGS) $(SHLIBLDFLAGS) -o $@ $(Q3ROBJ) $(Q3R1STRINGOBJ) $(JPGOBJ) \
+	$(Q)$(CC) $(CFLAGS) $(SHLIBLDFLAGS) -o $@ $(Q3ROBJ) $(Q3R1STRINGOBJ) $(JPGOBJ) $(FTOBJ) \
 		$(THREAD_LIBS) $(LIBSDLMAIN) $(RENDERER_LIBS) $(LIBS)
 
-$(B)/renderer_opengl2_$(SHLIBNAME): $(Q3R2OBJ) $(Q3R2STRINGOBJ) $(JPGOBJ)
+$(B)/renderer_opengl2_$(SHLIBNAME): $(Q3R2OBJ) $(Q3R2STRINGOBJ) $(JPGOBJ) $(FTOBJ)
 	$(echo_cmd) "LD $@"
-	$(Q)$(CC) $(CFLAGS) $(SHLIBLDFLAGS) -o $@ $(Q3R2OBJ) $(Q3R2STRINGOBJ) $(JPGOBJ) \
+	$(Q)$(CC) $(CFLAGS) $(SHLIBLDFLAGS) -o $@ $(Q3R2OBJ) $(Q3R2STRINGOBJ) $(JPGOBJ) $(FTOBJ) \
 		$(THREAD_LIBS) $(LIBSDLMAIN) $(RENDERER_LIBS) $(LIBS)
 else
-$(B)/$(CLIENTBIN)$(FULLBINEXT): $(Q3OBJ) $(Q3ROBJ) $(Q3R1STRINGOBJ) $(JPGOBJ) $(LIBSDLMAIN)
+$(B)/$(CLIENTBIN)$(FULLBINEXT): $(Q3OBJ) $(Q3ROBJ) $(Q3R1STRINGOBJ) $(JPGOBJ) $(FTOBJ) $(LIBSDLMAIN)
 	$(echo_cmd) "LD $@"
 	$(Q)$(CC) $(CLIENT_CFLAGS) $(CFLAGS) $(CLIENT_LDFLAGS) $(LDFLAGS) $(NOTSHLIBLDFLAGS) \
-		-o $@ $(Q3OBJ) $(Q3ROBJ) $(Q3R1STRINGOBJ) $(JPGOBJ) \
+		-o $@ $(Q3OBJ) $(Q3ROBJ) $(Q3R1STRINGOBJ) $(JPGOBJ) $(FTOBJ) \
 		$(LIBSDLMAIN) $(CLIENT_LIBS) $(RENDERER_LIBS) $(LIBS)
 
-$(B)/$(CLIENTBIN)_opengl2$(FULLBINEXT): $(Q3OBJ) $(Q3R2OBJ) $(Q3R2STRINGOBJ) $(JPGOBJ) $(LIBSDLMAIN)
+$(B)/$(CLIENTBIN)_opengl2$(FULLBINEXT): $(Q3OBJ) $(Q3R2OBJ) $(Q3R2STRINGOBJ) $(JPGOBJ) $(FTOBJ) $(LIBSDLMAIN)
 	$(echo_cmd) "LD $@"
 	$(Q)$(CC) $(CLIENT_CFLAGS) $(CFLAGS) $(CLIENT_LDFLAGS) $(LDFLAGS) $(NOTSHLIBLDFLAGS) \
-		-o $@ $(Q3OBJ) $(Q3R2OBJ) $(Q3R2STRINGOBJ) $(JPGOBJ) \
+		-o $@ $(Q3OBJ) $(Q3R2OBJ) $(Q3R2STRINGOBJ) $(JPGOBJ) $(FTOBJ) \
 		$(LIBSDLMAIN) $(CLIENT_LIBS) $(RENDERER_LIBS) $(LIBS)
 endif
 
@@ -2786,7 +2832,67 @@
 $(B)/renderergl2/%.o: $(RGL2DIR)/%.c
 	$(DO_REF_CC)
 
+$(B)/renderergl1/%.o: $(FTDIR)/src/base/%.c
+	$(DO_REF_CC)
 
+$(B)/renderergl1/ftbzip2.o: $(FTDIR)/src/bzip2/ftbzip2.c
+	$(DO_REF_CC)
+
+$(B)/renderergl1/ftgzip.o: $(FTDIR)/src/gzip/ftgzip.c
+	$(DO_REF_CC)
+
+$(B)/renderergl1/ftlzw.o: $(FTDIR)/src/lzw/ftlzw.c
+	$(DO_REF_CC)
+
+$(B)/renderergl1/autofit.o: $(FTDIR)/src/autofit/autofit.c
+	$(DO_REF_CC)
+
+$(B)/renderergl1/bdf.o: $(FTDIR)/src/bdf/bdf.c
+	$(DO_REF_CC)
+
+$(B)/renderergl1/cff.o: $(FTDIR)/src/cff/cff.c
+	$(DO_REF_CC)
+
+$(B)/renderergl1/pcf.o: $(FTDIR)/src/pcf/pcf.c
+	$(DO_REF_CC)
+
+$(B)/renderergl1/pfr.o: $(FTDIR)/src/pfr/pfr.c
+	$(DO_REF_CC)
+
+$(B)/renderergl1/psaux.o: $(FTDIR)/src/psaux/psaux.c
+	$(DO_REF_CC)
+
+$(B)/renderergl1/pshinter.o: $(FTDIR)/src/pshinter/pshinter.c
+	$(DO_REF_CC)
+
+$(B)/renderergl1/psnames.o: $(FTDIR)/src/psnames/psnames.c
+	$(DO_REF_CC)
+
+$(B)/renderergl1/raster.o: $(FTDIR)/src/raster/raster.c
+	$(DO_REF_CC)
+
+$(B)/renderergl1/sfnt.o: $(FTDIR)/src/sfnt/sfnt.c
+	$(DO_REF_CC)
+
+$(B)/renderergl1/smooth.o: $(FTDIR)/src/smooth/smooth.c
+	$(DO_REF_CC)
+
+$(B)/renderergl1/truetype.o: $(FTDIR)/src/truetype/truetype.c
+	$(DO_REF_CC)
+
+$(B)/renderergl1/type1.o: $(FTDIR)/src/type1/type1.c
+	$(DO_REF_CC)
+
+$(B)/renderergl1/type1cid.o: $(FTDIR)/src/cid/type1cid.c
+	$(DO_REF_CC)
+
+$(B)/renderergl1/type42.o: $(FTDIR)/src/type42/type42.c
+	$(DO_REF_CC)
+
+$(B)/renderergl1/winfnt.o: $(FTDIR)/src/winfonts/winfnt.c
+	$(DO_REF_CC)
+
+
 $(B)/ded/%.o: $(ASMDIR)/%.s
 	$(DO_AS)
 
@@ -2910,7 +3016,7 @@
 # MISC
 #############################################################################
 
-OBJ = $(Q3OBJ) $(Q3ROBJ) $(Q3R2OBJ) $(Q3DOBJ) $(JPGOBJ) \
+OBJ = $(Q3OBJ) $(Q3ROBJ) $(Q3R2OBJ) $(Q3DOBJ) $(JPGOBJ) $(FTOBJ) \
   $(MPGOBJ) $(Q3GOBJ) $(Q3CGOBJ) $(MPCGOBJ) $(Q3UIOBJ) $(MPUIOBJ) \
   $(MPGVMOBJ) $(Q3GVMOBJ) $(Q3CGVMOBJ) $(MPCGVMOBJ) $(Q3UIVMOBJ) $(MPUIVMOBJ)
 TOOLSOBJ = $(LBURGOBJ) $(Q3CPPOBJ) $(Q3RCCOBJ) $(Q3LCCOBJ) $(Q3ASMOBJ)
