Index: code/botlib/be_ai_move.c
===================================================================
--- code/botlib/be_ai_move.c	(revision 3357)
+++ code/botlib/be_ai_move.c	(working copy)
@@ -1444,28 +1444,57 @@
 //===========================================================================
 bot_moveresult_t BotTravel_BarrierJump(bot_movestate_t *ms, aas_reachability_t *reach)
 {
-	float dist, speed;
-	vec3_t hordir;
+	float rundist, dist, jumpdist, speed, currentspeed;
+	vec3_t hordir, cmdmove, end, velocity;
 	bot_moveresult_t_cleared( result );
+	aas_clientmove_t move;
 
 	//walk straight to reachability start
 	hordir[0] = reach->start[0] - ms->origin[0];
 	hordir[1] = reach->start[1] - ms->origin[1];
 	hordir[2] = 0;
-	dist = VectorNormalize(hordir);
+	rundist = VectorNormalize(hordir);
+	dist = rundist;
+
+	if (dist > 100) {
+		dist = 100;
+	}
 	//
 	BotCheckBlocked(ms, hordir, qtrue, &result);
+	// get command movement
+	VectorScale(hordir, 400, cmdmove);
+	VectorCopy(ms->velocity, velocity);
+	// start point
+	VectorCopy(reach->end, end);
+
+	AAS_PredictClientMovement(&move, ms->entitynum, end, PRESENCE_NORMAL, qtrue, velocity, cmdmove, 2, 2, 0.1f, SE_HITGROUNDDAMAGE|SE_ENTERLAVA|SE_ENTERSLIME|SE_GAP, 0, qfalse);
+	// reduce the speed if the bot will fall into slime, lava or into a gap
+	if (move.stopevent & (SE_HITGROUNDDAMAGE|SE_ENTERLAVA|SE_ENTERSLIME|SE_GAP)) {
+		if (ms->moveflags & MFL_WALK) {
+			speed = 200;
+		} else {
+			speed = 400 - (200 - (2 * dist));
+		}
+
+		jumpdist = 0.01f;
+	} else {
+		if (ms->moveflags & MFL_WALK) {
+			speed = 200 + (200 - (2 * dist));
+		} else {
+			speed = 400;
+		}
+
+		jumpdist = 0.25f;
+	}
+	// get the current speed
+	currentspeed = DotProduct(ms->velocity, hordir);
 	//if pretty close to the barrier
-	if (dist < 9)
+	if (rundist < (sv_maxbarrier->value + (currentspeed * 1.1)) * jumpdist)
 	{
 		EA_Jump(ms->client);
-	} //end if
-	else
-	{
-		if (dist > 60) dist = 60;
-		speed = 360 - (360 - 6 * dist);
-		EA_Move(ms->client, hordir, speed);
-	} //end else
+	}
+	// elementary action move in direction
+	EA_Move(ms->client, hordir, speed);
 	VectorCopy(hordir, result.movedir);
 	//
 	return result;
