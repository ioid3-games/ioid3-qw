Index: code/cgame/cg_effects.c
===================================================================
--- code/cgame/cg_effects.c	(revision 3359)
+++ code/cgame/cg_effects.c	(working copy)
@@ -59,17 +59,17 @@
 
 		le = CG_AllocLocalEntity();
 		le->leFlags = LEF_PUFF_DONT_SCALE;
-		le->leType = LE_MOVE_SCALE_FADE;
+		le->leType = LE_BUBBLE;
+		le->endTime = cg.time + 8000 + random() * 250;
 		le->startTime = cg.time;
-		le->endTime = cg.time + 1000 + random() * 250;
 		le->lifeRate = 1.0 / ( le->endTime - le->startTime );
 
 		re = &le->refEntity;
-		re->shaderTime = cg.time / 1000.0f;
+		re->shaderTime = cg.time;
 
 		re->reType = RT_SPRITE;
 		re->rotation = 0;
-		re->radius = 3;
+		re->radius = 2 + random() * 2;
 		re->customShader = cgs.media.waterBubbleShader;
 		re->shaderRGBA[0] = 0xff;
 		re->shaderRGBA[1] = 0xff;
@@ -83,13 +83,81 @@
 		VectorCopy( move, le->pos.trBase );
 		le->pos.trDelta[0] = crandom()*5;
 		le->pos.trDelta[1] = crandom()*5;
-		le->pos.trDelta[2] = crandom()*5 + 6;
+		le->pos.trDelta[2] = 85 + random()*10;
 
+		VectorCopy( move, re->origin );
 		VectorAdd (move, vec, move);
 	}
 }
 
 /*
+==================
+CG_SpawnBubbles
+==================
+*/
+int CG_SpawnBubbles( localEntity_t **bubbles, vec3_t origin, float baseSize, int numBubbles ) {
+	int			i;
+	float		rnd;
+	qboolean	spawnedLarge;
+
+	spawnedLarge = qfalse;
+
+	for ( i = 0; i < numBubbles; i++ ) {
+		localEntity_t	*le;
+		refEntity_t		*re;
+
+		le = CG_AllocLocalEntity();
+
+		if ( bubbles ) {
+			bubbles[i] = le;
+		}
+
+		le->leFlags = LEF_PUFF_DONT_SCALE;
+		le->leType = LE_BUBBLE;
+		le->endTime = cg.time + 8000 + random() * 250;
+		le->startTime = cg.time;
+		le->lifeRate = 1.0 / ( le->endTime - le->startTime );
+
+		re = &le->refEntity;
+		re->shaderTime = cg.time;
+
+		re->reType = RT_SPRITE;
+		re->rotation = 0;
+
+		rnd = random();
+		if (rnd > 0.9f && !spawnedLarge) {
+			spawnedLarge = qtrue;
+			re->radius = baseSize * 3;
+		} else {
+			re->radius = baseSize + rnd * baseSize;
+		}
+
+		re->customShader = cgs.media.waterBubbleShader;
+		re->shaderRGBA[0] = 0xff;
+		re->shaderRGBA[1] = 0xff;
+		re->shaderRGBA[2] = 0xff;
+		re->shaderRGBA[3] = 0xff;
+
+		le->color[3] = 1.0;
+
+		le->pos.trType = TR_LINEAR;
+		le->pos.trTime = cg.time;
+
+		VectorCopy( origin, le->pos.trBase );
+		VectorCopy( origin, re->origin );
+		le->pos.trBase[0] += crandom() * baseSize;
+		le->pos.trBase[1] += crandom() * baseSize;
+		le->pos.trBase[2] += crandom() * baseSize;
+
+		le->pos.trDelta[0] = baseSize * crandom()*5;
+		le->pos.trDelta[1] = baseSize * crandom()*5;
+		le->pos.trDelta[2] = 85 + random()*10;
+	}
+
+	return numBubbles;
+}
+
+/*
 =====================
 CG_SmokePuff
 
@@ -564,6 +632,10 @@
 void CG_GibPlayer( vec3_t playerOrigin ) {
 	vec3_t	origin, velocity;
 
+	if ( CG_PointContents( playerOrigin, -1 ) & ( CONTENTS_WATER | CONTENTS_SLIME ) ) {
+		CG_SpawnBubbles( NULL, playerOrigin, 3, 5 + random() * 5 );
+	}
+
 	if ( !cg_blood.integer ) {
 		return;
 	}
Index: code/cgame/cg_local.h
===================================================================
--- code/cgame/cg_local.h	(revision 3365)
+++ code/cgame/cg_local.h	(working copy)
@@ -220,6 +220,7 @@
 	LE_FADE_RGB,
 	LE_SCALE_FADE,
 	LE_SCOREPLUM,
+	LE_BUBBLE,
 #ifdef MISSIONPACK
 	LE_KAMIKAZE,
 	LE_INVULIMPACT,
@@ -1407,6 +1408,7 @@
 				   int leFlags,
 				   qhandle_t hShader );
 void CG_BubbleTrail( vec3_t start, vec3_t end, float spacing );
+int CG_SpawnBubbles( localEntity_t **bubbles, vec3_t origin, float baseSize, int numBubbles );
 void CG_SpawnEffect( vec3_t org );
 #ifdef MISSIONPACK
 void CG_KamikazeEffect( vec3_t org );
Index: code/cgame/cg_localents.c
===================================================================
--- code/cgame/cg_localents.c	(revision 3365)
+++ code/cgame/cg_localents.c	(working copy)
@@ -842,9 +842,35 @@
 	}
 }
 
+/*
+====================
+CG_BubbleThink
+====================
+*/
+void CG_BubbleThink( localEntity_t *le ) {
+	int contents;
+	vec3_t	newOrigin;
+	trace_t	trace;
 
+	// calculate new position
+	BG_EvaluateTrajectory( &le->pos, cg.time, newOrigin );
 
+	// trace a line from previous position to new position
+	CG_Trace( &trace, le->refEntity.origin, NULL, NULL, newOrigin, -1, CONTENTS_SOLID );
 
+	contents = CG_PointContents( trace.endpos, -1 );
+	if ( !( contents & ( CONTENTS_WATER | CONTENTS_SLIME | CONTENTS_LAVA ) ) ) {
+		// Bubble isn't in liquid anymore, remove it.
+		CG_FreeLocalEntity( le );
+		return;
+	}
+
+	CG_AddMoveScaleFade( le );
+}
+
+
+
+
 //==============================================================================
 
 /*
@@ -913,6 +939,10 @@
 			CG_AddScorePlum( le );
 			break;
 
+		case LE_BUBBLE:
+			CG_BubbleThink( le );
+			break;
+
 #ifdef MISSIONPACK
 		case LE_KAMIKAZE:
 			CG_AddKamikaze( le );
Index: code/cgame/cg_players.c
===================================================================
--- code/cgame/cg_players.c	(revision 3362)
+++ code/cgame/cg_players.c	(working copy)
@@ -1532,43 +1532,71 @@
 	smoke->leType = LE_SCALE_FADE;
 }
 
+/*
+===============
+CG_BreathPuff
+===============
+*/
+static void CG_BreathPuff( int clientNum, vec3_t origin, vec3_t *axis ) {
+	int				contents;
+	localEntity_t	*puffs[ 3 + 5 ] = { 0 };
+
+	contents = CG_PointContents( origin, 0 );
+
+	if ( contents & ( CONTENTS_WATER | CONTENTS_SLIME ) ) {
+		CG_SpawnBubbles( puffs, origin, 2, (int)( 3 + random() * 5 ) );
+	} else {
 #ifdef MISSIONPACK
+		if ( cg_enableBreath.integer ) {
+			vec3_t up;
+
+			VectorSet( up, 0, 0, 8 );
+
+			puffs[0] = CG_SmokePuff( origin, up, 16, 1, 1, 1, 0.66f, 1500, cg.time, cg.time + 400, LEF_PUFF_DONT_SCALE, cgs.media.shotgunSmokePuffShader );
+		}
+#endif
+	}
+}
+
 /*
 ===============
-CG_BreathPuffs
+CG_AddBreathPuffs
 ===============
 */
-static void CG_BreathPuffs( centity_t *cent, refEntity_t *head) {
+static void CG_AddBreathPuffs( centity_t *cent, refEntity_t *head ) {
 	clientInfo_t *ci;
-	vec3_t up, origin;
-	int contents;
+	vec3_t origin;
 
+	if ( cent->currentState.number >= MAX_CLIENTS ) {
+		return;
+	}
 	ci = &cgs.clientinfo[ cent->currentState.number ];
 
-	if (!cg_enableBreath.integer) {
-		return;
-	}
-	if ( cent->currentState.number == cg.snap->ps.clientNum && !cg.renderingThirdPerson) {
-		return;
-	}
 	if ( cent->currentState.eFlags & EF_DEAD ) {
 		return;
 	}
-	contents = CG_PointContents( head->origin, 0 );
-	if ( contents & ( CONTENTS_WATER | CONTENTS_SLIME | CONTENTS_LAVA ) ) {
-		return;
-	}
 	if ( ci->breathPuffTime > cg.time ) {
 		return;
 	}
 
-	VectorSet( up, 0, 0, 8 );
-	VectorMA(head->origin, 8, head->axis[0], origin);
-	VectorMA(origin, -4, head->axis[2], origin);
-	CG_SmokePuff( origin, up, 16, 1, 1, 1, 0.66f, 1500, cg.time, cg.time + 400, LEF_PUFF_DONT_SCALE, cgs.media.shotgunSmokePuffShader );
+	// Add first person effects
+	if ( cent->currentState.number == cg.snap->ps.clientNum && !cg.renderingThirdPerson ) {
+		VectorMA( cg.refdef.vieworg, 20, cg.refdef.viewaxis[0], origin );
+		VectorMA( origin, -4, cg.refdef.viewaxis[2], origin );
+
+		CG_BreathPuff( cent->currentState.number, origin, cg.refdef.viewaxis );
+	}
+
+	// Add third person effects for mirrors
+	VectorMA( head->origin, 8, head->axis[0], origin );
+	VectorMA( origin, -4, head->axis[2], origin );
+
+	CG_BreathPuff( cent->currentState.number, origin, head->axis );
+
 	ci->breathPuffTime = cg.time + 2000;
 }
 
+#ifdef MISSIONPACK
 /*
 ===============
 CG_DustTrail
@@ -2578,9 +2606,9 @@
 
 	CG_AddRefEntityWithPowerups( &head, &cent->currentState, ci->team );
 
+	CG_AddBreathPuffs( cent, &head );
+
 #ifdef MISSIONPACK
-	CG_BreathPuffs(cent, &head);
-
 	CG_DustTrail(cent);
 #endif
 
