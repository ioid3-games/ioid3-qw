Index: code/cgame/cg_ents.c
===================================================================
--- code/cgame/cg_ents.c	(revision 3359)
+++ code/cgame/cg_ents.c	(working copy)
@@ -432,10 +432,10 @@
 		weapon->missileTrailFunc( cent, weapon );
 	}
 /*
-	if ( cent->currentState.modelindex == TEAM_RED ) {
+	if ( s1->team == TEAM_RED ) {
 		col = 1;
 	}
-	else if ( cent->currentState.modelindex == TEAM_BLUE ) {
+	else if ( s1->team == TEAM_BLUE ) {
 		col = 2;
 	}
 	else {
@@ -484,7 +484,7 @@
 
 #ifdef MISSIONPACK
 	if ( cent->currentState.weapon == WP_PROX_LAUNCHER ) {
-		if (s1->generic1 == TEAM_BLUE) {
+		if (s1->team == TEAM_BLUE) {
 			ent.hModel = cgs.media.blueProxMine;
 		}
 	}
Index: code/cgame/cg_newdraw.c
===================================================================
--- code/cgame/cg_newdraw.c	(revision 3361)
+++ code/cgame/cg_newdraw.c	(working copy)
@@ -718,7 +718,7 @@
 	char num[16];
 	vec3_t origin, angles;
 	qhandle_t handle;
-	int value = cg.snap->ps.generic1;
+	int value = cg.snap->ps.tokens;
 
 	if (cgs.gametype != GT_HARVESTER) {
 		return;
Index: code/cgame/cg_players.c
===================================================================
--- code/cgame/cg_players.c	(revision 3359)
+++ code/cgame/cg_players.c	(working copy)
@@ -1778,7 +1778,7 @@
 		return;
 	}
 	trail = &cg.skulltrails[cent->currentState.number];
-	tokens = cent->currentState.generic1;
+	tokens = cent->currentState.tokens;
 	if ( !tokens ) {
 		trail->numpositions = 0;
 		return;
Index: code/game/ai_dmnet.c
===================================================================
--- code/game/ai_dmnet.c	(revision 3359)
+++ code/game/ai_dmnet.c	(working copy)
@@ -1390,7 +1390,7 @@
 		}
 		if (bestmine != -1) {
 			//
-			// state->generic1 == TEAM_RED || state->generic1 == TEAM_BLUE
+			// state->team == TEAM_RED || state->team == TEAM_BLUE
 			//
 			// deactivate prox mines in the bot's path by shooting
 			// rockets or plasma cells etc. at them
Index: code/game/ai_dmq3.c
===================================================================
--- code/game/ai_dmq3.c	(revision 3359)
+++ code/game/ai_dmq3.c	(working copy)
@@ -309,7 +309,7 @@
 		return qfalse;
 	//FIXME: get this info from the aas_entityinfo_t ?
 	BotAI_GetEntityState(entinfo->number, &state);
-	if (state.generic1 > 0)
+	if (state.tokens > 0)
 		return qtrue;
 	return qfalse;
 }
@@ -1775,12 +1775,12 @@
 #ifdef MISSIONPACK
 	bs->inventory[INVENTORY_NEUTRALFLAG] = bs->cur_ps.powerups[PW_NEUTRALFLAG] != 0;
 	if (BotTeam(bs) == TEAM_RED) {
-		bs->inventory[INVENTORY_REDCUBE] = bs->cur_ps.generic1;
+		bs->inventory[INVENTORY_REDCUBE] = bs->cur_ps.tokens;
 		bs->inventory[INVENTORY_BLUECUBE] = 0;
 	}
 	else {
 		bs->inventory[INVENTORY_REDCUBE] = 0;
-		bs->inventory[INVENTORY_BLUECUBE] = bs->cur_ps.generic1;
+		bs->inventory[INVENTORY_BLUECUBE] = bs->cur_ps.tokens;
 	}
 #endif
 	BotCheckItemPickup(bs, oldinventory);
@@ -4734,7 +4734,7 @@
 	if (state->eType != ET_MISSILE || state->weapon != WP_PROX_LAUNCHER)
 		return;
 	// if this prox mine is from someone on our own team
-	if (state->generic1 == BotTeam(bs))
+	if (state->team == BotTeam(bs))
 		return;
 	// if the bot doesn't have a weapon to deactivate the mine
 	if (!(bs->inventory[INVENTORY_PLASMAGUN] > 0 && bs->inventory[INVENTORY_CELLS] > 0) &&
Index: code/game/bg_misc.c
===================================================================
--- code/game/bg_misc.c	(revision 3360)
+++ code/game/bg_misc.c	(working copy)
@@ -1113,12 +1113,9 @@
 		}
 
 		// check team only
-		if( ( ent->generic1 & 2 ) && ( ps->persistant[PERS_TEAM] != TEAM_RED ) ) {
+		if( ent->team != 255 && ( ps->persistant[PERS_TEAM] != ent->team ) ) {
 			return qfalse;
 		}
-		if( ( ent->generic1 & 4 ) && ( ps->persistant[PERS_TEAM] != TEAM_BLUE ) ) {
-			return qfalse;
-		}
 
 		return qtrue;
 #endif
@@ -1526,7 +1523,8 @@
 	}
 
 	s->loopSound = ps->loopSound;
-	s->generic1 = ps->generic1;
+	s->tokens = ps->tokens;
+	s->team = ps->persistant[PERS_TEAM];
 }
 
 /*
@@ -1606,7 +1604,8 @@
 	}
 
 	s->loopSound = ps->loopSound;
-	s->generic1 = ps->generic1;
+	s->tokens = ps->tokens;
+	s->team = ps->persistant[PERS_TEAM];
 }
 
 
Index: code/game/g_active.c
===================================================================
--- code/game/g_active.c	(revision 3361)
+++ code/game/g_active.c	(working copy)
@@ -603,7 +603,7 @@
 
 #ifdef MISSIONPACK
 			if ( g_gametype.integer == GT_HARVESTER ) {
-				if ( ent->client->ps.generic1 > 0 ) {
+				if ( ent->client->ps.tokens > 0 ) {
 					if ( ent->client->sess.sessionTeam == TEAM_RED ) {
 						item = BG_FindItem( "Blue Cube" );
 					} else {
@@ -610,16 +610,16 @@
 						item = BG_FindItem( "Red Cube" );
 					}
 					if ( item ) {
-						for ( j = 0; j < ent->client->ps.generic1; j++ ) {
+						for ( j = 0; j < ent->client->ps.tokens; j++ ) {
 							drop = Drop_Item( ent, item, 0 );
 							if ( ent->client->sess.sessionTeam == TEAM_RED ) {
-								drop->spawnflags = TEAM_BLUE;
+								drop->s.team = TEAM_BLUE;
 							} else {
-								drop->spawnflags = TEAM_RED;
+								drop->s.team = TEAM_RED;
 							}
 						}
 					}
-					ent->client->ps.generic1 = 0;
+					ent->client->ps.tokens = 0;
 				}
 			}
 #endif
Index: code/game/g_combat.c
===================================================================
--- code/game/g_combat.c	(revision 3359)
+++ code/game/g_combat.c	(working copy)
@@ -142,7 +142,7 @@
 	vec3_t		angles;
 	vec3_t		origin;
 
-	self->client->ps.generic1 = 0;
+	self->client->ps.tokens = 0;
 
 	// this should never happen but we should never
 	// get the server to crash due to skull being spawned in
@@ -176,7 +176,7 @@
 
 	drop->nextthink = level.time + g_cubeTimeout.integer * 1000;
 	drop->think = G_FreeEntity;
-	drop->spawnflags = self->client->sess.sessionTeam;
+	drop->s.team = self->client->sess.sessionTeam;
 }
 
 
@@ -404,7 +404,7 @@
 	char		*classname;
 
 	// if the player was carrying cubes
-	if ( self->client->ps.generic1 ) {
+	if ( self->client->ps.tokens ) {
 		if ( self->client->sess.sessionTeam == TEAM_BLUE ) {
 			classname = "team_redobelisk";
 		}
Index: code/game/g_items.c
===================================================================
--- code/game/g_items.c	(revision 3359)
+++ code/game/g_items.c	(working copy)
@@ -908,7 +908,17 @@
 
 #ifdef MISSIONPACK
 	if ( item->giType == IT_PERSISTANT_POWERUP ) {
-		ent->s.generic1 = ent->spawnflags;
+		qboolean redTeam = !!( ent->spawnflags & 2 );
+		qboolean blueTeam = !!( ent->spawnflags & 4 );
+
+		// only one team can pick it up
+		if ( redTeam && !blueTeam )
+			ent->s.team = TEAM_RED;
+		else if ( blueTeam && !redTeam )
+			ent->s.team = TEAM_BLUE;
+		// allow all players to pick it up
+		else
+			ent->s.team = 255;
 	}
 #endif
 }
Index: code/game/g_missile.c
===================================================================
--- code/game/g_missile.c	(revision 3359)
+++ code/game/g_missile.c	(working copy)
@@ -140,7 +140,7 @@
 
 	if ( g_gametype.integer >= GT_TEAM ) {
 		// don't trigger same team mines
-		if (trigger->parent->s.generic1 == other->client->sess.sessionTeam) {
+		if (trigger->parent->s.team == other->client->sess.sessionTeam) {
 			return;
 		}
 	}
@@ -794,7 +794,7 @@
 	bolt->count = 0;
 
 	//FIXME: we prolly wanna abuse another field
-	bolt->s.generic1 = self->client->sess.sessionTeam;
+	bolt->s.team = self->client->sess.sessionTeam;
 
 	bolt->s.pos.trType = TR_GRAVITY;
 	bolt->s.pos.trTime = level.time - MISSILE_PRESTEP_TIME;		// move a bit on the very first frame
Index: code/game/g_public.h
===================================================================
--- code/game/g_public.h	(revision 3361)
+++ code/game/g_public.h	(working copy)
@@ -36,7 +36,7 @@
 #define SVF_CLIENTMASK 0x00000002
 
 #define SVF_BOT					0x00000008	// set if the entity is a bot
-#define	SVF_BROADCAST			0x00000020	// send to all connected clients
+#define	SVF_BROADCAST			0x00000020	// send to all connected clients (r.cullDistance will still be checked)
 #define	SVF_PORTAL				0x00000040	// merge a second pvs at origin2 into snapshots
 #define	SVF_USE_CURRENT_ORIGIN	0x00000080	// entity->r.currentOrigin instead of entity->s.origin
 											// for link position (missiles and movers)
@@ -87,6 +87,8 @@
 	// ent->r.ownerNum == passEntityNum	(don't interact with your own missiles)
 	// entity[ent->r.ownerNum].r.ownerNum == passEntityNum	(don't interact with other missiles from owner)
 	int			ownerNum;
+	// if set, portal entities are only sent to client if distance between portal and player <= portalCullDistance
+	int			portalCullDistance;
 } entityShared_t;
 
 
Index: code/game/g_team.c
===================================================================
--- code/game/g_team.c	(revision 3359)
+++ code/game/g_team.c	(working copy)
@@ -274,7 +274,6 @@
 	gentity_t *ent;
 	int flag_pw, enemy_flag_pw;
 	int otherteam;
-	int tokens;
 	gentity_t *flag, *carrier = NULL;
 	char *c;
 	vec3_t v1, v2;
@@ -306,12 +305,6 @@
 #endif
 
 	// did the attacker frag the flag carrier?
-	tokens = 0;
-#ifdef MISSIONPACK
-	if( g_gametype.integer == GT_HARVESTER ) {
-		tokens = targ->client->ps.generic1;
-	}
-#endif
 	if (targ->client->ps.powerups[enemy_flag_pw]) {
 		attacker->client->pers.teamState.lastfraggedcarrier = level.time;
 		AddScore(attacker, targ->r.currentOrigin, CTF_FRAG_CARRIER_BONUS);
@@ -328,9 +321,10 @@
 		}
 		return;
 	}
+	// did the attacker frag a skull carrier?
+	if (g_gametype.integer == GT_HARVESTER && targ->client->ps.tokens) {
+		int tokens = targ->client->ps.tokens;
 
-	// did the attacker frag a head carrier? other->client->ps.generic1
-	if (tokens) {
 		attacker->client->pers.teamState.lastfraggedcarrier = level.time;
 		AddScore(attacker, targ->r.currentOrigin, CTF_FRAG_CARRIER_BONUS * tokens * tokens);
 		attacker->client->pers.teamState.fragcarrier++;
@@ -499,7 +493,7 @@
 		attacker->client->pers.teamState.lasthurtcarrier = level.time;
 
 	// skulls
-	if (targ->client->ps.generic1 &&
+	if (targ->client->ps.tokens &&
 		targ->client->sess.sessionTeam != attacker->client->sess.sessionTeam)
 		attacker->client->pers.teamState.lasthurtcarrier = level.time;
 }
@@ -846,8 +840,8 @@
 
 	if( g_gametype.integer == GT_HARVESTER ) {
 		// the only team items that can be picked up in harvester are the cubes
-		if( ent->spawnflags != cl->sess.sessionTeam ) {
-			cl->ps.generic1 += 1;
+		if( ent->s.team != cl->sess.sessionTeam ) {
+			cl->ps.tokens += 1;
 		}
 		G_FreeEntity( ent );
 		return 0;
@@ -1265,7 +1259,7 @@
 		return;
 	}
 
-	tokens = other->client->ps.generic1;
+	tokens = other->client->ps.tokens;
 	if( tokens <= 0 ) {
 		return;
 	}
@@ -1284,7 +1278,7 @@
 	other->client->rewardTime = level.time + REWARD_SPRITE_TIME;
 	other->client->ps.persistant[PERS_CAPTURES] += tokens;
 	
-	other->client->ps.generic1 = 0;
+	other->client->ps.tokens = 0;
 	CalculateRanks();
 
 	Team_CaptureFlagSound( self, self->spawnflags );
Index: code/qcommon/msg.c
===================================================================
--- code/qcommon/msg.c	(revision 3359)
+++ code/qcommon/msg.c	(working copy)
@@ -775,7 +775,6 @@
 { NETF(modelindex), 8 },
 { NETF(otherEntityNum2), GENTITYNUM_BITS },
 { NETF(loopSound), 8 },
-{ NETF(generic1), 8 },
 { NETF(origin2[2]), 0 },
 { NETF(origin2[0]), 0 },
 { NETF(origin2[1]), 0 },
@@ -793,7 +792,9 @@
 { NETF(angles2[0]), 0 },
 { NETF(angles2[2]), 0 },
 { NETF(constantLight), 32 },
-{ NETF(frame), 16 }
+{ NETF(frame), 16 },
+{ NETF(tokens), 8 },
+{ NETF(team), 8 }
 };
 
 
@@ -1093,7 +1094,6 @@
 { PSF(damageYaw), 8 },
 { PSF(damagePitch), 8 },
 { PSF(damageCount), 8 },
-{ PSF(generic1), 8 },
 { PSF(pm_type), 8 },					
 { PSF(delta_angles[0]), 16 },
 { PSF(delta_angles[2]), 16 },
@@ -1106,6 +1106,7 @@
 { PSF(grapplePoint[0]), 0 },
 { PSF(grapplePoint[1]), 0 },
 { PSF(grapplePoint[2]), 0 },
+{ PSF(tokens), 8 },
 { PSF(jumppad_ent), GENTITYNUM_BITS },
 { PSF(loopSound), 16 }
 };
Index: code/qcommon/q_shared.h
===================================================================
--- code/qcommon/q_shared.h	(revision 3359)
+++ code/qcommon/q_shared.h	(working copy)
@@ -1205,7 +1205,7 @@
 	int			powerups[MAX_POWERUPS];	// level.time that the powerup runs out
 	int			ammo[MAX_WEAPONS];
 
-	int			generic1;
+	int			tokens;				// harvester skulls
 	int			loopSound;
 	int			jumppad_ent;	// jumppad entity hit this frame
 
@@ -1318,7 +1318,7 @@
 
 	int		event;			// impulse events -- muzzle flashes, footsteps, etc
 	int		eventParm;
-
+	int		team;
 	// for players
 	int		powerups;		// bit flags
 	int		weapon;			// determines weapon and flash model, etc
@@ -1325,7 +1325,7 @@
 	int		legsAnim;		// mask off ANIM_TOGGLEBIT
 	int		torsoAnim;		// mask off ANIM_TOGGLEBIT
 
-	int		generic1;
+	int		tokens;			// harvester skulls
 } entityState_t;
 
 typedef enum {
Index: code/server/sv_snapshot.c
===================================================================
--- code/server/sv_snapshot.c	(revision 3359)
+++ code/server/sv_snapshot.c	(working copy)
@@ -413,10 +413,10 @@
 
 		// if it's a portal entity, add everything visible from its camera position
 		if ( ent->r.svFlags & SVF_PORTAL ) {
-			if ( ent->s.generic1 ) {
+			if ( ent->r.portalCullDistance ) {
 				vec3_t dir;
 				VectorSubtract(ent->s.origin, origin, dir);
-				if ( VectorLengthSquared(dir) > (float) ent->s.generic1 * ent->s.generic1 ) {
+				if ( VectorLengthSquared(dir) > (float) ent->r.portalCullDistance * ent->r.portalCullDistance ) {
 					continue;
 				}
 			}
