Index: code/botlib/be_ai_move.c
===================================================================
--- code/botlib/be_ai_move.c	(revision 3447)
+++ code/botlib/be_ai_move.c	(working copy)
@@ -1321,7 +1321,7 @@
 bot_moveresult_t BotTravel_Walk(bot_movestate_t *ms, aas_reachability_t *reach)
 {
 	float dist, speed, currentspeed;
-	vec3_t hordir;
+	vec3_t hordir, sideward, up = {0, 0, 1};
 	bot_moveresult_t_cleared( result );
 
 	//first walk straight to the reachability start
@@ -1349,6 +1349,8 @@
 		if (dist < (200 + currentspeed) * 0.1f) EA_Crouch(ms->client);
 	} //end if
 	//
+// Tobias NOTE: These code changes are very map dependant (q3dm6, q3dm7, q3dm12), maybe delete all this gap checking code at all (at least for QW maps, or keep it only for obstacles?)
+/*
 	dist = BotGapDistance(ms->origin, hordir, 100, ms->entitynum);
 	//
 	if (ms->moveflags & MFL_WALK)
@@ -1361,6 +1363,76 @@
 		if (dist > 0) speed = 400 - (360 - 2 * dist);
 		else speed = 400;
 	} //end else
+*/
+/*
+	dist = BotGapDistance(ms->origin, hordir, 200, ms->entitynum);
+	//
+	if (ms->moveflags & MFL_WALK)
+	{
+		speed = 200;
+	} //end if
+	else
+	{
+		if (dist > 0) {
+			VectorNormalize(hordir);
+			//get the sideward vector
+			CrossProduct(hordir, up, sideward);
+			// start point
+			VectorMA(ms->origin, 100, sideward, start);
+			// if there is NO gap at the right side
+			if (!BotGapDistance(start, hordir, 200, ms->entitynum)) {
+				speed = 400;
+				EA_Move(ms->client, sideward, speed);
+#ifdef DEBUG
+				botimport.Print(PRT_MESSAGE, S_COLOR_GREEN "Found a gap at %f: Moving to the right side (Speed: %f)\n", dist, currentspeed);
+#endif //DEBUG
+			} else {
+				VectorNegate(sideward, sideward);
+				speed = 400;
+				EA_Move(ms->client, sideward, speed);
+#ifdef DEBUG
+				botimport.Print(PRT_MESSAGE, S_COLOR_YELLOW "Found a gap at %f: Moving to the left side (Speed: %f)\n", dist, currentspeed);
+#endif //DEBUG
+			}
+		} else {
+			speed = 400;
+		}
+	} //end else
+*/
+	dist = BotGapDistance(ms->origin, hordir, 200, ms->entitynum);
+
+	if (ms->moveflags & MFL_WALK)
+	{
+		speed = 200;
+	} //end if
+	else
+	{
+		if (dist > 0) speed = 400 - (200 - dist);
+		else speed = 400;
+	} //end else
+
+	if (dist > 0) {
+		VectorNormalize(hordir);
+		//get the sideward vector
+		CrossProduct(hordir, up, sideward);
+		// if there is NO gap at the right side
+		if (!BotGapDistance(ms->origin, sideward, 100, ms->entitynum)) {
+			EA_Move(ms->client, sideward, 400);
+#ifdef DEBUG
+			botimport.Print(PRT_MESSAGE, S_COLOR_GREEN "Found a gap at %f: Moving to the right side (Speed: %f)\n", dist, currentspeed);
+#endif //DEBUG
+		} else {
+			VectorNegate(sideward, sideward);
+			// if there is NO gap at the left side
+			if (!BotGapDistance(ms->origin, sideward, 100, ms->entitynum)) {
+				EA_Move(ms->client, sideward, 400);
+#ifdef DEBUG
+				botimport.Print(PRT_MESSAGE, S_COLOR_YELLOW "Found a gap at %f: Moving to the left side (Speed: %f)\n", dist, currentspeed);
+#endif //DEBUG
+			}
+		}
+	} //end else
+// Tobias END
 	//elemantary action move in direction
 	EA_Move(ms->client, hordir, speed);
 	VectorCopy(hordir, result.movedir);
